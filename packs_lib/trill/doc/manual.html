<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Riccardo Zese riccardo.zese@unife.it" />
  <title>TRILL Manual</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">TRILL Manual</h1>
<p class="subtitle">SWI-Prolog Version</p>
<p class="author">Riccardo Zese<br />
riccardo.zese@unife.it</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a>
<ul>
<li><a href="#example-of-use">Example of use</a></li>
</ul></li>
<li><a href="#syn">Syntax</a>
<ul>
<li><a href="#trill-syn">Prolog Syntax</a>
<ul>
<li><a href="#declarations">Declarations</a></li>
<li><a href="#axioms">Axioms</a></li>
<li><a href="#concepts-descriptions">Concepts descriptions</a></li>
</ul></li>
<li><a href="#rdfxml-syn">RDF/XML syntax and tools</a></li>
</ul></li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#inf">Inference</a>
<ul>
<li><a href="#queries">Possible Queries</a>
<ul>
<li><a href="#probabilistic-queries">Probabilistic Queries</a></li>
<li><a href="#non-probabilistic-queries">Non Probabilistic Queries</a></li>
</ul></li>
<li><a href="#query-options">Query Options</a></li>
<li><a href="#trill-useful-predicates">TRILL Useful Predicates</a></li>
</ul></li>
<li><a href="#loading-a-kb-in-trill">Loading a KB in TRILL</a>
<ul>
<li><a href="#case-1-self-contained-prolog-file">Case 1: Self-Contained Prolog File</a>
<ul>
<li><a href="#sec:trillq1">Executing a Query</a></li>
</ul></li>
<li><a href="#case-2-independent-kb-file">Case 2: Independent KB File</a>
<ul>
<li><a href="#sec:trillq2">Executing a Query</a></li>
</ul></li>
</ul></li>
<li><a href="#files">Files</a></li>
<li><a href="#license">License</a></li>
<li><a href="#app:dl">Description Logics</a></li>
<li><a href="#app:disponte">DISPONTE</a></li>
<li><a href="#app:inf">Inference</a>
<ul>
<li><a href="#computing-queries-probability">Computing Queries Probability</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>TRILL is a framework born from the original TRILL project whose contained a single reasoner <span class="citation" data-cites="ZesBelLamRig13-CILC13-NC">[<a href="#ref-ZesBelLamRig13-CILC13-NC" role="doc-biblioref">23</a>]</span>. The name of this reasoner, TRILL, is an acronym for “Tableau Reasoner for descrIption Logics in Prolog”. In the next years, this project has been extended to the current framework (<span class="citation" data-cites="ZesBelRig16-AMAI-IJ Zese17-SSW-BK ZesBelCot19-TPLP-IJ">[<a href="#ref-Zese17-SSW-BK" role="doc-biblioref">21</a>,<a href="#ref-ZesBelRig16-AMAI-IJ" role="doc-biblioref">24</a>,<a href="#ref-ZesBelCot19-TPLP-IJ" role="doc-biblioref">25</a>]</span>) that contains three different reasoners:</p>
<ul>
<li><p>TRILL, which implements a tableau algorithm in Prolog to compute the set of all the explanations of a query;</p></li>
<li><p>TRILL<span class="math inline">\(^P\)</span> (“TRILL powered by Pinpointing formulas”), which is able to compute a Boolean formula, called <em>pinpointing formula</em>, representing the set of explanations for a query;</p></li>
<li><p>TORNADO (“Trill powered by pinpOinting foRmula and biNAry DecisiOn diagrams”) which represent the pinpointing formula directly as a binary decision diagram, simplifying the management of the formula.</p></li>
</ul>
<p>After generating the set of explanations or of the pinpointing formula, TRILL and TRILL<span class="math inline">\(^P\)</span> represent them as a binary decision diagram. From this diagram, all the reasoners of this framework can computes the probability of the query. The management of the tableau rules’ non-determinism is delegated to the Prolog language.</p>
<p>The TRILL framework forms a layer cake, shown in Figure <a href="#fig:trill_arch" data-reference-type="ref" data-reference="fig:trill_arch">1</a>, designed to facilitate its extension. The lower layer, called “Translation Utilities”, contains a library for translating the input KB in case it is given in the RDF/XML format and loading it in the Prolog database, in order to be accessible to the upper layers.</p>
<figure>
<img src="img/trill-architecture" id="fig:trill_arch" alt="" /><figcaption>Software architecture of the old version of TRILL.</figcaption>
</figure>
<p>TRILL framework is available in two versions, one for Yap Prolog and one for SWI-Prolog. They differ slightly in the features offered. The Yap version differs principally in the absence of the translation module form OWL/RDF to TRILL syntax and in a different management of the explanations in TRILL<span class="math inline">\(^P\)</span>. the Yap version also lacks of TORNADO and it is no more maintained.</p>
<h1 id="installation">Installation</h1>
<p>TRILL is distributed as a <a href="http://www.swi-prolog.org/pack/list?p=trill">pack</a> of <a href="http://www.swi-prolog.org/">SWI-Prolog</a>. It can be installed with <code>pack_install/1</code></p>
<pre><code>$ swipl
?- pack_install(trill).</code></pre>
<p>It requires the packs <code>bddem</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. It is installed automatically when installing pack <code>trill</code> or can installed manually as</p>
<pre><code>$ swipl
?- pack_install(bddem).</code></pre>
<p>The package <code>bddem</code> uses a foreign library and contains the library binaries for 32 and 64 bits Linux and 64 bits Windows. If you want to recompile the foreign library you can use</p>
<pre><code>?- pack_rebuild(bdeem).</code></pre>
<p>On 32 and 64 bits Linux this should work out of the box. On 64 bits Windows the library must be rebuilt by hand, see the pack page <a href="https://github.com/friguzzi/bddem">https://github.com/friguzzi/bddem</a></p>
<p>You can upgrade the pack with</p>
<pre><code>$ swipl
?- pack_upgrade(trill).</code></pre>
<p>Note that the pack on which <code>trill</code> depends are not upgraded automatically in this case so they need to be upgraded manually.</p>
<p>To test the system you can simply run the following commands</p>
<pre><code>$ swipl
?- [library(trill_test/test)].
?- test.</code></pre>
<h2 id="example-of-use">Example of use</h2>
<pre><code>$ cd &lt;pack&gt;/trill/prolog/examples
$ swipl
?- [library(examples/peoplePets)].
?- prob_instanceOf(&#39;natureLover&#39;,&#39;Kevin&#39;,Prob).</code></pre>
<h1 id="syn">Syntax</h1>
<p>Description Logics (DLs) are knowledge representation formalisms that are at the basis of the Semantic Web <span class="citation" data-cites="DBLP:conf/dlog/2003handbook dlchap">[<a href="#ref-DBLP:conf/dlog/2003handbook" role="doc-biblioref">1</a>,<a href="#ref-dlchap" role="doc-biblioref">2</a>]</span> and are used for modelling ontologies. They are represented using a syntax based on concepts, basically sets of individuals of the domain, and roles, sets of pairs of individuals of the domain. A more formal description can be found in the Appendix <a href="#app:dl" data-reference-type="ref" data-reference="app:dl">9</a>.</p>
<p>TRILL allows the use of two different syntaxes used together or individually:</p>
<ul>
<li><p>RDF/XML</p></li>
<li><p>Prolog syntax</p></li>
</ul>
<p>RDF/XML syntax can be used by exploiting the predicate <code>owl_rdf/1</code>. For example:</p>
<pre><code>owl_rdf(&#39;
&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE rdf:RDF [
    &lt;!ENTITY owl &quot;http://www.w3.org/2002/07/owl#&quot; &gt;
    &lt;!ENTITY xsd &quot;http://www.w3.org/2001/XMLSchema#&quot; &gt;
    &lt;!ENTITY rdfs &quot;http://www.w3.org/2000/01/rdf-schema#&quot; &gt;
    &lt;!ENTITY rdf &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; &gt;
]&gt;
&lt;rdf:RDF xmlns=&quot;http://here.the.IRI.of.your.ontology#&quot;
     xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;
     xmlns:owl=&quot;http://www.w3.org/2002/07/owl#&quot;
     xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema#&quot;
     xmlns:rdfs=&quot;http://www.w3.org/2000/01/rdf-schema#&quot;&gt;
    &lt;owl:Ontology rdf:about=&quot;http://here.the.IRI.of.your.ontology&quot;/&gt;

    &lt;!-- 
    Axioms
    --&gt;

&lt;/rdf:RDF&gt;
&#39;).</code></pre>
<p>For a brief introduction on RDF/XML syntax see <em>RDF/XML syntax and tools</em> section below (Sec. <a href="#rdfxml-syn" data-reference-type="ref" data-reference="rdfxml-syn">3.2</a>).</p>
<p>Note that each single <code>owl_rdf/1</code> must be self contained and well formatted, it must start and end with <code>rdf:RDF</code> tag and contain all necessary declarations (namespaces, entities, ...).</p>
<p>An example of the combination of both syntaxes is shown the example <a href="http://trill-sw.eu/example/trill/johnEmployee.pl"><code>johnEmployee.pl</code></a>. It models that <em>john</em> is an <em>employee</em> and that employees are <em>workers</em>, which are in turn people (modeled by the concept <em>person</em>).</p>
<pre><code>owl_rdf(&#39;&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;rdf:RDF xmlns=&quot;http://example.foo#&quot;
     xml:base=&quot;http://example.foo&quot;
     xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;
     xmlns:owl=&quot;http://www.w3.org/2002/07/owl#&quot;
     xmlns:xml=&quot;http://www.w3.org/XML/1998/namespace&quot;
     xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema#&quot;
     xmlns:rdfs=&quot;http://www.w3.org/2000/01/rdf-schema#&quot;&gt;
    &lt;owl:Ontology rdf:about=&quot;http://example.foo&quot;/&gt;

    &lt;!-- Classes --&gt;
    &lt;owl:Class rdf:about=&quot;http://example.foo#worker&quot;&gt;
        &lt;rdfs:subClassOf rdf:resource=&quot;http://example.foo#person&quot;/&gt;
    &lt;/owl:Class&gt;

&lt;/rdf:RDF&gt;&#39;).

subClassOf(&#39;employee&#39;,&#39;worker&#39;).

owl_rdf(&#39;&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;rdf:RDF xmlns=&quot;http://example.foo#&quot;
     xml:base=&quot;http://example.foo&quot;
     xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;
     xmlns:owl=&quot;http://www.w3.org/2002/07/owl#&quot;
     xmlns:xml=&quot;http://www.w3.org/XML/1998/namespace&quot;
     xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema#&quot;
     xmlns:rdfs=&quot;http://www.w3.org/2000/01/rdf-schema#&quot;&gt;
    &lt;owl:Ontology rdf:about=&quot;http://example.foo&quot;/&gt;
    
    &lt;!-- Individuals --&gt;
    &lt;owl:NamedIndividual rdf:about=&quot;http://example.foo#john&quot;&gt;
        &lt;rdf:type rdf:resource=&quot;http://example.foo#employee&quot;/&gt;
    &lt;/owl:NamedIndividual&gt;
&lt;/rdf:RDF&gt;&#39;).</code></pre>
<h2 id="trill-syn">Prolog Syntax</h2>
<h3 id="declarations">Declarations</h3>
<p>Prolog syntax allows, as in standard OWL, the declaration of classes, properties, etc.</p>
<pre><code>class(&quot;classIRI&quot;).
datatype(&quot;datatypeIRI&quot;).
objectProperty(&quot;objectPropertyIRI&quot;).
dataProperty(&quot;dataPropertyIRI&quot;).
annotationProperty(&quot;annotationPropertyIRI&quot;).
namedIndividual(&quot;individualIRI&quot;).</code></pre>
<p>However, TRILL properly works also in their absence.</p>
<p>Prolog syntax allows also the declaration of aliases for namespaces by using the <code>kb_prefix/2</code> predicate.</p>
<pre><code>kb_prefix(&quot;foo&quot;,&quot;http://example.foo#&quot;).</code></pre>
<p>After this declaration, the prefix <code>foo</code> is available, thus, instead of <code>http://example.foo#john</code>, one can write <code>foo:john</code>. It is possible to define also an empty prefix as</p>
<pre><code>kb_prefix(&quot;&quot;,&quot;http://example.foo#&quot;).</code></pre>
<p>or as</p>
<pre><code>kb_prefix([],&quot;http://example.foo#&quot;).</code></pre>
<p>In this way <code>http://example.foo#john</code> can be written only as <code>john</code>.</p>
<p><strong>Note:</strong> Only one prefix per alias is allowed. Aliases defined in OWL/RDF part have the precedence, in case more than one prefix was assigned to the same alias, TRILL keeps only the first assignment.</p>
<h3 id="axioms">Axioms</h3>
<p>Axioms are modeled using the following predicates</p>
<pre><code>subClassOf(&quot;subClass&quot;,&quot;superClass&quot;).
equivalentClasses([list,of,classes]).
disjointClasses([list,of,classes]).
disjointUnion([list,of,classes]).

subPropertyOf(&quot;subPropertyIRI&quot;,&quot;superPropertyIRI&quot;).
equivalentProperties([list,of,properties,IRI]).
propertyDomain(&quot;propertyIRI&quot;,&quot;domainIRI&quot;).
propertyRange(&quot;propertyIRI&quot;,&quot;rangeIRI&quot;).
transitiveProperty(&quot;propertyIRI&quot;).
inverseProperties(&quot;propertyIRI&quot;,&quot;inversePropertyIRI&quot;).
symmetricProperty(&quot;propertyIRI&quot;).

sameIndividual([list,of,individuals]).
differentIndividuals([list,of,individuals]).

classAssertion(&quot;classIRI&quot;,&quot;individualIRI&quot;).
propertyAssertion(&quot;propertyIRI&quot;,&quot;subjectIRI&quot;,&quot;objectIRI&quot;).
annotationAssertion(&quot;annotationIRI&quot;,axiom,literal(&#39;value&#39;)).</code></pre>
<p>For example, for asserting that <em>employee</em> is subclass of <em>worker</em> one can use</p>
<pre><code>subClassOf(employee,worker).</code></pre>
<p>while the assertion <em>worker</em> is equal to the intersection of <em>person</em> and not <em>unemployed</em></p>
<pre><code>equivalentClasses([worker,
           intersectionOf([person,complementOf(unemployed)])]).</code></pre>
<p>Annotation assertions can be defined, for example, as</p>
<pre><code>annotationAssertion(foo:myAnnotation,
    subClassOf(employee,worker),&#39;myValue&#39;).</code></pre>
<p>In particular, an axiom can be annotated with a probability which defines the degree of belief in the truth of the axiom. See Section <a href="#semantics" data-reference-type="ref" data-reference="semantics">4</a> for details.</p>
<p>Below, an example of an probabilistic axiom, following the Prolog syntax.</p>
<pre><code>annotationAssertion(&#39;disponte:probability&#39;,
    subClassOf(employee,worker),literal(&#39;0.6&#39;)).</code></pre>
<h3 id="concepts-descriptions">Concepts descriptions</h3>
<p>Complex concepts can be defined using different operators:</p>
<p>Existential and universal quantifiers</p>
<pre><code>someValuesFrom(&quot;propertyIRI&quot;,&quot;classIRI&quot;).
allValuesFrom(&quot;propertyIRI&quot;,&quot;classIRI&quot;).</code></pre>
<p>Union and intersection of concepts</p>
<pre><code>unionOf([list,of,classes]).
intersectionOf([list,of,classes]).</code></pre>
<p>Cardinality descriptions</p>
<pre><code>exactCardinality(cardinality,&quot;propertyIRI&quot;).
exactCardinality(cardinality,&quot;propertyIRI&quot;,&quot;classIRI&quot;).
maxCardinality(cardinality,&quot;propertyIRI&quot;).
maxCardinality(cardinality,&quot;propertyIRI&quot;,&quot;classIRI&quot;).
minCardinality(cardinality,&quot;propertyIRI&quot;).
minCardinality(cardinality,&quot;propertyIRI&quot;,&quot;classIRI&quot;).</code></pre>
<p>Complement of a concept</p>
<pre><code>complementOf(&quot;classIRI&quot;).</code></pre>
<p>Nominal concept</p>
<pre><code>oneOf([list,of,classes]).</code></pre>
<p>For example, the class <em>workingman</em> is the intersection of <em>worker</em> with the union of <em>man</em> and <em>woman</em>. It can be defined as:</p>
<pre><code>equivalentClasses([workingman,
    intersectionOf([worker,unionOf([man,woman])])]).</code></pre>
<h2 id="rdfxml-syn">RDF/XML syntax and tools</h2>
<p>As said before, TRILL is able to automatically translate RDF/XML knowledge bases when passed as a string using the preticate <code>owl_rdf/1</code>.</p>
<p>Consider the following axioms</p>
<pre><code>classAssertion(Cat,fluffy)
subClassOf(Cat,Pet)
propertyAssertion(hasAnimal,kevin,fluffy)</code></pre>
<p>The first axiom states that <em>fluffy</em> is a <em>Cat</em>. The second states that every <em>Cat</em> is also a <em>Pet</em>. The third states that the role <em>hasAnimal</em> links together <em>kevin</em> and <em>fluffy</em>.</p>
<p>RDF (Resource Descritpion Framework) is a standard W3C. See the <a href="http://www.w3.org/TR/REC-rdf-syntax/">syntax specification</a> for more details. RDF is a standard XML-based used for representing knowledge by means of triples. A representations of the three axioms seen above is shown below.</p>
<pre><code>&lt;owl:NamedIndividual rdf:about=&quot;fluffy&quot;&gt;
  &lt;rdf:type rdf:resource=&quot;Cat&quot;/&gt;
&lt;/owl:NamedIndividual&gt;

&lt;owl:Class rdf:about=&quot;Cat&quot;&gt;
  &lt;rdfs:subClassOf rdf:resource=&quot;Pet&quot;/&gt;
&lt;/owl:Class&gt;

&lt;owl:ObjectProperty rdf:about=&quot;hasAnimal&quot;/&gt;
&lt;owl:NamedIndividual rdf:about=&quot;kevin&quot;&gt;
 &lt;hasAnimal rdf:resource=&quot;fluffy&quot;/&gt;
&lt;/owl:NamedIndividual&gt;</code></pre>
<p>Annotations are assertable using an extension of RDF/XML. For example the annotated axiom below, defined using the Prolog sintax</p>
<pre><code>annotationAssertion(&#39;disponte:probability&#39;,
    subClassOf(&#39;Cat&#39;,&#39;Pet&#39;),literal(&#39;0.6&#39;)).</code></pre>
<p>is modeled using RDF/XML syntax as</p>
<pre><code>&lt;owl:Class rdf:about=&quot;Cat&quot;&gt;
 &lt;rdfs:subClassOf rdf:resource=&quot;Pet&quot;/&gt;
&lt;/owl:Class&gt;
&lt;owl:Axiom&gt;
 &lt;disponte:probability rdf:datatype=&quot;&amp;amp;xsd;decimal&quot;&gt;
     0.6
 &lt;/disponte:probability&gt;
 &lt;owl:annotatedSource rdf:resource=&quot;Cat&quot;/&gt;
 &lt;owl:annotatedTarget rdf:resource=&quot;Pet&quot;/&gt;
 &lt;owl:annotatedProperty rdf:resource=&quot;&amp;amp;rdfs;subClassOf&quot;/&gt;
&lt;/owl:Axiom&gt;</code></pre>
<p>If you define the annotated axiom in the RDF/XML part, the annotation must be declared in the knowledge base as follow</p>
<pre><code>&lt;!DOCTYPE rdf:RDF [
 ...
 &lt;!ENTITY disponte &quot;https://sites.google.com/a/unife.it/ml/disponte#&quot; &gt;
]&gt;

&lt;rdf:RDF
 ...
 xmlns:disponte=&quot;https://sites.google.com/a/unife.it/ml/disponte#&quot;
 ...&gt;

 ...
 &lt;owl:AnnotationProperty rdf:about=&quot;&amp;amp;disponte;probability&quot;/&gt;
 ...
&lt;/rdf:RDF&gt;</code></pre>
<p>There are many <a href="http://www.w3.org/2001/sw/wiki/Category:Editor">editors</a> for developing knowledge bases.</p>
<h1 id="semantics">Semantics</h1>
<p>Finding the explanations for a query is important for probabilistic inference. In the following we briefly describe the DISPONTE semantics <span class="citation" data-cites="RigBelLamZes15-SW-IJ">[<a href="#ref-RigBelLamZes15-SW-IJ" role="doc-biblioref">13</a>]</span>, which requires the set of all the justifications to compute the probability of the queries.</p>
<p>DISPONTE <span class="citation" data-cites="RigBelLamZes15-SW-IJ Zese17-SSW-BK">[<a href="#ref-RigBelLamZes15-SW-IJ" role="doc-biblioref">13</a>,<a href="#ref-Zese17-SSW-BK" role="doc-biblioref">21</a>]</span> applies the distribution semantics <span class="citation" data-cites="DBLP:conf/iclp/Sato95">[<a href="#ref-DBLP:conf/iclp/Sato95" role="doc-biblioref">15</a>]</span> to Probabilistic Description Logic KBs. In DISPONTE, a <em>probabilistic knowledge base</em> <span class="math inline">\({\cal K}\)</span> contains a set of <em>probabilistic axioms</em> which take the form <span class="math display">\[\begin{aligned}
&amp; p::E\label{pax} &amp;\end{aligned}\]</span> where <span class="math inline">\(p\)</span> is a real number in <span class="math inline">\([0,1]\)</span> and <span class="math inline">\(E\)</span> is a DL axiom. The probability <span class="math inline">\(p\)</span> can be interpreted as the degree of our belief in the truth of axiom <span class="math inline">\(E\)</span>. For example, a probabilistic concept membership axiom <span class="math inline">\(p::a:C\)</span> means that we have degree of belief <span class="math inline">\(p\)</span> in <span class="math inline">\(C(a)\)</span>. A probabilistic concept inclusion axiom of the form <span class="math inline">\(p::C\sqsubseteq D\)</span> represents the fact that we believe in the truth of <span class="math inline">\(C \sqsubseteq D\)</span> with probability <span class="math inline">\(p\)</span>.</p>
<p>For more detail about probabilistic inference with the TRILL framework, we refer the interested reader to Appendix <a href="#app:disponte" data-reference-type="ref" data-reference="app:disponte">10</a> and to <span class="citation" data-cites="ZesBelCot18-TPLP-IJ">[<a href="#ref-ZesBelCot18-TPLP-IJ" role="doc-biblioref">22</a>]</span>.</p>
<p>The following example illustrates inference under the DISPONTE semantics.</p>
<p><span class="math display">\[\begin{aligned}
	&amp;&amp; (E_1)\ 0.5 ::\ &amp; \exists hasAnimal.Pet \sqsubseteq PetOwner\\
	&amp;&amp; 				&amp; {\mathit{fluffy}}: Cat \\
	&amp;&amp; 				&amp; tom: Cat \\
	&amp;&amp; (E_2)\ 0.6 ::\ &amp; Cat\sqsubseteq Pet\\
	&amp;&amp; 				&amp; (kevin,{\mathit{fluffy}}):hasAnimal \\
	&amp;&amp; 				&amp; (kevin,tom):hasAnimal
	\end{aligned}\]</span> It indicates that the individuals that own an animal which is a pet are pet owners with a 50% probability and that <span class="math inline">\(kevin\)</span> owns the animals <span class="math inline">\({\mathit{fluffy}}\)</span> and <span class="math inline">\(tom\)</span>, which are cats. Moreover, cats are pets with a 60% probability.</p>
<p>The query axiom <span class="math inline">\(Q=kevin:PetOwner\)</span> is true with probability <span class="math inline">\(P(Q)=0.5\cdot 0.6=0.3\)</span>.</p>
<p>the translation of this KB into the TRILL syntax is:</p>
<pre><code>subClassOf(someValuesFrom(hasAnimal, pet), petOwner).
annotationAssertion(disponte:probability,
                    subClassOf(someValuesFrom(hasAnimal, pet), petOwner),
                    literal(&#39;0.5&#39;))
classAssertion(cat, fluffy).
classAssertion(cat, tom).
subClassOf(cat, pet).
annotationAssertion(disponte:probability, subClassOf(cat, pet), literal(&#39;0.6&#39;))
propertyAssertion(hasAnimal, kevin, fluffy).
propertyAssertion(hasAnimal, kevin, tom).</code></pre>
<p>Optionally, the KB can also contain the following axioms</p>
<pre><code>namedIndividual(fluffy).
namedIndividual(kevin).
namedIndividual(tom).
objectProperty(hasAnimal).
annotationProperty(&#39;http://ml.unife.it/disponte#probability&#39;).
class(petOwner).
class(pet).</code></pre>
<h1 id="inf">Inference</h1>
<p>TRILL systems can answer many different queries. To do so, it exploits an algorithm called <em>tableau</em> algorithm, which is able to collect explanations. In the following you can find an example that shows how the tableau works. In section <a href="#sec:trillq" data-reference-type="ref" data-reference="sec:trillq">[sec:trillq]</a> we will see how queries can be asked with TRILL systems.</p>
<p>Consider a simple knowledge base inspired by the film “The Godfather” containing the following axioms: <span class="math display">\[\begin{aligned}
&amp;tom : Cat\\
&amp;(donVito, tom) : hasPet\\
&amp;Cat \sqsubseteq Pet\\
&amp;\exists hasAnimal.Pet \sqsubseteq NatureLover\\
&amp;NatureLover \sqsubseteq GoodPerson\\
&amp;hasPet \sqsubseteq hasAnimal\end{aligned}\]</span></p>
<p>The axioms are telling what is known about the domain: (1) Tom is an individual of the domain, and he is a Cat; (2) donVito (Vito Corleone) has tom as his pet; (3) all cats are also pets; (4) everyone having at least one animal which is a pet is a nature lover; (5) nature lovers are good people; and (6) if one has a pet, she/he also has an animal.</p>
<p>This KB can be defined by the following TRILL syntax axioms:</p>
<pre><code>classAssertion(cat, tom).
propertyAssertion(hasPet, donVito, tom).
subClassOf(cat, pet).
subClassOf(someValuesFrom(hasAnimal, pet), natureLover).
subClassOf(natureLover,goodPerson).
subPropertyOf(hasPet,hasAnimal).</code></pre>
<p>You can run this example <a href="http://trill-sw.eu/example/trill/donVito.pl">here</a>.</p>
<p>The first two axioms are assertional axioms (hence they constitute the ABox), the other four axioms define the TBox. Axiom 1 is called class assertion, 2 is called property assertion, 3,4,5 are called class subsumption axioms, and axiom 6 is called property subsumption axiom.</p>
<p>To check, for example, whether don Vito Corleone is a good person, the tableau algorithm builds a graph, called the <em>tableau</em>. The initial tableau contains information from the ABox plus the negation of the query, as depicted in Figure<a href="#fig:tab1" data-reference-type="ref" data-reference="fig:tab1">2</a>. This last axiom is added since the underlying proof mechanism uses refutation. In logic, working by refutation means assuming the opposite of the query one wants to prove. Then, if this assumption leads to a contradiction, this means that the axioms of the ontology allows to prove that the query is true, and thus that its opposite is false. In practice, working by refutation means that the graph must assume that the posed query be false, the tableau algorithm expands all the known axioms (including the negation of the query) and looks for contradictions present in the final graph. The presence of a contradiction in a node proves that the query is true because the graph depicts at least one way to contradict the negation of that query, and thus it depicts at least one way to prove that the opposite of the query contradicts what is defined by the ontology.</p>
<figure>
<img src="img/tab1.png" id="fig:tab1" alt="" /><figcaption>Initial tableau</figcaption>
</figure>
<p>This means that if the opposite of the query is (artificially) added to the knowledge base as a new axiom, this ontology will contain at least two pieces of information one contradicting the other.</p>
<p>The tableau has one node for each individual: tom is labelled as cat, <span class="math inline">\(donVito\)</span> is labelled as not a good person (the negation of the query), and the edge between them is labelled as <span class="math inline">\(hasPet\)</span> because the individuals are connected by this property (Figure <a href="#fig:tab1" data-reference-type="ref" data-reference="fig:tab1">2</a>).</p>
<p>At this point, the graph of Figure <a href="#fig:tab1" data-reference-type="ref" data-reference="fig:tab1">2</a> is expanded using the axioms of the ontology to check the truth of the query and to build the justifications. Therefore, the tableau algorithm takes e.g. the axiom 3, “cats are pets”, and adds to the node for tom also the label <span class="math inline">\(pet\)</span> since he is a cat. This new information is true and its justification is given directly by the set of axioms <span>1,3</span>: axiom 3 because since <span class="math inline">\(tom\)</span> is a <span class="math inline">\(cat\)</span> (axiom 1) he is also a <span class="math inline">\(pet\)</span>. The same operation can be done for the edge (relationship) between tom and <span class="math inline">\(donVito\)</span>, which can be labelled also as <span class="math inline">\(hasAnimal\)</span> because of axioms 2 and 6.</p>
<p>At this point, the calculus can deduce that <span class="math inline">\(donVito\)</span> belongs to the class <span class="math inline">\(\exists hasAnimal.Pet\)</span> because <span class="math inline">\(donVito\)</span> is connected with <span class="math inline">\(tom\)</span>, which is a <span class="math inline">\(pet\)</span> (axioms <span>1,3</span>), via property <span class="math inline">\(hasAnimal\)</span> (axioms <span>2,6</span>). Therefore, <span class="math inline">\(donVito\)</span>’s node is labelled also as <span class="math inline">\(\exists hasAnimal.Pet\)</span> with a justification given by the union of the axioms associated with the used axioms, therefore its justification is given by the set of the involved axioms <span>1,2,3,6</span>. Then, the tableau graph is further expanded by adding the class <span class="math inline">\(NatureLover\)</span> to <span class="math inline">\(donVito\)</span>’s node using axiom 4 and finally, by adding also the class <span class="math inline">\(GoodPerson\)</span> using label <span class="math inline">\(NatureLover\)</span> (axioms <span>1,2,3,4,6</span>) and axiom 5, creating as justification the set of axioms <span>1,2,3,4,5,6</span>.</p>
<p>The final graph is shown in Figure <a href="#fig:tab2" data-reference-type="ref" data-reference="fig:tab2">3</a>.</p>
<figure>
<img src="img/tab2.png" id="fig:tab2" alt="" /><figcaption>Final tableau</figcaption>
</figure>
<p>The expanded graph contains now a contradiction, i.e., <span class="math inline">\(donVito\)</span> is labelled as <span class="math inline">\(GoodPerson\)</span> and as not a <span class="math inline">\(GoodPerson\)</span> (i.e., <span class="math inline">\(\neg GoodPerson\)</span>), therefore, by refutation, the query “Is don Vito Corleone a good person?” is true, with justification given by the axioms <span>1,2,3,4,5,6</span>, that are the axioms of the KB necessary to deduce this information.</p>
<p>From this example, it would be clear why the use of probabilistic information is useful. Indeed, don Vito Corleone is hardly classifiable as a good person. This is because not all people who are nature lovers are also good, and therefore, one could say that axiom 5 is true with probability 0.4. It would also be arguable that everyone who has animals is also a nature lover, making probabilistic also this axiom. For a formal description of how the probability of the query is computed see the Appendix <a href="#app:inf" data-reference-type="ref" data-reference="app:inf">11</a>.</p>
<h2 id="queries">Possible Queries</h2>
<p>TRILL can compute the probability or find an explanation of the following queries:</p>
<ul>
<li><p>Concept membership queries.</p></li>
<li><p>Property assertion queries.</p></li>
<li><p>Subsumption queries.</p></li>
<li><p>Unsatifiability of a concept.</p></li>
<li><p>Inconsistency of the knowledge base.</p></li>
</ul>
<p>All the input arguments must be atoms or ground terms.</p>
<h3 id="probabilistic-queries">Probabilistic Queries</h3>
<p>TRILL can be queried for computing the probability of queries. A resulting 0 probaility means that the query is false w.r.t. the knowledge base, while a probability value 1 that the query is certainly true.</p>
<p>The probability of an individual to belong to a concept can be asked using TRILL with the predicate</p>
<pre><code>prob_instanceOf(+Concept:term,+Individual:atom,-Prob:double)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- prob_instanceOf(cat,&#39;Tom&#39;,Prob).</code></pre>
<p>The probability of two individuals to be related by a role can be computed with</p>
<pre><code>prob_property_value(+Prop:atom,+Individual1:atom,
                    +Individual2:atom,-Prob:double)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- prob_property_value(has_animal,&#39;Kevin&#39;,&#39;Tom&#39;,Prob).</code></pre>
<p>If you want to know the probability with which a class is a subclass of another you have to use</p>
<pre><code>prob_sub_class(+Concept:term,+SupConcept:term,-Prob:double)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- prob_sub_class(cat,pet,Prob).</code></pre>
<p>The probability of the unsatisfiability of a concept can be asked with the predicate</p>
<pre><code>prob_unsat(+Concept:term,-Prob:double)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- prob_unsat(intersectionOf([cat,complementOf(pet)]),P).</code></pre>
<p>This query for example corresponds with a subsumption query, which is represented as the intersection of the subclass and the complement of the superclass.</p>
<p>Finally, you can ask the probability of the inconsistency of the knowledge base with</p>
<pre><code>prob_inconsistent_theory(-Prob:double)</code></pre>
<h3 id="non-probabilistic-queries">Non Probabilistic Queries</h3>
<p>In TRILL you can also ask whether a query is true or false w.r.t. the knowledge base and in case of a succesful query an explanation can be returned as well. Query predicates in this case differs in the number of arguments, in the second case, when we want also an explanation, an extra argument is added to unify with the list of axioms build to explain the query.</p>
<p>The query if an individual belongs to a concept can be used the predicates</p>
<pre><code>instanceOf(+Concept:term,+Individual:atom)
instanceOf(+Concept:term,+Individual:atom,-Expl:list)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- instanceOf(pet,&#39;Tom&#39;).
?- instanceOf(pet,&#39;Tom&#39;,Expl).</code></pre>
<p>In the first query the result is <code>true</code> because Tom belongs to cat, in the second case TRILL returns the explanation</p>
<pre><code>[classAssertion(cat,&#39;Tom&#39;), subClassOf(cat,pet)]</code></pre>
<p>Similarly, to ask whether two individuals are related by a role you have to use the queries</p>
<pre><code>property_value(+Prop:atom,+Individual1:atom,+Individual2:atom)
property_value(+Prop:atom,+Individual1:atom,
               +Individual2:atom,-Expl:list)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- property_value(has_animal,&#39;Kevin&#39;,&#39;Tom&#39;).
?- property_value(has_animal,&#39;Kevin&#39;,&#39;Tom&#39;,Expl).</code></pre>
<p>If you want to know if a class is a subclass of another you have to use</p>
<pre><code>sub_class(+Concept:term,+SupConcept:term)
sub_class(+Concept:term,+SupConcept:term,-Expl:list)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- sub_class(cat,pet).
?- sub_class(cat,pet,Expl).</code></pre>
<p>The unsatisfiability of a concept can be asked with the predicate</p>
<pre><code>unsat(+Concept:term)
unsat(+Concept:term,-Expl:list)</code></pre>
<p>as in (<a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>)</p>
<pre><code>?- unsat(intersectionOf([cat,complementOf(pet)])).
?- unsat(intersectionOf([cat,complementOf(pet)]),Expl).</code></pre>
<p>In this case, the returned explanation is the same obtained by querying if cat is subclass of pet with the <code>sub_class/3</code> predicate, i.e., <code>[subClassOf(cat,pet)]</code></p>
<p>Finally, you can ask about the inconsistency of the knowledge base with</p>
<pre><code>inconsistent_theory
inconsistent_theory(-Expl:list)</code></pre>
<p>The predicate above returns explanations one at a time. To collect all the explanations with a single goal you can use the predicates:</p>
<pre><code>all_instanceOf(+Concept:term,+Individual:atom,-Expl:list)
all_property_value(+Prop:atom,+Individual1:atom,
                        +Individual2:atom,-Expl:list)
all_sub_class(+Concept:term,+SupConcept:term,-Expl:list)
all_unsat(+Concept:term,-Expl:list)
all_inconsistent_theory(-Expl:list)</code></pre>
<h2 id="query-options">Query Options</h2>
<p>The behaviour of the queries can be fine tuned using the <em>query options</em>. To use them you need to use the predicates:</p>
<pre><code>instanceOf(+Concept:term,+Individual:atom,-Expl:list,-QueryOptions:list)
property_value(+Prop:atom,+Individual1:atom,
                        +Individual2:atom,-Expl:list,-QueryOptions:list)
sub_class(+Concept:term,+SupConcept:term,-Expl:list,-QueryOptions:list)
unsat(+Concept:term,-Expl:list,-QueryOptions:list)
inconsistent_theory(-Expl:list,-QueryOptions:list)</code></pre>
<p>Options can be:</p>
<ul>
<li><p><code>assert_abox(Boolean)</code> if Boolean is set to true the list of ABoxes is asserted with the predicate <code>final_abox/1</code>;</p></li>
<li><p><code>return_prob(Prob)</code> if present the probability of the query is computed and unified with <code>Prob</code>;</p></li>
<li><p><code>max_expl(Value)</code> to limit the maximum number of explanations to find. <code>Value</code> must be an integer. The predicate will return a list containing at most <code>Value</code> different explanations;</p></li>
<li><p><code>time_limit(Value)</code> to limit the time for the inference. The predicate will return the explanations found in the time allowed. <code>Value</code> is the number of seconds allowed for the search of explanations .</p></li>
</ul>
<p>For example, if you want to find the probability of the query <span class="math inline">\(Q=kevin:PetOwner\)</span> computed on at most 2 explanations allowing at most 1 second for the explanations search you can use the goal</p>
<pre><code>instanceOf(&#39;natureLover&#39;,&#39;Kevin&#39;,Expl,
           [time_limit(1),return_prob(Prob),max_expl(2)]).</code></pre>
<h2 id="trill-useful-predicates">TRILL Useful Predicates</h2>
<p>There are other predicates defined in TRILL which helps manage and load the KB.</p>
<pre><code>add_kb_prefix(++ShortPref:string,++LongPref:string)
add_kb_prefixes(++Prefixes:list)</code></pre>
<p>They register the alias for prefixes. The firs registers <code>ShortPref</code> for the prefix <code>LongPref</code>, while the second register all the alias prefixes contained in Prefixes. The input list must contain pairs alias=prefix, i.e., <code>[('foo'='http://example.foo#')]</code>. In both cases, the empty string <code>''</code> can be defined as alias. The predicates</p>
<pre><code>remove_kb_prefix(++ShortPref:string,++LongPref:string)
remove_kb_prefix(++Name:string)</code></pre>
<p>remove from the registered aliases the one given in input. In particular, <code>remove_kb_prefix/1</code> takes as input a string that can be an alias or a prefix and removes the pair containing the string from the registered aliases.</p>
<pre><code>add_axiom(++Axiom:axiom)
add_axioms(++Axioms:list)</code></pre>
<p>These predicates add (all) the given axiom to the knowledge base. While, to remove axioms can be similarly used the predicates</p>
<pre><code>remove_axiom(++Axiom:axiom)
remove_axioms(++Axioms:list)</code></pre>
<p>All the axioms must be defined following the TRILL syntax.</p>
<p>We can interrogate TRILL to return the loaded axioms with</p>
<pre><code>axiom(?Axiom:axiom)</code></pre>
<p>This predicate searches in the loaded knowledge base axioms that unify with Axiom.</p>
<pre><code>load_owl_kb(++filename:string)
load_kb(++filename:string)</code></pre>
<p>The predicate <code>load_owl_kb/1</code> allows to load a KB defined using a pure RDF/XML syntax. The predicate <code>load_kb/1</code> allows to load a KB defined using the Prolog syntax, i.e., axioms and/or <code>owl_rdf/1</code> predicate.</p>
<h1 id="loading-a-kb-in-trill">Loading a KB in TRILL</h1>
<p>Once the KB is ready to be used, you must load it in TRILL to perform inference. There are two ways to do that:</p>
<ol>
<li><p>prepare the KB so that it contains also the necessary Prolog directives to load the reasoner and load the KB in the Prolog console;</p></li>
<li><p>run the Prolog console, load the reasoner and finally the KB.</p></li>
</ol>
<p>At this point you can run all the query you want.</p>
<h2 id="case-1-self-contained-prolog-file">Case 1: Self-Contained Prolog File</h2>
<p>In the first case, it is necessary to specify which algorithm, TRILL, TRILL<span class="math inline">\(^P\)</span> or TORNADO, has to be loaded for performing inference. This is done by using at the beginning of the input file the directive</p>
<pre><code>:- trill.</code></pre>
<p>for loading TRILL,</p>
<pre><code>:- trillp.</code></pre>
<p>for TRILL<span class="math inline">\(^P\)</span> or</p>
<pre><code>:- tornado.</code></pre>
<p>for TORNADO.</p>
<p>The KB file will be similar to what shown in the following (<a href="http://trill-sw.eu/example/trill/donVito.pl"><code>donVito.pl</code></a> examples):</p>
<pre><code>% Load the reasoner
:-use_module(library(trill)).

% Init the reasoner
:- trill. % or :- trillp. or :- tornado.

% Definition of the axioms of the KB
classAssertion(cat, tom).
propertyAssertion(hasPet, donVito, tom).
subClassOf(cat, pet).
subClassOf(someValuesFrom(hasAnimal, pet), natureLover).
subClassOf(natureLover,goodPerson).
subPropertyOf(hasPet,hasAnimal).</code></pre>
<h3 id="sec:trillq1">Executing a Query</h3>
<p>To run a query, you can simply load the Prolog file, for example <a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a>, as</p>
<pre><code>?- [peoplePets].</code></pre>
<p>or by starting the Prolog console passing the file as argument</p>
<pre><code>$ swipl peoplePets.pl</code></pre>
<p>The linked file contains axioms defined in both syntaxes accepted by TRILL, RDF/XML and Prolog Syntax, based on definition of <a href="http://vangelisv.github.io/thea/">Thea</a> library. <a href="http://trill-sw.eu/example/trill/peoplePets.pl"><code>peoplePets.pl</code></a> is equivalent with the following KB</p>
<pre><code>:- use_module(library(trill)).

:- trill.

:- add_kb_prefix(&#39;&#39;,&#39;http://cohse.semanticweb.org/ontologies/people#&#39;).

subClassOf(someValuesFrom(&#39;has_animal&#39;, &#39;pet&#39;), &#39;natureLover&#39;).
subClassOf(&#39;cat&#39;, &#39;pet&#39;).
annotationAssertion(&#39;disponte:probability&#39;, 
        classAssertion(&#39;cat&#39;, &#39;Fluffy&#39;), literal(&#39;0.4&#39;)).
annotationAssertion(&#39;disponte:probability&#39;, 
        classAssertion(&#39;cat&#39;, &#39;Tom&#39;), literal(&#39;0.3&#39;)).
annotationAssertion(&#39;disponte:probability&#39;, 
        subClassOf(&#39;cat&#39;, &#39;pet&#39;), literal(&#39;0.6&#39;)).
propertyAssertion(&#39;has_animal&#39;, &#39;Kevin&#39;, &#39;Fluffy&#39;).
propertyAssertion(&#39;has_animal&#39;, &#39;Kevin&#39;, &#39;Tom&#39;).
classAssertion(&#39;cat&#39;, &#39;Fluffy&#39;).
classAssertion(&#39;cat&#39;, &#39;Tom&#39;).</code></pre>
<p>At this point the KB is loaded, you can ask every query or run every predicate shown in Section <a href="#queries" data-reference-type="ref" data-reference="queries">5.1</a>.</p>
<h2 id="case-2-independent-kb-file">Case 2: Independent KB File</h2>
<p>If you do not want to specify in your KB which reasoner to use, you can prepare the KB to that it contains only the axioms. The KB file can be define using pure RDF/XML syntax or TRILL’s Prolog syntax. In this case the file will NOT contain the directives:</p>
<pre><code>% Load the reasoner
:-use_module(library(trill)).

% Init the reasoner
:- trill. % or :- trillp. or :- tornado.</code></pre>
<h3 id="sec:trillq2">Executing a Query</h3>
<p>You can load the KB using the predicates <code>load_owl_kb(&lt;filename&gt;).</code> and <code>load_kb(&lt;filename&gt;).</code> in the following way:</p>
<ul>
<li><p>run the Prolog console<br />
<code>$ swipl</code></p></li>
<li><p>load TRILL library<br />
<code>?- use_module(library(trill)).</code></p></li>
<li><p>initialize the algorithm you want to perform inference<br />
<code>?- init_trill(&lt;algorithm_name&gt;).</code><br />
For example, if you want to use TRILL<span class="math inline">\(^P\)</span> you should run <code>init_trill(trillp).</code></p></li>
<li><p>load the KB<br />
<code>?- load_owl_kb(&lt;filename&gt;).</code> or<br />
<code>?- load_kb(&lt;filename&gt;).</code><br />
For example:<br />
<code>load_owl_kb('./examples/biopaxLevel3_rdf.owl').</code> or<br />
<code>load_kb('./examples/biopaxLevel3.pl').</code><br />
The first predicate allows to load a RDF/XML file, while the second allows to load a KB defined using the Prolog syntax, i.e., axioms and/or <code>owl_rdf/1</code> predicate.</p></li>
</ul>
<p>Now the KB is loaded and the queries or TRILL’s utility predicates can be executed in the usual way.</p>
<h1 id="files">Files</h1>
<p>The <code>pack/trill/prolog/examples</code> folder in SWI-Prolog home contains some example programs. The <code>pack/trill/doc</code> folder in SWI-Prolog home contains this manual in latex, html and pdf.</p>
<h1 id="license">License</h1>
<p>TRILL follows the Artistic License 2.0 that you can find in TRILL root folder. The copyright is by Riccardo Zese.</p>
<p>The library <a href="http://vangelisv.github.io/thea/">Thea</a> at the basis of the translation module is available under the <a href="http://www.gnu.org/copyleft/gpl.html">GNU/GPL license</a>.</p>
<p>The library <a href="http://vlsi.colorado.edu/\string ~fabio/">CUDD</a> for manipulating BDDs has the following license:</p>
<p>Copyright (c) 1995-2004, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li><p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p></li>
<li><p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p></li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAU-SED<br />
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1 id="app:dl">Description Logics</h1>
<p>In this section, we recall the expressive description logic <span class="math inline">\(\mathcal{ALC}\)</span> <span class="citation" data-cites="DBLP:journals/ai/Schmidt-SchaussS91">[<a href="#ref-DBLP:journals/ai/Schmidt-SchaussS91" role="doc-biblioref">18</a>]</span>. We refer to <span class="citation" data-cites="DBLP:journals/ws/LukasiewiczS08">[<a href="#ref-DBLP:journals/ws/LukasiewiczS08" role="doc-biblioref">10</a>]</span> for a detailed description of <span class="math inline">\(\mathcal{SHOIN}(\mathbf{D})\)</span> DL, that is at the basis of OWL DL.</p>
<p>Let <span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\mathbf{R}\)</span> and <span class="math inline">\(\mathbf{I}\)</span> be sets of <em>atomic concepts</em>, <em>roles</em> and <em>individuals</em>. A <em>role</em> is an atomic role <span class="math inline">\(R \in \mathbf{R}\)</span>. <em>Concepts</em> are defined by induction as follows. Each <span class="math inline">\(C \in \mathbf{A}\)</span>, <span class="math inline">\(\bot\)</span> and <span class="math inline">\(\top\)</span> are concepts. If <span class="math inline">\(C\)</span>, <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are concepts and <span class="math inline">\(R \in \mathbf{R}\)</span>, then <span class="math inline">\((C_1\sqcap C_2)\)</span>, <span class="math inline">\((C_1\sqcup C_2 )\)</span>, <span class="math inline">\(\neg C\)</span>, <span class="math inline">\(\exists R.C\)</span>, and <span class="math inline">\(\forall R.C\)</span> are concepts. Let <span class="math inline">\(C\)</span>, <span class="math inline">\(D\)</span> be concepts, <span class="math inline">\(R \in \mathbf{R}\)</span> and <span class="math inline">\(a, b \in \mathbf{I}\)</span>. An <em>ABox</em> <span class="math inline">\({\cal A}\)</span> is a finite set of <em>concept membership axioms</em> <span class="math inline">\(a : C\)</span> and <em>role membership axioms</em> <span class="math inline">\((a, b) : R\)</span>, while a <em>TBox</em> <span class="math inline">\({\cal T}\)</span> is a finite set of <em>concept inclusion axioms</em> <span class="math inline">\(C\sqsubseteq D\)</span>. <span class="math inline">\(C \equiv D\)</span> abbreviates <span class="math inline">\(C \sqsubseteq D\)</span> and <span class="math inline">\(D\sqsubseteq  C\)</span>.</p>
<p>A <em>knowledge base</em> <span class="math inline">\({\cal K}= ({\cal T}, {\cal A})\)</span> consists of a TBox <span class="math inline">\({\cal T}\)</span> and an ABox <span class="math inline">\({\cal A}\)</span>. A KB <span class="math inline">\({\cal K}\)</span> is assigned a semantics in terms of set-theoretic interpretations <span class="math inline">\({\cal I}= (\Delta^{\cal I}, \cdot^{\cal I})\)</span>, where <span class="math inline">\(\Delta^{\cal I}\)</span> is a non-empty <em>domain</em> and <span class="math inline">\(\cdot^{\cal I}\)</span> is the <em>interpretation function</em> that assigns an element in <span class="math inline">\(\Delta ^{\cal I}\)</span> to each <span class="math inline">\(a \in \mathbf{I}\)</span>, a subset of <span class="math inline">\(\Delta^{\cal I}\)</span> to each <span class="math inline">\(C \in \mathbf{A}\)</span> and a subset of <span class="math inline">\(\Delta^{\cal I}\times \Delta^{\cal I}\)</span> to each <span class="math inline">\(R \in \mathbf{R}\)</span>.</p>
<h1 id="app:disponte">DISPONTE</h1>
<p>In the field of Probabilistic Logic Programming (PLP for short) many proposals have been presented. An effective and popular approach is the Distribution Semantics <span class="citation" data-cites="DBLP:conf/iclp/Sato95">[<a href="#ref-DBLP:conf/iclp/Sato95" role="doc-biblioref">15</a>]</span>, which underlies many PLP languages such as PRISM <span class="citation" data-cites="DBLP:conf/iclp/Sato95 DBLP:journals/jair/SatoK01">[<a href="#ref-DBLP:conf/iclp/Sato95" role="doc-biblioref">15</a>,<a href="#ref-DBLP:journals/jair/SatoK01" role="doc-biblioref">16</a>]</span>, Independent Choice Logic <span class="citation" data-cites="Poo97-ArtInt-IJ">[<a href="#ref-Poo97-ArtInt-IJ" role="doc-biblioref">12</a>]</span>, Logic Programs with Annotated Disjunctions <span class="citation" data-cites="VenVer04-ICLP04-IC">[<a href="#ref-VenVer04-ICLP04-IC" role="doc-biblioref">20</a>]</span> and ProbLog <span class="citation" data-cites="DBLP:conf/ijcai/RaedtKT07">[<a href="#ref-DBLP:conf/ijcai/RaedtKT07" role="doc-biblioref">5</a>]</span>. Along this line, many reserchers proposed to combine probability theory with Description Logics (DLs for short) <span class="citation" data-cites="DBLP:journals/ws/LukasiewiczS08 DBLP:conf/rweb/Straccia08">[<a href="#ref-DBLP:journals/ws/LukasiewiczS08" role="doc-biblioref">10</a>,<a href="#ref-DBLP:conf/rweb/Straccia08" role="doc-biblioref">19</a>]</span>. DLs are at the basis of the Web Ontology Language (OWL for short), a family of knowledge representation formalisms used for modeling information of the Semantic Web</p>
<p>TRILL follows the DISPONTE <span class="citation" data-cites="RigBelLamZese12-URSW12 Zese17-SSW-BK">[<a href="#ref-RigBelLamZese12-URSW12" role="doc-biblioref">14</a>,<a href="#ref-Zese17-SSW-BK" role="doc-biblioref">21</a>]</span> semantics to compute the probability of queries. DISPONTE applies the distribution semantics <span class="citation" data-cites="DBLP:conf/iclp/Sato95">[<a href="#ref-DBLP:conf/iclp/Sato95" role="doc-biblioref">15</a>]</span> of probabilistic logic programming to DLs. A program following this semantics defines a probability distribution over normal logic programs called <em>worlds</em>. Then the distribution is extended to queries and the probability of a query is obtained by marginalizing the joint distribution of the query and the programs.</p>
<p>In DISPONTE, a <em>probabilistic knowledge base</em> <span class="math inline">\({\cal K}\)</span> is a set of <em>certain axioms</em> or <em>probabilistic axioms</em> in which each axiom is independent evidence. Certain axioms take the form of regular DL axioms while probabilistic axioms are <span class="math inline">\(p::E\)</span> where <span class="math inline">\(p\)</span> is a real number in <span class="math inline">\([0,1]\)</span> and <span class="math inline">\(E\)</span> is a DL axiom.</p>
<p>The idea of DISPONTE is to associate independent Boolean random variables to the probabilistic axioms. To obtain a <em>world</em>, we include every formula obtained from a certain axiom. For each probabilistic axiom, we decide whether to include it or not in <span class="math inline">\(w\)</span>. A world therefore is a non probabilistic KB that can be assigned a semantics in the usual way. A query is entailed by a world if it is true in every model of the world.</p>
<p>The probability <span class="math inline">\(p\)</span> can be interpreted as an <em>epistemic probability</em>, i.e., as the degree of our belief in axiom <span class="math inline">\(E\)</span>. For example, a probabilistic concept membership axiom <span class="math inline">\(p::a:C\)</span> means that we have degree of belief <span class="math inline">\(p\)</span> in <span class="math inline">\(C(a)\)</span>. A probabilistic concept inclusion axiom of the form <span class="math inline">\(p::C\sqsubseteq D\)</span> represents our belief in the truth of <span class="math inline">\(C \sqsubseteq D\)</span> with probability <span class="math inline">\(p\)</span>.</p>
<p>Formally, an <em>atomic choice</em> is a couple <span class="math inline">\((E_i,k)\)</span> where <span class="math inline">\(E_i\)</span> is the <span class="math inline">\(i\)</span>th probabilistic axiom and <span class="math inline">\(k\in \{0,1\}\)</span>. <span class="math inline">\(k\)</span> indicates whether <span class="math inline">\(E_i\)</span> is chosen to be included in a world (<span class="math inline">\(k\)</span> = 1) or not (<span class="math inline">\(k\)</span> = 0). A <em>composite choice</em> <span class="math inline">\(\kappa\)</span> is a consistent set of atomic choices, i.e., <span class="math inline">\((E_i,k)\in\kappa, (E_i,m)\in \kappa\)</span> implies <span class="math inline">\(k=m\)</span> (only one decision is taken for each formula). The probability of a composite choice <span class="math inline">\(\kappa\)</span> is <span class="math inline">\(P(\kappa)=\prod_{(E_i,1)\in \kappa}p_i\prod_{(E_i, 0)\in \kappa} (1-p_i)\)</span>, where <span class="math inline">\(p_i\)</span> is the probability associated with axiom <span class="math inline">\(E_i\)</span>. A <em>selection</em> <span class="math inline">\(\sigma\)</span> is a total composite choice, i.e., it contains an atomic choice <span class="math inline">\((E_i,k)\)</span> for every probabilistic axiom of the probabilistic KB. A selection <span class="math inline">\(\sigma\)</span> identifies a theory <span class="math inline">\(w_\sigma\)</span> called a <em>world</em> in this way: <span class="math inline">\(w_\sigma={\cal C}\cup\{E_i|(E_i,1)\in \sigma\}\)</span> where <span class="math inline">\({\cal C}\)</span> is the set of certain axioms. Let us indicate with <span class="math inline">\(\mathcal{S}_{\cal K}\)</span> the set of all selections and with <span class="math inline">\(\mathcal{W}_{\cal K}\)</span> the set of all worlds. The probability of a world <span class="math inline">\(w_\sigma\)</span> is <span class="math inline">\(P(w_\sigma)=P(\sigma)=\prod_{(E_i,1)\in \sigma}p_i\prod_{(E_i, 0)\in \sigma} (1-p_i)\)</span>. <span class="math inline">\(P(w_\sigma)\)</span> is a probability distribution over worlds, i.e., <span class="math inline">\(\sum_{w\in \mathcal{W}_{\cal K}}P(w)=1\)</span>.</p>
<p>We can now assign probabilities to queries. Given a world <span class="math inline">\(w\)</span>, the probability of a query <span class="math inline">\(Q\)</span> is defined as <span class="math inline">\(P(Q|w)=1\)</span> if <span class="math inline">\(w\models Q\)</span> and 0 otherwise. The probability of a query can be defined by marginalizing the joint probability of the query and the worlds, i.e. <span class="math inline">\(P(Q)=\sum_{w\in \mathcal{W}_{\cal K}}P(Q,w)=\sum_{w\in \mathcal{W}_{\cal K}} P(Q|w)p(w)=\sum_{w\in \mathcal{W}_{\cal K}: w\models Q}P(w)\)</span>.</p>
<p><span id="people+petsxy" label="people+petsxy">[people+petsxy]</span></p>
<p>Consider the following KB, inspired by the <code>people+pets</code> ontology <span class="citation" data-cites="ISWC03-tut">[<a href="#ref-ISWC03-tut" role="doc-biblioref">11</a>]</span>: <span><span class="math inline">\(0.5\ \ ::\ \ \exists hasAnimal.Pet \sqsubseteq NatureLover\ \ \ \ \ 0.6\ \ ::\ \ Cat\sqsubseteq Pet\)</span><br />
<span class="math inline">\((kevin,tom):hasAnimal\ \ \ \ \ (kevin,{\mathit{fluffy}}):hasAnimal\ \ \ \ \ tom: Cat\ \ \ \ \ {\mathit{fluffy}}: Cat\)</span><br />
</span> The KB indicates that the individuals that own an animal which is a pet are nature lovers with a 50% probability and that <span class="math inline">\(kevin\)</span> has the animals <span class="math inline">\({\mathit{fluffy}}\)</span> and <span class="math inline">\(tom\)</span>. Fluffy and <span class="math inline">\(tom\)</span> are cats and cats are pets with probability 60%. We associate a Boolean variable to each axiom as follow <span class="math inline">\(F_1 = \exists hasAnimal.Pet \sqsubseteq NatureLover\)</span>, <span class="math inline">\(F_2=(kevin,{\mathit{fluffy}}):hasAnimal\)</span>, <span class="math inline">\(F_3=(kevin,tom):hasAnimal\)</span>, <span class="math inline">\(F_4={\mathit{fluffy}}: Cat\)</span>, <span class="math inline">\(F_5=tom: Cat\)</span> and <span class="math inline">\(F_6= Cat\sqsubseteq Pet\)</span>.</p>
<p>The KB has four worlds and the query axiom <span class="math inline">\(Q=kevin:NatureLover\)</span> is true in one of them, the one corresponding to the selection <span class="math inline">\(\{(F_1,1),(F_2,1)\}\)</span>. The probability of the query is <span class="math inline">\(P(Q)=0.5\cdot 0.6=0.3\)</span>.</p>
<p><span id="people+pets_comb" label="people+pets_comb">[people+pets_comb]</span></p>
<p>Sometimes we have to combine knowledge from multiple, untrusted sources, each one with a different reliability. Consider a KB similar to the one of Example <a href="#people+petsxy" data-reference-type="ref" data-reference="people+petsxy">[people+petsxy]</a> but where we have a single cat, <span class="math inline">\({\mathit{fluffy}}\)</span>. <span><span class="math inline">\(\exists hasAnimal.Pet \sqsubseteq NatureLover\ \ \ \ \ (kevin,{\mathit{fluffy}}):hasAnimal\ \ \ \ \ Cat\sqsubseteq Pet\)</span><br />
</span></p>
<p>and there are two sources of information with different reliability that provide the information that <span class="math inline">\({\mathit{fluffy}}\)</span> is a cat. On one source the user has a degree of belief of 0.4, i.e., he thinks it is correct with a 40% probability, while on the other source he has a degree of belief 0.3. The user can reason on this knowledge by adding the following statements to his KB: <span><span class="math inline">\(0.4\ \ ::\ \ {\mathit{fluffy}}: Cat\ \ \ \ \ 0.3\ \ ::\ \ {\mathit{fluffy}}: Cat\)</span><br />
</span> The two statements represent independent evidence on <span class="math inline">\({\mathit{fluffy}}\)</span> being a cat. We associate <span class="math inline">\(F_1\)</span> (<span class="math inline">\(F_2\)</span>) to the first (second) probabilistic axiom.</p>
<p>The query axiom <span class="math inline">\(Q=kevin:NatureLover\)</span> is true in 3 out of the 4 worlds, those corresponding to the selections <span class="math inline">\(\{ \{(F_1,1),(F_2,1)\},
		\{(F_1,1),(F_2,0)\},
		\{(F_1,0),(F_2,1)\}\}\)</span>. So <span class="math inline">\(P(Q)=0.4\cdot 0.3+0.4\cdot 0.7+ 0.6\cdot 0.3=0.58.\)</span> This is reasonable if the two sources can be considered as independent. In fact, the probability comes from the disjunction of two independent Boolean random variables with probabilities respectively 0.4 and 0.3: <span class="math inline">\(P(Q) = P(X_1\vee X_2) = P(X_1)+P(X_2)-P(X_1\wedge X_2)
		= P(X_1)+P(X_2)-P(X_1)P(X_2)
		= 0.4+0.3-0.4\cdot 0.3=0.58\)</span></p>
<h1 id="app:inf">Inference</h1>
<p>Traditionally, a reasoning algorithm decides whether an axiom is entailed or not by a KB by refutation: the axiom <span class="math inline">\(E\)</span> is entailed if <span class="math inline">\(\neg E\)</span> has no model in the KB. Besides deciding whether an axiom is entailed by a KB, we want to find also explanations for the axiom, in order to compute the probability of the axiom.</p>
<h2 id="computing-queries-probability">Computing Queries Probability</h2>
<p>The problem of finding explanations for a query has been investigated by various authors <span class="citation" data-cites="DBLP:conf/ijcai/SchlobachC03 DBLP:journals/ws/KalyanpurPSH05 DBLP:conf/semweb/KalyanpurPHS07 Kalyanpurphd extended_tracing Zese17-SSW-BK">[<a href="#ref-extended_tracing" role="doc-biblioref">6</a>–<a href="#ref-DBLP:journals/ws/KalyanpurPSH05" role="doc-biblioref">9</a>,<a href="#ref-DBLP:conf/ijcai/SchlobachC03" role="doc-biblioref">17</a>,<a href="#ref-Zese17-SSW-BK" role="doc-biblioref">21</a>]</span>. It was called <em>axiom pinpointing</em> in <span class="citation" data-cites="DBLP:conf/ijcai/SchlobachC03">[<a href="#ref-DBLP:conf/ijcai/SchlobachC03" role="doc-biblioref">17</a>]</span> and considered as a non-standard reasoning service useful for tracing derivations and debugging ontologies. In particular, in <span class="citation" data-cites="DBLP:conf/ijcai/SchlobachC03">[<a href="#ref-DBLP:conf/ijcai/SchlobachC03" role="doc-biblioref">17</a>]</span> the authors define <em>minimal axiom sets</em> (<em>MinAs</em> for short). [MinA] Let <span class="math inline">\({\cal K}\)</span> be a knowledge base and <span class="math inline">\(Q\)</span> an axiom that follows from it, i.e., <span class="math inline">\({\cal K}\models Q\)</span>. We call a set <span class="math inline">\(M\subseteq {\cal K}\)</span> a <em>minimal axiom set</em> or <em>MinA</em> for <span class="math inline">\(Q\)</span> in <span class="math inline">\({\cal K}\)</span> if <span class="math inline">\(M \models Q\)</span> and it is minimal w.r.t. set inclusion.</p>
<p>The problem of enumerating all MinAs is called <span class="smallcaps">min-a-enum</span>. <span class="smallcaps">All-MinAs(<span class="math inline">\(Q,{\cal K}\)</span>)</span> is the set of all MinAs for query <span class="math inline">\(Q\)</span> in knowledge base <span class="math inline">\({\cal K}\)</span>.</p>
<p>A <em>tableau</em> is a graph where each node represents an individual <span class="math inline">\(a\)</span> and is labeled with the set of concepts <span class="math inline">\({\cal L}(a)\)</span> it belongs to. Each edge <span class="math inline">\(\langle a, b\rangle\)</span> in the graph is labeled with the set of roles to which the couple <span class="math inline">\((a, b)\)</span> belongs. Then, a set of consistency preserving tableau expansion rules are repeatedly applied until a clash (i.e., a contradiction) is detected or a clash-free graph is found to which no more rules are applicable. A clash is for example a couple <span class="math inline">\((C, a)\)</span> where <span class="math inline">\(C\)</span> and <span class="math inline">\(\neg C\)</span> are present in the label of a node, i.e. <span class="math inline">\({C, \neg C} \subseteq {\cal L}(a)\)</span>.</p>
<p>Some expansion rules are non-deterministic, i.e., they generate a finite set of tableaux. Thus the algorithm keeps a set of tableaux that is consistent if there is any tableau in it that is consistent, i.e., that is clash-free. Each time a clash is detected in a tableau <span class="math inline">\(G\)</span>, the algorithm stops applying rules to <span class="math inline">\(G\)</span>. Once every tableau in <span class="math inline">\(T\)</span> contains a clash or no more expansion rules can be applied to it, the algorithm terminates. If all the tableaux in the final set <span class="math inline">\(T\)</span> contain a clash, the algorithm returns unsatisfiable as no model can be found. Otherwise, any one clash-free completion graph in <span class="math inline">\(T\)</span> represents a possible model for the concept and the algorithm returns satisfiable.</p>
<p>To compute the probability of a query, the explanations must be made mutually exclusive, so that the probability of each individual explanation is computed and summed with the others. To do that we assign independent Boolean random variables to the axioms contained in the explanations and defining the Disjunctive Normal Form (DNF) Boolean formula <span class="math inline">\(f_K\)</span> which models the set of explanations. Thus <span class="math inline">\(f_K(\mathbf{X})=\bigvee_{\kappa\in K}\bigwedge_{(E_i,1)}X_{i}\bigwedge_{(E_i,0)}\overline{X_{i}}\)</span> where <span class="math inline">\(\mathbf{X}=\{X_{i}|(E_i,k)\in\kappa,\kappa\in K\}\)</span> is the set of Boolean random variables. We can now translate <span class="math inline">\(f_K\)</span> to a Binary Decision Diagram (BDD), from which we can compute the probability of the query with a dynamic programming algorithm that is linear in the size of the BDD.</p>
<p>In <span class="citation" data-cites="DBLP:journals/jar/BaaderP10 DBLP:journals/logcom/BaaderP10">[<a href="#ref-DBLP:journals/jar/BaaderP10" role="doc-biblioref">3</a>,<a href="#ref-DBLP:journals/logcom/BaaderP10" role="doc-biblioref">4</a>]</span> the authors consider the problem of finding a <em>pinpointing formula</em> instead of <span class="smallcaps">All-MinAs(<span class="math inline">\(Q,{\cal K}\)</span>)</span>. The pinpointing formula is a monotone Boolean formula in which each Boolean variable corresponds to an axiom of the KB. This formula is built using the variables and the conjunction and disjunction connectives. It compactly encodes the set of all MinAs. Let’s assume that each axiom <span class="math inline">\(E\)</span> of a KB <span class="math inline">\({\cal K}\)</span> is associated with a propositional variable, indicated with <span class="math inline">\(var(E)\)</span>. The set of all propositional variables is indicated with <span class="math inline">\(var({\cal K})\)</span>. A valuation <span class="math inline">\(\nu\)</span> of a monotone Boolean formula is the set of propositional variables that are true. For a valuation <span class="math inline">\(\nu \subseteq var({\cal K})\)</span>, let <span class="math inline">\({\cal K}_{\nu} := \{t \in {\cal K}|var(t)\in\nu\}\)</span>. [Pinpointing formula] Given a query <span class="math inline">\(Q\)</span> and a KB <span class="math inline">\({\cal K}\)</span>, a monotone Boolean formula <span class="math inline">\(\phi\)</span> over <span class="math inline">\(var({\cal K})\)</span> is called a <em>pinpointing formula</em> for <span class="math inline">\(Q\)</span> if for every valuation <span class="math inline">\(\nu \subseteq var({\cal K})\)</span> it holds that <span class="math inline">\({\cal K}_{\nu} \models Q\)</span> iff <span class="math inline">\(\nu\)</span> satisfies <span class="math inline">\(\phi\)</span>.</p>
<p>In Lemma 2.4 of <span class="citation" data-cites="DBLP:journals/logcom/BaaderP10">[<a href="#ref-DBLP:journals/logcom/BaaderP10" role="doc-biblioref">4</a>]</span> the authors proved that the set of all MinAs can be obtained by transforming the pinpointing formula into a Disjunctive Normal Form Boolean formula (DNF) and removing disjuncts implying other disjuncts.</p>
<p>Irrespective of which representation of the explanations we choose, a DNF or a general pinpointing formula, we can apply knowledge compilation and <em>transform it into a Binary Decision Diagram (BDD)</em>, from which we can compute the probability of the query with a dynamic programming algorithm that is linear in the size of the BDD.</p>
<p>We refer to <span class="citation" data-cites="Zese17-SSW-BK ZesBelRig16-AMAI-IJ">[<a href="#ref-Zese17-SSW-BK" role="doc-biblioref">21</a>,<a href="#ref-ZesBelRig16-AMAI-IJ" role="doc-biblioref">24</a>]</span> for a detailed description of the two methods.</p>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-DBLP:conf/dlog/2003handbook">
<p>1. F. Baader, D. Calvanese, D. L. McGuinness, D. Nardi, and P. F. Patel-Schneider (eds.). 2003. <em>The description logic handbook: Theory, implementation, and applications</em>. Cambridge University Press.</p>
</div>
<div id="ref-dlchap">
<p>2. F. Baader, I. Horrocks, and U. Sattler. 2008. Description logics. In <em>Handbook of knowledge representation</em>. Elsevier, 135–179.</p>
</div>
<div id="ref-DBLP:journals/jar/BaaderP10">
<p>3. F. Baader and R. Peñaloza. 2010. Automata-based axiom pinpointing. <em>Journal of Automated Reasoning</em> 45, 2: 91–129.</p>
</div>
<div id="ref-DBLP:journals/logcom/BaaderP10">
<p>4. F. Baader and R. Peñaloza. 2010. Axiom pinpointing in general tableaux. <em>Journal of Logic and Computation</em> 20, 1: 5–34.</p>
</div>
<div id="ref-DBLP:conf/ijcai/RaedtKT07">
<p>5. L. De Raedt, A. Kimmig, and H. Toivonen. 2007. ProbLog: A probabilistic Prolog and its application in link discovery. <em>IJCAI</em>, 2462–2467.</p>
</div>
<div id="ref-extended_tracing">
<p>6. C. Halaschek-Wiener, A. Kalyanpur, and B. Parsia. 2006. <em>Extending tableau tracing for ABox updates</em>. University of Maryland.</p>
</div>
<div id="ref-Kalyanpurphd">
<p>7. A. Kalyanpur. 2006. Debugging and repair of OWL ontologies. </p>
</div>
<div id="ref-DBLP:conf/semweb/KalyanpurPHS07">
<p>8. A. Kalyanpur, B. Parsia, M. Horridge, and E. Sirin. 2007. Finding all justifications of OWL DL entailments. <em>ISWC</em>, Springer, 267–280.</p>
</div>
<div id="ref-DBLP:journals/ws/KalyanpurPSH05">
<p>9. A. Kalyanpur, B. Parsia, E. Sirin, and J. A. Hendler. 2005. Debugging unsatisfiable classes in OWL ontologies. <em>J. Web Sem.</em> 3, 4: 268–293.</p>
</div>
<div id="ref-DBLP:journals/ws/LukasiewiczS08">
<p>10. T. Lukasiewicz and U. Straccia. 2008. Managing uncertainty and vagueness in description logics for the semantic web. <em>J. Web Sem.</em> 6, 4: 291–308.</p>
</div>
<div id="ref-ISWC03-tut">
<p>11. F. Patel-Schneider P, I. Horrocks, and S. Bechhofer. 2003. Tutorial on OWL. </p>
</div>
<div id="ref-Poo97-ArtInt-IJ">
<p>12. D. Poole. 1997. The Independent Choice Logic for modelling multiple agents under uncertainty. <em>Artif. Intell.</em> 94, 1-2: 7–56.</p>
</div>
<div id="ref-RigBelLamZes15-SW-IJ">
<p>13. Fabrizio Riguzzi, Elena Bellodi, Evelina Lamma, and Riccardo Zese. 2015. Probabilistic description logics under the distribution semantics. 6, 5: 447–501. <a href="http://doi.org/10.3233/SW-140154">http://doi.org/10.3233/SW-140154</a></p>
</div>
<div id="ref-RigBelLamZese12-URSW12">
<p>14. Fabrizio Riguzzi, Evelina Lamma, Elena Bellodi, and Riccardo Zese. 2012. Epistemic and statistical probabilistic ontologies. <em>URSW</em>, Sun SITE Central Europe, 3–14.</p>
</div>
<div id="ref-DBLP:conf/iclp/Sato95">
<p>15. T. Sato. 1995. A statistical learning method for logic programs with distribution semantics. <em>ICLP</em>, MIT Press, 715–729.</p>
</div>
<div id="ref-DBLP:journals/jair/SatoK01">
<p>16. Taisuke Sato and Yoshitaka Kameya. 2001. Parameter learning of logic programs for symbolic-statistical modeling. <em>J. Artif. Intell. Res.</em> 15: 391–454.</p>
</div>
<div id="ref-DBLP:conf/ijcai/SchlobachC03">
<p>17. Stefan Schlobach and Ronald Cornet. 2003. Non-standard reasoning services for the debugging of description logic terminologies. <em>IJCAI</em>, Morgan Kaufmann, 355–362.</p>
</div>
<div id="ref-DBLP:journals/ai/Schmidt-SchaussS91">
<p>18. Manfred Schmidt-Schauß and Gert Smolka. 1991. Attributive concept descriptions with complements. <em>Artif. Intell.</em> 48, 1: 1–26.</p>
</div>
<div id="ref-DBLP:conf/rweb/Straccia08">
<p>19. Umberto Straccia. 2008. Managing uncertainty and vagueness in description logics, logic programs and description logic programs. <em>International summer school on reasoning web</em>, Springer, 54–103.</p>
</div>
<div id="ref-VenVer04-ICLP04-IC">
<p>20. J. Vennekens, S. Verbaeten, and M. Bruynooghe. 2004. Logic programs with annotated disjunctions. <em>ICLP</em>, Springer, 195–209.</p>
</div>
<div id="ref-Zese17-SSW-BK">
<p>21. Riccardo Zese. 2017. <em>Probabilistic semantic web</em>. IOS Press. <a href="http://doi.org/10.3233/978-1-61499-734-4-i">http://doi.org/10.3233/978-1-61499-734-4-i</a></p>
</div>
<div id="ref-ZesBelCot18-TPLP-IJ">
<p>22. Riccardo Zese, Elena Bellodi, Giuseppe Cota, Fabrizio Riguzzi, and Evelina Lamma. 2018. Probabilistic DL reasoning with pinpointing formulas: A Prolog-based approach. 1–28. <a href="http://doi.org/10.1017/S1471068418000480">http://doi.org/10.1017/S1471068418000480</a></p>
</div>
<div id="ref-ZesBelLamRig13-CILC13-NC">
<p>23. Riccardo Zese, Elena Bellodi, Evelina Lamma, and Fabrizio Riguzzi. 2013. A description logics tableau reasoner in Prolog. <em>Proceedings of the 28th italian conference on computational logic (CILC2013), catania, italy, 25-27 september 2013</em>, Sun SITE Central Europe, 33–47. Retrieved from <a href="http://ceur-ws.org/Vol-1068/paper-l02.pdf">http://ceur-ws.org/Vol-1068/paper-l02.pdf</a></p>
</div>
<div id="ref-ZesBelRig16-AMAI-IJ">
<p>24. Riccardo Zese, Elena Bellodi, Fabrizio Riguzzi, Giuseppe Cota, and Evelina Lamma. 2016. Tableau reasoning for description logics and its extension to probabilities. <em>Ann. Math. Artif. Intel.</em>: 1–30. <a href="http://doi.org/10.1007/s10472-016-9529-3">http://doi.org/10.1007/s10472-016-9529-3</a></p>
</div>
<div id="ref-ZesBelCot19-TPLP-IJ">
<p>25. Riccardo Zese, Giuseppe Cota, Evelina Lamma, Elena Bellodi, and Fabrizio Riguzzi. 2019. Probabilistic DL reasoning with pinpointing formulas: A prolog-based approach. <em>Theory and Practice of Logic Programming</em> 19, 3: 449–476. <a href="http://doi.org/10.1017/S1471068418000480">http://doi.org/10.1017/S1471068418000480</a></p>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://github.com/friguzzi/bddem">https://github.com/friguzzi/bddem</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
