<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog Semantic Web Library 3.0</title>
<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white"> 
<div class="title">SWI-Prolog Semantic Web Library 3.0</div>
<div class="author">Jan Wielemaker <br>
University of Amsterdam/VU University Amsterdam <br>
The Netherlands <br>
E-mail: <a class="url" href="mailto:J.Wielemaker@vu.nl">J.Wielemaker@vu.nl</a></div>
<div class="abstract">
<div class="abstract-title">Abstract</div>

<p>This document describes the SWI-Prolog <em>semweb</em> package. The 
core of this package is an efficient main-memory based RDF store that is 
tightly connected to Prolog. Additional libraries provide reading and 
writing RDF/XML and Turtle data, caching loaded RDF documents and 
persistent storage. This package is the core of a ready-to-run platform 
for developing Semantic Web applications named
<a class="url" href="http://cliopatria.swi-prolog.org">ClioPatria</a>, 
which is distributed separately. The SWI-Prolog RDF store is among the 
most memory efficient main-memory stores for RDF<sup class="fn">1<span class="fn-text"><a class="url" href="http://cliopatria.swi-prolog.org/help/source/doc/home/vnc/prolog/src/ClioPatria/web/help/memusage.txt">http://cliopatria.swi-prolog.org/help/source/doc/home/vnc/prolog/src/ClioPatria/web/help/memusage.txt</a></span></sup>

<p>Version&nbsp;3 of the RDF library enhances concurrent use of the 
library by allowing for lock-free reading and writing using short-held 
locks. It provides Prolog compatible <em>logical update view</em> on the 
triple store and isolation using <em>transactions</em> and <em>snapshots</em>. 
This version of the library provides near real-time modification and 
querying of RDF graphs, making it particularly interesting for handling 
streaming RDF and graph manipulation tasks.
</div>

<h1><a id="document-contents">Table of Contents</a></h1>

<div class="toc">
<div class="toc-h2"><a class="sec" href="#sec:1"><span class="sec-nr">1</span> <span class="sec-title">Introduction</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:2"><span class="sec-nr">2</span> <span class="sec-title">Scalability</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:3"><span class="sec-nr">3</span> <span class="sec-title">Two 
RDF APIs</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.1"><span class="sec-nr">3.1</span> <span class="sec-title">library(semweb/rdf11): 
The RDF database</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.1.1"><span class="sec-nr">3.1.1</span> <span class="sec-title">Query 
the RDF database</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.1.2"><span class="sec-nr">3.1.2</span> <span class="sec-title">Enumerating 
and testing objects</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.1.3"><span class="sec-nr">3.1.3</span> <span class="sec-title">RDF 
literals</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.1.4"><span class="sec-nr">3.1.4</span> <span class="sec-title">Accessing 
RDF graphs</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.1.5"><span class="sec-nr">3.1.5</span> <span class="sec-title">Modifying 
the RDF store</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.1.6"><span class="sec-nr">3.1.6</span> <span class="sec-title">Accessing 
RDF collections</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.2"><span class="sec-nr">3.2</span> <span class="sec-title">library(semweb/rdf11_containers): 
RDF 1.1 Containers</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.3"><span class="sec-nr">3.3</span> <span class="sec-title">library(semweb/rdf_db): 
The RDF database</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.1"><span class="sec-nr">3.3.1</span> <span class="sec-title">Query 
the RDF database</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.2"><span class="sec-nr">3.3.2</span> <span class="sec-title">Enumerating 
objects</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.3"><span class="sec-nr">3.3.3</span> <span class="sec-title">Modifying 
the RDF database</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.4"><span class="sec-nr">3.3.4</span> <span class="sec-title">Update 
view, transactions and snapshots</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.5"><span class="sec-nr">3.3.5</span> <span class="sec-title">Type 
checking predicates</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.6"><span class="sec-nr">3.3.6</span> <span class="sec-title">Loading 
and saving to file</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.7"><span class="sec-nr">3.3.7</span> <span class="sec-title">Graph 
manipulation</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.8"><span class="sec-nr">3.3.8</span> <span class="sec-title">Literal 
matching and indexing</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.9"><span class="sec-nr">3.3.9</span> <span class="sec-title">Predicate 
properties</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.10"><span class="sec-nr">3.3.10</span> <span class="sec-title">Prefix 
Handling</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.11"><span class="sec-nr">3.3.11</span> <span class="sec-title">Miscellaneous 
predicates</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:3.3.12"><span class="sec-nr">3.3.12</span> <span class="sec-title">Memory 
management considerations</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.4"><span class="sec-nr">3.4</span> <span class="sec-title">Monitoring 
the database</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.5"><span class="sec-nr">3.5</span> <span class="sec-title">Issues 
with rdf_db</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:4"><span class="sec-nr">4</span> <span class="sec-title">Plugin 
modules for rdf_db</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.1"><span class="sec-nr">4.1</span> <span class="sec-title">Hooks 
into the RDF library</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.2"><span class="sec-nr">4.2</span> <span class="sec-title">library(semweb/rdf_zlib_plugin): 
Reading compressed RDF</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.3"><span class="sec-nr">4.3</span> <span class="sec-title">library(semweb/rdf_http_plugin): 
Reading RDF from a HTTP server</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.4"><span class="sec-nr">4.4</span> <span class="sec-title">library(semweb/rdf_cache): 
Cache RDF triples</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.5"><span class="sec-nr">4.5</span> <span class="sec-title">library(semweb/rdf_litindex): 
Indexing words in literals</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:4.5.1"><span class="sec-nr">4.5.1</span> <span class="sec-title">Literal 
maps: Creating additional indices on literals</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.6"><span class="sec-nr">4.6</span> <span class="sec-title">library(semweb/rdf_persistency): 
Providing persistent storage</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:4.6.1"><span class="sec-nr">4.6.1</span> <span class="sec-title">Enriching 
the journals</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:5"><span class="sec-nr">5</span> <span class="sec-title">library(semweb/turtle): 
Turtle: Terse RDF Triple Language</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:6"><span class="sec-nr">6</span> <span class="sec-title">library(semweb/rdf_ntriples): 
Process files in the RDF N-Triples format</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:7"><span class="sec-nr">7</span> <span class="sec-title">library(semweb/rdfa): 
Extract RDF from an HTML or XML DOM</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:8"><span class="sec-nr">8</span> <span class="sec-title">library(semweb/rdfs): 
RDFS related queries</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:8.1"><span class="sec-nr">8.1</span> <span class="sec-title">Hierarchy 
and class-individual relations</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:8.2"><span class="sec-nr">8.2</span> <span class="sec-title">Collections 
and Containers</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:9"><span class="sec-nr">9</span> <span class="sec-title">Managing 
RDF input files</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:9.1"><span class="sec-nr">9.1</span> <span class="sec-title">The 
Manifest file</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:9.1.1"><span class="sec-nr">9.1.1</span> <span class="sec-title">Support 
for the VoID and VANN vocabularies</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:9.1.2"><span class="sec-nr">9.1.2</span> <span class="sec-title">Finding 
manifest files</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:9.2"><span class="sec-nr">9.2</span> <span class="sec-title">Usage 
scenarios</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:9.2.1"><span class="sec-nr">9.2.1</span> <span class="sec-title">Referencing 
resources</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:9.3"><span class="sec-nr">9.3</span> <span class="sec-title">Putting 
it all together</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:9.4"><span class="sec-nr">9.4</span> <span class="sec-title">Example: 
A metadata file for W3C WordNet</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:10"><span class="sec-nr">10</span> <span class="sec-title">library(semweb/sparql_client): 
SPARQL client library</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:11"><span class="sec-nr">11</span> <span class="sec-title">library(semweb/rdf_compare): 
Compare RDF graphs</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:12"><span class="sec-nr">12</span> <span class="sec-title">library(semweb/rdf_portray): 
Portray RDF resources</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:13"><span class="sec-nr">13</span> <span class="sec-title">Related 
packages</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:14"><span class="sec-nr">14</span> <span class="sec-title">Version 
3 release notes</span></a></div>
</div>
<h2 id="sec:semweb-intro"><a id="sec:1"><span class="sec-nr">1</span> <span class="sec-title">Introduction</span></a></h2>

<a id="sec:semweb-intro"></a>

<p>The core of the SWI-Prolog package <code>semweb</code> is an 
efficient main-memory RDF store written in C that is tightly integrated 
with Prolog. It provides a fully logical predicate <a id="idx:rdf3:1"></a><a class="pred" href="#rdf/3">rdf/3</a> 
to query the RDF store efficiently by using multiple (currently 9) 
indexes. In addition, SWI-Prolog provides libraries for reading and 
writing XML/RDF and Turtle and a library that provides persistency using 
a combination of efficient binary snapshots and journals.

<p>Below, we describe a few usage scenarios that guides the current 
design of this Prolog-based RDF store.

<p><b>Application prototyping platform</b> 

<p>Bundled with <a class="url" href="http://cliopatria.swi-prolog.org">ClioPatria</a>, 
the store is an efficient platform for prototyping a wide range of 
semantic web applications. Prolog, connected to the main-memory based 
store is a productive platform for writing application logic that can be 
made available through the SPARQL endpoint of ClioPatria, using an 
application specific API (typically based on JSON or XML) or as an HTML 
based end-user application. Prolog is more versatile than SPARQL, allows 
composing of the logic from small building blocks and does not suffer 
from the <em>Object-relational impedance mismatch</em>.

<p><b>Data integration</b> 

<p>The SWI-Prolog store is optimized for entailment on the
<code>rdfs:subPropertyOf</code> relation. The <code>rdfs:subPropertyOf</code> 
relation is crucial for integrating data from multiple sources while 
preserving the original richness of the sources because integration can 
be achieved by defining the native properties as sub-properties of 
properties from a unifying schema such as Dublin Core.

<p><b>Dynamic data</b> 

<p>This RDF store is one of the few stores that is primarily based on
<em>backward reasoning</em>. The big advantage of backward reasoning is 
that it can much easier deal with changes to the database because it 
does not have to take care of propagating the consequences. Backward 
reasoning reduces storage requirements. The price is more reasoning 
during querying. In many scenarios the extra reasoning using a main 
memory will outperform the fetching the precomputed results from 
external storage.

<p><b>Prototyping reasoning systems</b> 

<p>Reasoning systems, not necessarily limited to entailment reasoning, 
can be prototyped efficiently on the Prolog based store. This includes&lsquo;what-if' 
reasoning, which is supported by <em>snapshot</em> and
<em>transaction</em> isolation. These features, together with the 
concurrent loading capabilities, make the platform well equiped to 
collect relevant data from large external stores for intensive 
reasoning. Finally, the
<a class="url" href="http://www.swi-prolog.org/pldoc/package/tipc.html">TIPC</a> 
package can be used to create networks of cooperating RDF based agents.

<p><b>Streaming RDF</b> 

<p>Transactions, snapshots, concurrent modifications and the database 
monitoring facilities (see <a id="idx:rdfmonitor2:2"></a><a class="pred" href="#rdf_monitor/2">rdf_monitor/2</a>) 
make the platform well suited for prototyping systems that deal with 
streaming RDF data.

<p><h2 id="sec:semweb-scalability"><a id="sec:2"><span class="sec-nr">2</span> <span class="sec-title">Scalability</span></a></h2>

<a id="sec:semweb-scalability"></a>

<p>Depending on the OS and further application restrictions, the 
SWI-Prolog RDF stores scales to about 15&nbsp;million triples on 32-bit 
hardware. On 64-bit hardware, the scalability is limited by the amount 
of physical memory, allowing for approximately 4&nbsp;million triples 
per gigabyte. The other limiting factor for practical use is the time 
required to load data and/or restore the database from the persistent 
file backup. Performance depends highly on hardware, concurrent 
performance and whether or not the data is spread over multiple (named) 
graphs that can be loaded in parallel. Restoring over 20&nbsp;million 
triples per minute is feasible on medium hardware (Intel i7/2600 running 
Ubuntu 12.10).

<p><h2 id="sec:semweb-rdfapi"><a id="sec:3"><span class="sec-nr">3</span> <span class="sec-title">Two 
RDF APIs</span></a></h2>

<a id="sec:semweb-rdfapi"></a>

<p>The current&lsquo;semweb' package provides two sets of interface 
predicates. The original set is described in <a class="sec" href="#sec:3.3">section 
3.3</a>. The new API is described in <a class="sec" href="#sec:3.1">section 
3.1</a>. The original API was designed when RDF was not yet standardised 
and did not yet support data types and language indicators. The new API 
is designed from the RDF 1.1 specification, introducing consistent 
naming and access to literals using the <em>value space</em>. The new 
API is currently defined on top of the old API, so both APIs can be 
mixed in a single application.

<p><h3 id="sec:semweb-rdf11"><a id="sec:3.1"><span class="sec-nr">3.1</span> <span class="sec-title">library(semweb/rdf11): 
The RDF database</span></a></h3>

<a id="sec:semweb-rdf11"></a>

<p>The <code>library(semweb/rdf11)</code> provides a new interface to 
the SWI-Prolog RDF database based on the RDF 1.1 specification.

<p><h4 id="sec:rdf11-query"><a id="sec:3.1.1"><span class="sec-nr">3.1.1</span> <span class="sec-title">Query 
the RDF database</span></a></h4>

<p><a id="sec:rdf11-query"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf/3"><strong>rdf</strong>(<var>?S, 
?P, ?O</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf/4"><strong>rdf</strong>(<var>?S, 
?P, ?O, ?G</var>)</a></dt>
<dd class="defbody">
True if an RDF triple <var>&lt;</var><var>S</var>,<var>P</var>,<var>O</var><var>&gt;</var> 
exists, optionally in the graph <var>G</var>. The object <var>O</var> is 
either a resource (atom) or one of the terms listed below. The described 
types apply for the case where <var>O</var> is unbound. If <var>O</var> 
is instantiated it is converted according to the rules described with <a class="pred" href="#rdf_assert/3">rdf_assert/3</a>.

<p>Triples consist of the following three terms:

<p>
<ul class="latex">
<li>Blank nodes are encoded by atoms that start with&lsquo;_:`.
<li>IRIs appear in two notations:

<p>
<ul class="latex">
<li>Full IRIs are encoded by atoms that do not start with&lsquo;_:`. 
Specifically, an IRI term is not required to follow the IRI standard 
grammar.
<li>Abbreviated IRI notation that allows IRI prefix aliases that are 
registered by rdf_register_prefix/[2,3] to be used. Their notation is <code>Alias:Local</code>, 
where Alias and Local are atoms. Each abbreviated IRI is expanded by the 
system to a full IRI.
</ul>

<p>
<li>Literals appear in two notations:

<dl class="latex">
<dt><var><var>String</var></var> <strong>@</strong> <var><var>Lang</var></var></dt>
<dd class="defbody">
A language-tagged string, where <var>String</var> is a Prolog string and <var>Lang</var> 
is an atom.
</dd>
<dt><var><var>Value</var></var> <strong><code>^</code><code>^</code></strong> <var><var>Type</var></var></dt>
<dd class="defbody">
A type qualified literal. For unknown types, <var>Value</var> is a 
Prolog string. If type is known, the Prolog representations from the 
table below are used.
<blockquote>
<table class="latex frame-box">
<tr><td><b><b>Datatype IRI</b></b> </td><td><b><b>Prolog term</b></b> </td></tr>
<tr><td>xsd:float</td><td>float </td></tr>
<tr><td>xsd:double</td><td>float </td></tr>
<tr><td>xsd:decimal</td><td>float (1) </td></tr>
<tr><td>xsd:integer</td><td>integer </td></tr>
<tr><td>XSD integer sub-types</td><td>integer </td></tr>
<tr><td>xsd:boolean</td><td><code>true</code> or <code>false</code> </td></tr>
<tr><td>xsd:date</td><td><code>date(Y,M,D)</code> </td></tr>
<tr><td>xsd:dateTime</td><td><code>date_time(Y,M,D,HH,MM,SS)</code> 
(2,3) </td></tr>
<tr><td>xsd:gDay</td><td>integer </td></tr>
<tr><td>xsd:gMonth</td><td>integer </td></tr>
<tr><td>xsd:gMonthDay</td><td><code>month_day(M,D)</code> </td></tr>
<tr><td>xsd:gYear</td><td>integer </td></tr>
<tr><td>xsd:gYearMonth</td><td><code>year_month(Y,M)</code> </td></tr>
<tr><td>xsd:time</td><td><code>time(HH,MM,SS)</code> (2) </td></tr>
</table>
</blockquote>
</dd>
</dl>

</ul>

<p>Notes:

<p>(1) The current implementation of <code>xsd:decimal</code> values as 
floats is formally incorrect. Future versions of SWI-Prolog may 
introduce decimal as a subtype of rational.

<p>(2) <var>SS</var> fields denote the number of seconds. This can 
either be an integer or a float.

<p>(3) The <code>date_time</code> structure can have a 7th field that 
denotes the timezone offset <b>in seconds</b> as an integer.

<p>In addition, a <i>ground</i> object value is translated into a 
properly typed RDF literal using <a class="pred" href="#rdf_canonical_literal/2">rdf_canonical_literal/2</a>.

<p>There is a fine distinction in how duplicate statements are handled 
in rdf/[3,4]: backtracking over <a class="pred" href="#rdf/3">rdf/3</a> 
will never return duplicate triples that appear in multiple graphs. <a class="pred" href="#rdf/4">rdf/4</a> 
will return such duplicate triples, because their graph term differs.
<table class="arglist">
<tr><td><var>S</var> </td><td>is the subject term. It is either a blank 
node or IRI. </td></tr>
<tr><td><var>P</var> </td><td>is the predicate term. It is always an 
IRI. </td></tr>
<tr><td><var>O</var> </td><td>is the object term. It is either a 
literal, a blank node or IRI (except for <code>true</code> and <code>false</code> 
that denote the values of datatype XSD boolean). </td></tr>
<tr><td><var>G</var> </td><td>is the graph term. It is always an IRI. </td></tr>
</table>

<dl class="tags">
<dt class="mtag">See also</dt>
<dd>
- <a class="url" href="http://www.w3.org/TR/sparql11-query/#sparqlTriplePatterns">Triple 
pattern querying</a> <br>
- <span class="pred-ext">xsd_number_string/2</span> and <span class="pred-ext">xsd_time_string/3</span> 
are used to convert between lexical representations and Prolog terms.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_has/3"><strong>rdf_has</strong>(<var>?S, 
+P, ?O</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_has/4"><strong>rdf_has</strong>(<var>?S, 
+P, ?O, -RealP</var>)</a></dt>
<dd class="defbody">
Similar to <a class="pred" href="#rdf/3">rdf/3</a> and <a class="pred" href="#rdf/4">rdf/4</a>, 
but <var>P</var> matches all predicates that are defined as an 
rdfs:subPropertyOf of <var>P</var>. This predicate also recognises the 
predicate properties <code>inverse_of</code> and
<code>symmetric</code>. See <a class="pred" href="#rdf_set_predicate/2">rdf_set_predicate/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_reachable/3"><strong>rdf_reachable</strong>(<var>?S, 
+P, ?O</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_reachable/5"><strong>rdf_reachable</strong>(<var>?S, 
+P, ?O, +MaxD, -D</var>)</a></dt>
<dd class="defbody">
True when <var>O</var> can be reached from <var>S</var> using the 
transitive closure of <var>P</var>. The predicate uses (the internals 
of) <a class="pred" href="#rdf_has/3">rdf_has/3</a> and thus matches 
both rdfs:subPropertyOf and the <code>inverse_of</code> and
<code>symmetric</code> predicate properties. The version <a class="pred" href="#rdf_reachable/5">rdf_reachable/5</a> 
maximizes the steps considered and returns the number of steps taken.

<p>If both <var>S</var> and <var>O</var> are given, these predicates are <code>semidet</code>. 
The number of steps <var>D</var> is minimal because the implementation 
uses
<i>breadth first</i> search.
</dd>
</dl>

<p><b>Constraints on literal values</b> 

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="{}/1"><strong>{}</strong>(<var>+Where</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_where/1"><strong>rdf_where</strong>(<var>+Where</var>)</a></dt>
<dd class="defbody">
Formulate constraints on RDF terms, notably literals. These are intended 
to be used as illustrated below. RDF constraints are pure: they may be 
placed before, after or inside a graph pattern and, provided the code 
contains no <i>commit</i> operations (!, <code>-&gt;</code>), the 
semantics of the goal remains the same. Preferably, constraints are 
placed <i>before</i> the graph pattern as they often help the RDF 
database to exploit its literal indexes. In the example below, the 
database can choose between using the subject and/or predicate hash or 
the ordered literal table.

<pre class="code">
    { Date &gt;= "2000-01-01"^^xsd:date },
    rdf(S, P, Date)
</pre>

<p>The following constraints are currently defined:

<dl class="latex">
<dt><var><code><code>&gt;</code></code></var> <strong><code>,</code></strong> <var><code><code><code>&gt;=</code></code>,<code><code><code>==</code></code>,<code><code><code>=&lt;</code></code>,<code><code>&lt;</code></code></code></code></code></var></dt>
<dd class="defbody">
The comparison operators are defined between numbers (of any recognised 
type), typed literals of the same type and langStrings of the same 
language.
</dd>
<dt><strong>prefix</strong>(<var>String, Pattern</var>)</dt>
<dt><strong>substring</strong>(<var>String, Pattern</var>)</dt>
<dt><strong>word</strong>(<var>String, Pattern</var>)</dt>
<dt><strong>like</strong>(<var>String, Pattern</var>)</dt>
<dt><strong>icase</strong>(<var>String, Pattern</var>)</dt>
<dd class="defbody">
Text matching operators that act on both typed literals and langStrings.
</dd>
<dt><strong>lang_matches</strong>(<var>Term, Pattern</var>)</dt>
<dd class="defbody">
Demands a full RDF term (Text@Lang) or a plain <var>Lang</var> term to 
match the language pattern <var>Pattern</var>.
</dd>
</dl>

<p>The predicates <a class="pred" href="#rdf_where/1">rdf_where/1</a> 
and {}/1 are identical. The
<a class="pred" href="#rdf_where/1">rdf_where/1</a> variant is provided 
to avoid ambiguity in applications where {}/1 is used for other 
purposes. Note that it is also possible to write <code>rdf11:{...}</code>.
</dd>
</dl>

<p><h4 id="sec:rdf11-enum"><a id="sec:3.1.2"><span class="sec-nr">3.1.2</span> <span class="sec-title">Enumerating 
and testing objects</span></a></h4>

<p><a id="sec:rdf11-enum"></a><b>Enumerating objects by role</b> <a id="sec:rdf11-enum-role"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_subject/1"><strong>rdf_subject</strong>(<var>?S</var>)</a></dt>
<dd class="defbody">
True when <var>S</var> is a currently known <i>subject</i>, i.e. it 
appears in the subject position of some visible triple. The predicate is
<i>semidet</i> if <var>S</var> is ground.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_predicate/1"><strong>rdf_predicate</strong>(<var>?P</var>)</a></dt>
<dd class="defbody">
True when <var>P</var> is a currently known predicate, i.e. it appears 
in the predicate position of some visible triple. The predicate is
<i>semidet</i> if <var>P</var> is ground.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_object/1"><strong>rdf_object</strong>(<var>?O</var>)</a></dt>
<dd class="defbody">
True when <var>O</var> is a currently known object, i.e. it appears in 
the object position of some visible triple. If Term is ground, it is 
pre-processed as the object argument of <a class="pred" href="#rdf_assert/3">rdf_assert/3</a> 
and the predicate is <i>semidet</i>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_node/1"><strong>rdf_node</strong>(<var>?T</var>)</a></dt>
<dd class="defbody">
True when <var>T</var> appears in the subject or object position of a 
known triple, i.e., is a node in the RDF graph.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_graph/1"><strong>rdf_graph</strong>(<var>?Graph</var>)</a></dt>
<dd class="defbody">
True when <var>Graph</var> is an existing graph.
</dd>
</dl>

<p><b>Enumerating objects by type</b> <a id="sec:rdf11-enum-type"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_literal/1"><strong>rdf_literal</strong>(<var>?Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> is a known literal. If <var>Term</var> is 
ground, it is pre-processed as the object argument of <a class="pred" href="#rdf_assert/3">rdf_assert/3</a> 
and the predicate is <i>semidet</i>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_bnode/1"><strong>rdf_bnode</strong>(<var>?BNode</var>)</a></dt>
<dd class="defbody">
True if <var>BNode</var> is a currently known blank node. The predicate 
is
<i>semidet</i> if <var>BNode</var> is ground.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_iri/1"><strong>rdf_iri</strong>(<var>?IRI</var>)</a></dt>
<dd class="defbody">
True if <var>IRI</var> is a current <var>IRI</var>. The predicate is <i>semidet</i> 
if <var>IRI</var> is ground.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_name/1"><strong>rdf_name</strong>(<var>?Name</var>)</a></dt>
<dd class="defbody">
True if <var>Name</var> is a current IRI or literal. The predicate is
<i>semidet</i> if <var>Name</var> is ground.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_term/1"><strong>rdf_term</strong>(<var>?Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> appears in the RDF database. <var>Term</var> is 
either an IRI, literal or blank node and may appear in any position of 
any triple. If <var>Term</var> is ground, it is pre-processed as the 
object argument of <a class="pred" href="#rdf_assert/3">rdf_assert/3</a> 
and the predicate is <i>semidet</i>.
</dd>
</dl>

<p><b>Testing objects types</b> <a id="sec:rdf11-type-test"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_iri/1"><strong>rdf_is_iri</strong>(<var>@IRI</var>)</a></dt>
<dd class="defbody">
True if <var>IRI</var> is an RDF <var>IRI</var> term.

<p>For performance reasons, this does not check for compliance to the 
syntax defined in <a class="url" href="http://www.ietf.org/rfc/rfc3987.txt">RFC 
3987</a>. This checks whether the term is (1) an atom and (2) not a 
blank node identifier.

<p>Success of this goal does not imply that the <var>IRI</var> is 
present in the database (see <a class="pred" href="#rdf_iri/1">rdf_iri/1</a> 
for that).</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_bnode/1"><strong>rdf_is_bnode</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> is an RDF blank node identifier.

<p>A blank node is represented by an atom that starts with
<code>_:</code>.

<p>Success of this goal does not imply that the blank node is present in 
the database (see <a class="pred" href="#rdf_bnode/1">rdf_bnode/1</a> 
for that).

<p>For backwards compatibility, atoms that are represented with an atom 
that starts with <code>__</code> are also considered to be a blank node.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_literal/1"><strong>rdf_is_literal</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> is an RDF literal term.

<p>An RDF literal term is of the form <code>String@LanguageTag</code> or
<code>Value^^Datatype</code>.

<p>Success of this goal does not imply that the literal is well-formed 
or that it is present in the database (see
<a class="pred" href="#rdf_literal/1">rdf_literal/1</a> for that).</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_name/1"><strong>rdf_is_name</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> is an RDF Name, i.e., an IRI or literal.

<p>Success of this goal does not imply that the name is well-formed or 
that it is present in the database (see
<a class="pred" href="#rdf_name/1">rdf_name/1</a> for that).</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_object/1"><strong>rdf_is_object</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> can appear in the object position of a triple.

<p>Success of this goal does not imply that the object term in 
well-formed or that it is present in the database (see
<a class="pred" href="#rdf_object/1">rdf_object/1</a> for that).

<p>Since any RDF term can appear in the object position, this is 
equaivalent to <a class="pred" href="#rdf_is_term/1">rdf_is_term/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_predicate/1"><strong>rdf_is_predicate</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> can appear in the predicate position of a 
triple.

<p>Success of this goal does not imply that the predicate term is 
present in the database (see <a class="pred" href="#rdf_predicate/1">rdf_predicate/1</a> 
for that).

<p>Since only IRIs can appear in the predicate position, this is 
equivalent to <a class="pred" href="#rdf_is_iri/1">rdf_is_iri/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_subject/1"><strong>rdf_is_subject</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> can appear in the subject position of a triple.

<p>Only blank nodes and IRIs can appear in the subject position.

<p>Success of this goal does not imply that the subject term is present 
in the database (see <a class="pred" href="#rdf_subject/1">rdf_subject/1</a> 
for that).

<p>Since blank nodes are represented by atoms that start with&lsquo;_:` 
and an IRIs are atoms as well, this is equivalent to
<code>atom(Term)</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_term/1"><strong>rdf_is_term</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> can be used as an RDF term, i.e., if <var>Term</var> 
is either an IRI, a blank node or an RDF literal.

<p>Success of this goal does not imply that the RDF term is present in 
the database (see <a class="pred" href="#rdf_term/1">rdf_term/1</a> for 
that).
</dd>
</dl>

<p><h4 id="sec:rdf11-literal"><a id="sec:3.1.3"><span class="sec-nr">3.1.3</span> <span class="sec-title">RDF 
literals</span></a></h4>

<p><a id="sec:rdf11-literal"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_canonical_literal/2"><strong>rdf_canonical_literal</strong>(<var>++In, 
-Literal</var>)</a></dt>
<dd class="defbody">
Transform a relaxed literal specification as allowed for
<a class="pred" href="#rdf_assert/3">rdf_assert/3</a> into its canonical 
form. The following Prolog terms are translated:
<blockquote>
<table class="latex frame-box">
<tr><td><b><b>Prolog Term</b></b> </td><td><b><b>Datatype IRI</b></b> </td></tr>
<tr><td>float</td><td>xsd:double </td></tr>
<tr><td>integer</td><td>xsd:integer </td></tr>
<tr><td>string</td><td>xsd:string </td></tr>
<tr><td><code>true</code> or <code>false</code> </td><td>xsd:boolean </td></tr>
<tr><td><code>date(Y,M,D)</code> </td><td>xsd:date </td></tr>
<tr><td><code>date_time(Y,M,D,HH,MM,SS)</code> </td><td>xsd:dateTime </td></tr>
<tr><td><code>date_time(Y,M,D,HH,MM,SS,TZ)</code> </td><td>xsd:dateTime </td></tr>
<tr><td><code>month_day(M,D)</code> </td><td>xsd:gMonthDay </td></tr>
<tr><td><code>year_month(Y,M)</code> </td><td>xsd:gYearMonth </td></tr>
<tr><td><code>time(HH,MM,SS)</code> </td><td>xsd:time </td></tr>
</table>
</blockquote>

<p>For example:

<pre class="code">
?- rdf_canonical_literal(42, X).
X = 42^^'http://www.w3.org/2001/XMLSchema#integer'.
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_lexical_form/2"><strong>rdf_lexical_form</strong>(<var>++Literal, 
-Lexical:compound</var>)</a></dt>
<dd class="defbody">
True when <var>Lexical</var> is the lexical form for the literal <var>Literal</var>.
<var>Lexical</var> is of one of the forms below. The ntriples 
serialization is obtained by transforming String into a proper ntriples 
string using double quotes and escaping where needed and turning Type 
into a proper IRI reference.

<p>
<ul class="compact">
<li>String<code>^</code><code>^</code>Type
<li>String@Lang
</ul>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_compare/3"><strong>rdf_compare</strong>(<var>-Diff, 
+Left, +Right</var>)</a></dt>
<dd class="defbody">
True if the RDF terms <var>Left</var> and <var>Right</var> are ordered 
according to the comparison operator <var>Diff</var>. The ordering is 
defines as:

<p>
<ul class="latex">
<li>Literal <var>&lt;</var> BNode <var>&lt;</var> IRI
<li>For literals

<p>
<ul class="latex">
<li>Numeric <var>&lt;</var> non-numeric
<li>Numeric literals are ordered by value. If both are equal, floats are 
ordered before integers.
<li>Other data types are ordered lexicographically.
</ul>

<p>
<li>BNodes and IRIs are ordered lexicographically.
</ul>

<p>Note that this ordering is a complete ordering of RDF terms that is 
consistent with the partial ordering defined by SPARQL.
<table class="arglist">
<tr><td><var>Diff</var> </td><td>is one of <code>&lt;</code>, <code>=</code> 
or <code>&gt;</code> </td></tr>
</table>
</dd>
</dl>

<p><h4 id="sec:rdf11-graph"><a id="sec:3.1.4"><span class="sec-nr">3.1.4</span> <span class="sec-title">Accessing 
RDF graphs</span></a></h4>

<p><a id="sec:rdf11-graph"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_default_graph/1"><strong>rdf_default_graph</strong>(<var>-Graph</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_default_graph/2"><strong>rdf_default_graph</strong>(<var>-Old, 
+New</var>)</a></dt>
<dd class="defbody">
Query/set the notion of the default graph. The notion of the default 
graph is local to a thread. Threads created inherit the default graph 
from their creator. See <span class="pred-ext">set_prolog_flag/2</span>.
</dd>
</dl>

<p><h4 id="sec:rdf11-modify"><a id="sec:3.1.5"><span class="sec-nr">3.1.5</span> <span class="sec-title">Modifying 
the RDF store</span></a></h4>

<p><a id="sec:rdf11-modify"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert/3"><strong>rdf_assert</strong>(<var>+S, 
+P, +O</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert/4"><strong>rdf_assert</strong>(<var>+S, 
+P, +O, +G</var>)</a></dt>
<dd class="defbody">
Assert a new triple. If <var>O</var> is a literal, certain Prolog terms 
are translated to typed RDF literals. These conversions are described 
with <a class="pred" href="#rdf_canonical_literal/2">rdf_canonical_literal/2</a>.

<p>If a type is provided using Value<code>^</code><code>^</code>Type 
syntax, additional conversions are performed. All types accept either an 
atom or Prolog string holding a valid RDF lexical value for the type and 
xsd:float and xsd:double accept a Prolog integer.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_retractall/3"><strong>rdf_retractall</strong>(<var>?S, 
?P, ?O</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_retractall/4"><strong>rdf_retractall</strong>(<var>?S, 
?P, ?O, ?G</var>)</a></dt>
<dd class="defbody">
Remove all matching triples from the database. Matching is performed 
using the same rules as <a class="pred" href="#rdf/3">rdf/3</a>. The 
call does not instantiate any of its arguments.</dd>
<dt class="pubdef"><a id="rdf_create_bnode/1"><strong>rdf_create_bnode</strong>(<var>--BNode</var>)</a></dt>
<dd class="defbody">
Create a new <var>BNode</var>. A blank node is an atom starting with
<code>_:</code>. Blank nodes generated by this predicate are of the form
<code>_:genid</code> followed by a unique integer.
</dd>
</dl>

<p><h4 id="sec:rdf11-collections"><a id="sec:3.1.6"><span class="sec-nr">3.1.6</span> <span class="sec-title">Accessing 
RDF collections</span></a></h4>

<p><a id="sec:rdf11-collections"></a>

<p>The following predicates are utilities to access RDF 1.1 <i>collections</i>. 
A collection is a linked list created from <code>rdf:first</code> and <code>rdf:next</code> 
triples, ending in <code>rdf:nil</code>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_last/2"><strong>rdf_last</strong>(<var>+RDFList, 
-Last</var>)</a></dt>
<dd class="defbody">
True when <var>Last</var> is the last element of <var>RDFList</var>. 
Note that if the last cell has multiple rdf:first triples, this 
predicate becomes nondet.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_list/1"><strong>rdf_list</strong>(<var>?RDFTerm</var>)</a></dt>
<dd class="defbody">
True if <var>RDFTerm</var> is a proper RDF list. This implies that every 
node in the list has an <code>rdf:first</code> and <code>rdf:rest</code> 
property and the list ends in <code>rdf:nil</code>.

<p>If <var>RDFTerm</var> is unbound, <var>RDFTerm</var> is bound to each <i>maximal</i> 
RDF list. An RDF list is <i>maximal</i> if there is no triple <code>rdf(_, rdf:rest, RDFList)</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_list/2"><strong>rdf_list</strong>(<var>+RDFList, 
-PrologList</var>)</a></dt>
<dd class="defbody">
True when <var>PrologList</var> represents the rdf:first objects for all 
cells in <var>RDFList</var>. Note that this can be non-deterministic if 
cells have multiple rdf:first or rdf:rest triples.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_length/2"><strong>rdf_length</strong>(<var>+RDFList, 
-Length:nonneg</var>)</a></dt>
<dd class="defbody">
True when <var>Length</var> is the number of cells in <var>RDFList</var>. 
Note that a list cell may have multiple rdf:rest triples, which makes 
this predicate non-deterministic. This predicate does not check whether 
the list cells have associated values (rdf:first). The list must end in 
rdf:nil.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_member/2"><strong>rdf_member</strong>(<var>?Member, 
+RDFList</var>)</a></dt>
<dd class="defbody">
True when <var>Member</var> is a member of <var>RDFList</var></dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_nth0/3"><strong>rdf_nth0</strong>(<var>?Index, 
+RDFList, ?X</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_nth1/3"><strong>rdf_nth1</strong>(<var>?Index, 
+RDFList, ?X</var>)</a></dt>
<dd class="defbody">
True when <var>X</var> is the <var>Index</var>-th element (0-based or 
1-based) of
<var>RDFList</var>. This predicate is deterministic if <var>Index</var> 
is given and the list has no multiple rdf:first or rdf:rest values.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_list/2"><strong>rdf_assert_list</strong>(<var>+PrologList, 
?RDFList</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_list/3"><strong>rdf_assert_list</strong>(<var>+PrologList, 
?RDFList, +Graph</var>)</a></dt>
<dd class="defbody">
Create an RDF list from the given Prolog List. <var>PrologList</var> 
must be a proper Prolog list and all members of the list must be 
acceptable as object for <a class="pred" href="#rdf_assert/3">rdf_assert/3</a>. 
If <var>RDFList</var> is unbound and
<var>PrologList</var> is not empty, <a class="pred" href="#rdf_create_bnode/1">rdf_create_bnode/1</a> 
is used to create
<var>RDFList</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_retract_list/1"><strong>rdf_retract_list</strong>(<var>+RDFList</var>)</a></dt>
<dd class="defbody">
Retract the rdf:first, rdf:rest and rdf:type=rdf:'List' triples from all 
nodes reachable through rdf:rest. Note that other triples that exist on 
the nodes are left untouched.
</dd>
</dl>

<p><h3 id="sec:rdf11containers"><a id="sec:3.2"><span class="sec-nr">3.2</span> <span class="sec-title">library(semweb/rdf11_containers): 
RDF 1.1 Containers</span></a></h3>

<p><a id="sec:rdf11containers"></a>

<dl class="tags">
<dt class="mtag">author</dt>
<dd>
- Wouter Beek <br>
- Jan Wielemaker
</dd>
<dt class="tag">version</dt>
<dd>
2016/01
</dd>
<dt class="tag">See also</dt>
<dd>
<a class="url" href="http://www.w3.org/TR/2014/REC-rdf-schema-20140225/#ch_containervocab">http://www.w3.org/TR/2014/REC-rdf-schema-20140225/#ch_containervocab</a>
</dd>
<dt class="tag">Compatibility</dt>
<dd>
RDF 1.1
</dd>
</dl>

<p>Implementation of the conventional human interpretation of RDF 1.1 
containers.

<p>RDF containers are open enumeration structures as opposed to RDF 
collections or RDF lists which are closed enumeration structures. The 
same resource may appear in a container more than once. A container may 
be contained in itself.
<hr>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_alt/3"><strong>rdf_alt</strong>(<var>+Alt, 
?Default, ?Others</var>)</a></dt>
<dd class="defbody">
True when <var>Alt</var> is an instance of <code>rdf:Alt</code> with 
first member
<var>Default</var> and remaining members <var>Others</var>.

<p>Notice that this construct adds no machine-processable semantics but 
is conventionally used to indicate to a human reader that the numerical 
ordering of the container membership properties of Container is intended 
to only be relevant in distinguishing between the first and all 
non-first members.

<p><var>Default</var> denotes the default option to take when choosing 
one of the alternatives container in Container. <var>Others</var> 
denotes the non-default options that can be chosen from.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_alt/3"><strong>rdf_assert_alt</strong>(<var>?Alt, 
+Default, +Others:list</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_alt/4"><strong>rdf_assert_alt</strong>(<var>?Alt, 
+Default, +Others:list, +Graph</var>)</a></dt>
<dd class="defbody">
Create an rdf:<var>Alt</var> with the given <var>Default</var> and <var>Others</var>. <var>Default</var> 
and the members of <var>Others</var> must be valid object terms for
<a class="pred" href="#rdf_assert/3">rdf_assert/3</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_bag/2"><strong>rdf_bag</strong>(<var>+Bag, 
-List:list</var>)</a></dt>
<dd class="defbody">
True when <var>Bag</var> is an rdf:<var>Bag</var> and set is the set 
values related through container membership properties to <var>Bag</var>.

<p>Notice that this construct adds no machine-processable semantics but 
is conventionally used to indicate to a human reader that the numerical 
ordering of the container membership properties of Container is intended 
to not be significant.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_bag/2"><strong>rdf_assert_bag</strong>(<var>?Bag, 
+Set:list</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_bag/3"><strong>rdf_assert_bag</strong>(<var>?Bag, 
+Set:list, +Graph</var>)</a></dt>
<dd class="defbody">
Create an rdf:<var>Bag</var> from the given set of values. The members 
of
<var>Set</var> must be valid object terms for <a class="pred" href="#rdf_assert/3">rdf_assert/3</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_seq/2"><strong>rdf_seq</strong>(<var>+Seq, 
-List:list</var>)</a></dt>
<dd class="defbody">
True when <var>Seq</var> is an instance of rdf:<var>Seq</var> and <var>List</var> 
is a list of associated values, ordered according to the container 
membership property used.

<p>Notice that this construct adds no machine-processable semantics but 
is conventionally used to indicate to a human reader that the numerical 
ordering of the container membership properties of Container is intended 
to be significant.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_seq/2"><strong>rdf_assert_seq</strong>(<var>?Seq, 
+List</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert_seq/3"><strong>rdf_assert_seq</strong>(<var>?Seq, 
+List, +Graph</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdfs_container/2"><strong>rdfs_container</strong>(<var>+Container, 
-List</var>)</a></dt>
<dd class="defbody">
True when <var>List</var> is the list of objects attached to <var>Container</var> 
using a container membership property (rdf:_0, rdf:_1, ...). If multiple 
objects are connected to the <var>Container</var> using the same 
membership property, this predicate selects one value 
non-deterministically.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdfs_container_membership_property/1"><strong>rdfs_container_membership_property</strong>(<var>?Property</var>)</a></dt>
<dd class="defbody">
True when <var>Property</var> is a container membership property 
(rdf:_1, rdf:_2, ...).</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdfs_container_membership_property/2"><strong>rdfs_container_membership_property</strong>(<var>?Property, 
?Number:nonneg</var>)</a></dt>
<dd class="defbody">
True when <var>Property</var> is the Nth container membership property.

<p>Success of this goal does not imply that <var>Property</var> is 
present in the database.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdfs_member/2"><strong>rdfs_member</strong>(<var>?Elem, 
?Container</var>)</a></dt>
<dd class="defbody">
True if <code>rdf(Container, P, Elem)</code> is true and P is a 
container membership property.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdfs_nth0/3"><strong>rdfs_nth0</strong>(<var>?N, 
?Container, ?Elem</var>)</a></dt>
<dd class="defbody">
True if <code>rdf(Container, P, Elem)</code> is true and P is the <var>N</var>-th 
(0-based) container membership property.
</dd>
</dl>

<p><h3 id="sec:semweb-rdf-db"><a id="sec:3.3"><span class="sec-nr">3.3</span> <span class="sec-title">library(semweb/rdf_db): 
The RDF database</span></a></h3>

<a id="sec:semweb-rdf-db"></a>

<p>The central module of the RDF infrastructure is <code>library(semweb/rdf_db)</code>. 
It provides storage and indexed querying of RDF triples. RDF data is 
stored as quintuples. The first three elements denote the RDF triple. 
The extra <i>Graph</i> and <i>Line</i> elements provide information 
about the origin of the triple.

<p>The actual storage is provided by the <i>foreign language (C)</i> 
module. Using a dedicated C-based implementation we can reduce memory 
usage and improve indexing capabilities, for example by providing a 
dedicated index to support entailment over <code>rdfs:subPropertyOf</code>. 
Currently the following indexes are provided (S=subject, P=predicate, 
O=object, G=graph):

<p>
<ul class="latex">
<li>S, P, O, SP, PO, SPO, G, SG, PG
<li>Predicates connected by <b>rdfs:subPropertyOf</b> are combined in a <i>predicate 
cloud</i>. The system causes multiple predicates in the cloud to share 
the same hash. The cloud maintains a 2-dimensional array that expresses 
the closure of all <code>rdfs:subPropertyOf</code> relations. This index 
supports <a class="pred" href="#rdf_has/3">rdf_has/3</a> to query a 
property and all its children efficiently.
<li>Additional indexes for predicates, resources and graphs allow 
enumerating these objects without duplicates. For example, using <a class="pred" href="#rdf_resource/1">rdf_resource/1</a> 
we enumerate all resources in the database only once, while enumeration 
using e.g., <code>(rdf(R,_,_);rdf(_,_,R))</code> normally produces many 
duplicate answers.
<li>Literal <i>Objects</i> are combined in a <i>skip list</i> after case 
normalization. This provides for efficient case-insensitive search, 
prefix and range search. The plugin library <code>library(semweb/litindex)</code> 
provides indexed search on tokens inside literals.
</ul>

<p><h4 id="sec:semweb-query"><a id="sec:3.3.1"><span class="sec-nr">3.3.1</span> <span class="sec-title">Query 
the RDF database</span></a></h4>

<p><a id="sec:semweb-query"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf/3"><strong>rdf</strong>(<var>?Subject, 
?Predicate, ?Object</var>)</a></dt>
<dd class="defbody">
Elementary query for triples. <var>Subject</var> and <var>Predicate</var> 
are atoms representing the fully qualified URL of the resource. <var>Object</var> 
is either an atom representing a resource or <code>literal(Value)</code> 
if the object is a literal value. If a value of the form 
NameSpaceID:LocalName is provided it is expanded to a ground atom using <span class="pred-ext">expand_goal/2</span>. 
This implies you can use this construct in compiled code without paying 
a performance penalty. Literal values take one of the following forms:

<dl class="latex">
<dt><strong><var>Atom</var></strong></dt>
<dd class="defbody">
If the value is a simple atom it is the textual representation of a 
string literal without explicit type or language qualifier.
</dd>
<dt><strong>lang</strong>(<var>LangID, Atom</var>)</dt>
<dd class="defbody">
<var>Atom</var> represents the text of a string literal qualified with 
the given language.
</dd>
<dt><strong>type</strong>(<var>TypeID, Value</var>)</dt>
<dd class="defbody">
Used for attributes qualified using the <code>rdf:datatype</code>
<var>TypeID</var>. The <var>Value</var> is either the textual 
representation or a natural Prolog representation. See the option 
convert_typed_literal(:Convertor) of the parser. The storage layer 
provides efficient handling of atoms, integers (64-bit) and floats 
(native C-doubles). All other data is represented as a Prolog record.
</dd>
</dl>

<p>For literal querying purposes, <var>Object</var> can be of the form
<code>literal(+Query, -Value)</code>, where Query is one of the terms 
below. If the Query takes a literal argument and the value has a numeric 
type numerical comparison is performed.

<dl class="latex">
<dt><strong>plain</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Perform exact match and demand the language or type qualifiers to match. 
This query is fully indexed.
</dd>
<dt><strong>icase</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Perform a full but case-insensitive match. This query is fully indexed.
</dd>
<dt><strong>exact</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Same as <code>icase(Text)</code>. Backward compatibility.
</dd>
<dt><strong>substring</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Match any literal that contains <var>Text</var> as a case-insensitive 
substring. The query is not indexed on <var>Object</var>.
</dd>
<dt><strong>word</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Match any literal that contains <var>Text</var> delimited by a non 
alpha-numeric character, the start or end of the string. The query is 
not indexed on <var>Object</var>.
</dd>
<dt><strong>prefix</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Match any literal that starts with <var>Text</var>. This call is 
intended for completion. The query is indexed using the skip list of 
literals.
</dd>
<dt><strong>ge</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
Match any literal that is equal or larger than <var>Literal</var> in the 
ordered set of literals.
</dd>
<dt><strong>gt</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
Match any literal that is larger than <var>Literal</var> in the ordered 
set of literals.
</dd>
<dt><strong>eq</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
Match any literal that is equal to <var>Literal</var> in the ordered set 
of literals.
</dd>
<dt><strong>le</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
Match any literal that is equal or smaller than <var>Literal</var> in 
the ordered set of literals.
</dd>
<dt><strong>lt</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
Match any literal that is smaller than <var>Literal</var> in the ordered 
set of literals.
</dd>
<dt><strong>between</strong>(<var>+Literal1, +Literal2</var>)</dt>
<dd class="defbody">
Match any literal that is between <var>Literal1</var> and <var>Literal2</var> 
in the ordered set of literals. This may include both <var>Literal1</var> 
and
<var>Literal2</var>.
</dd>
<dt><strong>like</strong>(<var>+Pattern</var>)</dt>
<dd class="defbody">
Match any literal that matches <var>Pattern</var> case insensitively, 
where the&lsquo;*' character in <var>Pattern</var> matches zero or more 
characters.
</dd>
</dl>

<p>Backtracking never returns duplicate triples. Duplicates can be 
retrieved using <a class="pred" href="#rdf/4">rdf/4</a>. The predicate <a class="pred" href="#rdf/3">rdf/3</a> 
raises a type-error if called with improper arguments. If <a class="pred" href="#rdf/3">rdf/3</a> 
is called with a term <code>literal(_)</code> as <var>Subject</var> or <var>Predicate</var> 
object it fails silently. This allows for graph matching goals like
<code>rdf(S,P,O)</code>,<code>rdf(O,P2,O2)</code> to proceed without 
errors.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf/4"><strong>rdf</strong>(<var>?Subject, 
?Predicate, ?Object, ?Source</var>)</a></dt>
<dd class="defbody">
As <a class="pred" href="#rdf/3">rdf/3</a> but in addition query the 
graph to which the triple belongs. Unlike <a class="pred" href="#rdf/3">rdf/3</a>, 
this predicate does not remove duplicates from the result set.
<table class="arglist">
<tr><td><var>Source</var> </td><td>is a term Graph:Line. If <var>Source</var> 
is instatiated, passing an atom is the same as passing Atom:_. </td></tr>
</table>
</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_has/3"><strong>rdf_has</strong>(<var>?Subject, 
+Predicate, ?Object</var>)</a></dt>
<dd class="defbody">
Succeeds if the triple <code>rdf(Subject, Predicate, Object)</code> is 
true exploiting the rdfs:subPropertyOf predicate as well as inverse 
predicates declared using <a class="pred" href="#rdf_set_predicate/2">rdf_set_predicate/2</a> 
with the
<code>inverse_of</code> property.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_has/4"><strong>rdf_has</strong>(<var>?Subject, 
+Predicate, ?Object, -RealPredicate</var>)</a></dt>
<dd class="defbody">
Same as <a class="pred" href="#rdf_has/3">rdf_has/3</a>, but <var>RealPredicate</var> 
is unified to the actual predicate that makes this relation true. <var>RealPredicate</var> 
must be
<var>Predicate</var> or an rdfs:subPropertyOf <var>Predicate</var>. If 
an inverse match is found, <var>RealPredicate</var> is the term <code>inverse_of(Pred)</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_reachable/3"><strong>rdf_reachable</strong>(<var>?Subject, 
+Predicate, ?Object</var>)</a></dt>
<dd class="defbody">
Is true if <var>Object</var> can be reached from <var>Subject</var> 
following the transitive predicate <var>Predicate</var> or a 
sub-property thereof, while repecting the <code>symetric(true)</code> or <code>inverse_of(P2)</code> 
properties.

<p>If used with either <var>Subject</var> or <var>Object</var> unbound, 
it first returns the origin, followed by the reachable nodes in 
breadth-first search-order. The implementation internally looks one 
solution ahead and succeeds deterministically on the last solution. This 
predicate never generates the same node twice and is robust against 
cycles in the transitive relation.

<p>With all arguments instantiated, it succeeds deterministically if a 
path can be found from <var>Subject</var> to <var>Object</var>. 
Searching starts at <var>Subject</var>, assuming the branching factor is 
normally lower. A call with both <var>Subject</var> and <var>Object</var> 
unbound raises an instantiation error. The following example generates 
all subclasses of rdfs:Resource:

<pre class="code">
?- rdf_reachable(X, rdfs:subClassOf, rdfs:'Resource').
X = 'http://www.w3.org/2000/01/rdf-schema#Resource' ;
X = 'http://www.w3.org/2000/01/rdf-schema#Class' ;
X = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property' ;
...
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_reachable/5"><strong>rdf_reachable</strong>(<var>?Subject, 
+Predicate, ?Object, +MaxD, -D</var>)</a></dt>
<dd class="defbody">
Same as <a class="pred" href="#rdf_reachable/3">rdf_reachable/3</a>, but 
in addition, <var>MaxD</var> limits the number of edges expanded and <var>D</var> 
is unified with the&lsquo;distance' between
<var>Subject</var> and <var>Object</var>. Distance 0 means <var>Subject</var> 
and <var>Object</var> are the same resource. <var>MaxD</var> can be the 
constant <code>infinite</code> to impose no distance-limit.
</dd>
</dl>

<p><h4 id="sec:semweb-enumerate"><a id="sec:3.3.2"><span class="sec-nr">3.3.2</span> <span class="sec-title">Enumerating 
objects</span></a></h4>

<p><a id="sec:semweb-enumerate"></a>

<p>The predicates below enumerate the basic objects of the RDF store. 
Most of these predicates also enumerate objects that are not associated 
to any currently visible triple. Objects are retained as long as they 
are visible in active queries or <i>snapshots</i>. After that, some are 
reclaimed by the RDF garbage collector, while others are never 
reclaimed.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_subject/1"><strong>rdf_subject</strong>(<var>?Resource</var>)</a></dt>
<dd class="defbody">
True if <var>Resource</var> appears as a subject. This query respects 
the visibility rules implied by the logical update view.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_resource/1">rdf_resource/1</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_resource/1"><strong>rdf_resource</strong>(<var>?Resource</var>)</a></dt>
<dd class="defbody">
True when <var>Resource</var> is a resource used as a subject or object 
in a triple.

<p>This predicate is primarily intended as a way to process all 
resources without processing resources twice. The user must be aware 
that some of the returned resources may not appear in any
<i>visible</i> triple.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_current_predicate/1"><strong>rdf_current_predicate</strong>(<var>?Predicate</var>)</a></dt>
<dd class="defbody">
True when <var>Predicate</var> is a currently known predicate. 
Predicates are created if a triples is created that uses this predicate 
or a property of the predicate is set using <a class="pred" href="#rdf_set_predicate/2">rdf_set_predicate/2</a>. 
The predicate may (no longer) have triples associated with it.

<p>Note that resources that have <code>rdf:type</code> <code>rdf:Property</code> 
are not automatically included in the result-set of this predicate, 
while <i>all</i> resources that appear as the second argument of a 
triple <i>are</i> included.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_predicate_property/2">rdf_predicate_property/2</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_current_literal/1"><strong>rdf_current_literal</strong>(<var>-Literal</var>)</a></dt>
<dd class="defbody">
True when <var>Literal</var> is a currently known literal. Enumerates 
each unique literal exactly once. Note that it is possible that the 
literal only appears in already deleted triples. Deleted triples may be 
locked due to active queries, transactions or snapshots or may not yet 
be reclaimed by the garbage collector.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_graph/1"><strong>rdf_graph</strong>(<var>?Graph</var>)</a></dt>
<dd class="defbody">
True when <var>Graph</var> is an existing graph.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_current_ns/2"><strong>rdf_current_ns</strong>(<var>:Prefix, 
?URI</var>)</a></dt>
<dd class="defbody">

<dl class="tags">
<dt class="tag">deprecated</dt>
<dd>
Use <a class="pred" href="#rdf_current_prefix/2">rdf_current_prefix/2</a>.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:semweb-modify"><a id="sec:3.3.3"><span class="sec-nr">3.3.3</span> <span class="sec-title">Modifying 
the RDF database</span></a></h4>

<p><a id="sec:semweb-modify"></a>

<p>The predicates below modify the RDF store directly. In addition, data 
may be loaded using <a class="pred" href="#rdf_load/2">rdf_load/2</a> or 
by restoring a persistent database using <a class="pred" href="#rdf_attach_db/2">rdf_attach_db/2</a>. 
Modifications follow the Prolog <i>logical update view</i> semantics, 
which implies that modifications remain invisible to already running 
queries. Further isolation can be achieved using
<a class="pred" href="#rdf_transaction/3">rdf_transaction/3</a>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert/3"><strong>rdf_assert</strong>(<var>+Subject, 
+Predicate, +Object</var>)</a></dt>
<dd class="defbody">
Assert a new triple into the database. This is equivalent to
<a class="pred" href="#rdf_assert/4">rdf_assert/4</a> using Graph <code>user</code>. <var>Subject</var> 
and <var>Predicate</var> are resources. <var>Object</var> is either a 
resource or a term <code>literal(Value)</code>. See <a class="pred" href="#rdf/3">rdf/3</a> 
for an explanation of Value for typed and language qualified literals. 
All arguments are subject to name-space expansion. Complete duplicates 
(including the same graph and&lsquo;line' and with a compatible&lsquo;lifespan') 
are not added to the database.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_assert/4"><strong>rdf_assert</strong>(<var>+Subject, 
+Predicate, +Object, +Graph</var>)</a></dt>
<dd class="defbody">
As <a class="pred" href="#rdf_assert/3">rdf_assert/3</a>, adding the 
predicate to the indicated named graph.
<table class="arglist">
<tr><td><var>Graph</var> </td><td>is either the name of a graph (an 
atom) or a term
<var>Graph</var>:Line, where Line is an integer that denotes a line 
number. </td></tr>
</table>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_retractall/3"><strong>rdf_retractall</strong>(<var>?Subject, 
?Predicate, ?Object</var>)</a></dt>
<dd class="defbody">
Remove all matching triples from the database. As
<a class="pred" href="#rdf_retractall/4">rdf_retractall/4</a> using an 
unbound graph.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_retractall/4"><strong>rdf_retractall</strong>(<var>?Subject, 
?Predicate, ?Object, ?Graph</var>)</a></dt>
<dd class="defbody">
As <a class="pred" href="#rdf_retractall/3">rdf_retractall/3</a>, also 
matching <var>Graph</var>. This is particulary useful to remove all 
triples coming from a loaded file. See also
<a class="pred" href="#rdf_unload/1">rdf_unload/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_update/4"><strong>rdf_update</strong>(<var>+Subject, 
+Predicate, +Object, ++Action</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_update/5"><strong>rdf_update</strong>(<var>+Subject, 
+Predicate, +Object, +Graph, ++Action</var>)</a></dt>
<dd class="defbody">
Replaces one of the three (four) fields on the matching triples 
depending on <var>Action</var>:

<dl class="latex">
<dt><strong>subject</strong>(<var>Resource</var>)</dt>
<dd class="defbody">
Changes the first field of the triple.
</dd>
<dt><strong>predicate</strong>(<var>Resource</var>)</dt>
<dd class="defbody">
Changes the second field of the triple.
</dd>
<dt><strong>object</strong>(<var>Object</var>)</dt>
<dd class="defbody">
Changes the last field of the triple to the given resource or
<code>literal(Value)</code>.
</dd>
<dt><strong>graph</strong>(<var>Graph</var>)</dt>
<dd class="defbody">
Moves the triple from its current named graph to <var>Graph</var>. This 
only works with <a class="pred" href="#rdf_update/5">rdf_update/5</a> 
and throws an error when used with <a class="pred" href="#rdf_update/4">rdf_update/4</a>.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:semweb-update-view"><a id="sec:3.3.4"><span class="sec-nr">3.3.4</span> <span class="sec-title">Update 
view, transactions and snapshots</span></a></h4>

<p><a id="sec:semweb-update-view"></a>

<p>The update semantics of the RDF database follows the conventional 
Prolog
<i>logical update view</i>. In addition, the RDF database supports
<i>transactions</i> and <i>snapshots</i>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_transaction/1"><strong>rdf_transaction</strong>(<var>:Goal</var>)</a></dt>
<dd class="defbody">
Same as <code>rdf_transaction(Goal, user, [])</code>. See <a class="pred" href="#rdf_transaction/3">rdf_transaction/3</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_transaction/2"><strong>rdf_transaction</strong>(<var>:Goal, 
+Id</var>)</a></dt>
<dd class="defbody">
Same as <code>rdf_transaction(Goal, Id, [])</code>. See <a class="pred" href="#rdf_transaction/3">rdf_transaction/3</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_transaction/3"><strong>rdf_transaction</strong>(<var>:Goal, 
+Id, +Options</var>)</a></dt>
<dd class="defbody">
Run <var>Goal</var> in an RDF transaction. Compared to the ACID model, 
RDF transactions have the following properties:

<p>
<ol class="latex">
<li>Modifications inside the transactions become all atomically visible 
to the outside world if <var>Goal</var> succeeds or remain invisible if <var>Goal</var> 
fails or throws an exception. I.e., the <i>atomicy</i> property is fully 
supported.
<li><i>Consistency</i> is not guaranteed. Later versions may implement 
consistency constraints that will be checked serialized just before the 
actual commit of a transaction.
<li>Concurrently executing transactions do not infuence each other. 
I.e., the <i>isolation</i> property is fully supported.
<li><i>Durability</i> can be activated by loading
<code>library(semweb/rdf_persistency)</code>.
</ol>

<p>Processed options are:

<dl class="latex">
<dt><strong>snapshot</strong>(<var>+Snapshot</var>)</dt>
<dd class="defbody">
Execute <var>Goal</var> using the state of the RDF store as stored in
<var>Snapshot</var>. See <a class="pred" href="#rdf_snapshot/1">rdf_snapshot/1</a>. <var>Snapshot</var> 
can also be the atom <code>true</code>, which implies that an anonymous 
snapshot is created at the current state of the store. Modifications due 
to executing <var>Goal</var> are only visible to <var>Goal</var>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_snapshot/1"><strong>rdf_snapshot</strong>(<var>-Snapshot</var>)</a></dt>
<dd class="defbody">
Take a snapshot of the current state of the RDF store. Later, goals may 
be executed in the context of the database at this moment using <a class="pred" href="#rdf_transaction/3">rdf_transaction/3</a> 
with the <code>snapshot</code> option. A snapshot created outside a 
transaction exists until it is deleted. Snapshots taken inside a 
transaction can only be used inside this transaction.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_delete_snapshot/1"><strong>rdf_delete_snapshot</strong>(<var>+Snapshot</var>)</a></dt>
<dd class="defbody">
Delete a snapshot as obtained from <a class="pred" href="#rdf_snapshot/1">rdf_snapshot/1</a>. 
After this call, resources used for maintaining the snapshot become 
subject to garbage collection.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_active_transaction/1"><strong>rdf_active_transaction</strong>(<var>?Id</var>)</a></dt>
<dd class="defbody">
True if <var>Id</var> is the identifier of a transaction in the context 
of which this call is executed. If <var>Id</var> is not instantiated, 
backtracking yields transaction identifiers starting with the innermost 
nested transaction. Transaction identifier terms are not copied, need 
not be ground and can be instantiated during the transaction.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_current_snapshot/1"><strong>rdf_current_snapshot</strong>(<var>?Term</var>)</a></dt>
<dd class="defbody">
True when <var>Term</var> is a currently known snapshot.

<dl class="tags">
<dt class="tag">bug</dt>
<dd>
Enumeration of snapshots is slow.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:semweb-typecheck"><a id="sec:3.3.5"><span class="sec-nr">3.3.5</span> <span class="sec-title">Type 
checking predicates</span></a></h4>

<p><a id="sec:semweb-typecheck"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_resource/1"><strong>rdf_is_resource</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> is an RDF resource. Note that this is merely a 
type-test; it does not mean this resource is involved in any triple. 
Blank nodes are also considered resources.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_is_bnode/1">rdf_is_bnode/1</a>
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_is_bnode/1"><strong>rdf_is_bnode</strong>(<var>+Id</var>)</a></dt>
<dd class="defbody">
Tests if a resource is a blank node (i.e. is an anonymous resource). A 
blank node is represented as an atom that starts with <code>_:</code>. 
For backward compatibility reason, <code>__</code> is also considered to 
be a blank node.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_bnode/1">rdf_bnode/1</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_is_literal/1"><strong>rdf_is_literal</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> is an RDF literal object. Currently only checks 
for groundness and the literal functor.
</dd>
</dl>

<p><h4 id="sec:semweb-load-save"><a id="sec:3.3.6"><span class="sec-nr">3.3.6</span> <span class="sec-title">Loading 
and saving to file</span></a></h4>

<p><a id="sec:semweb-load-save"></a>

<p>The RDF library can read and write triples in RDF/XML and a 
proprietary binary format. There is a plugin interface defined to 
support additional formats. The <code>library(semweb/turtle)</code> uses 
this plugin API to support loading Turtle files using <a class="pred" href="#rdf_load/2">rdf_load/2</a>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_load/1"><strong>rdf_load</strong>(<var>+FileOrList</var>)</a></dt>
<dd class="defbody">
Same as <code>rdf_load(FileOrList, [])</code>. See <a class="pred" href="#rdf_load/2">rdf_load/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_load/2"><strong>rdf_load</strong>(<var>+FileOrList, 
:Options</var>)</a></dt>
<dd class="defbody">
Load RDF data. <var>Options</var> provides additional processing 
options. Defined options are:

<dl class="latex">
<dt><strong>blank_nodes</strong>(<var>+ShareMode</var>)</dt>
<dd class="defbody">
How to handle equivalent blank nodes. If <code>share</code> (default), 
equivalent blank nodes are shared in the same resource.
</dd>
<dt><strong>base_uri</strong>(<var>+URI</var>)</dt>
<dd class="defbody">
<var>URI</var> that is used for rdf:about="" and other RDF constructs 
that are relative to the base uri. Default is the source URL.
</dd>
<dt><strong>concurrent</strong>(<var>+Jobs</var>)</dt>
<dd class="defbody">
If <var>FileOrList</var> is a list of files, process the input files 
using <var>Jobs</var> threads concurrently. Default is the mininum of 
the number of cores and the number of inputs. Higher values can be 
useful when loading inputs from (slow) network connections. Using 1 
(one) does not use separate worker threads.
</dd>
<dt><strong>format</strong>(<var>+Format</var>)</dt>
<dd class="defbody">
Specify the source format explicitly. Normally this is deduced from the 
filename extension or the mime-type. The core library understands the 
formats xml (RDF/XML) and triples (internal quick load and cache 
format). Plugins, such as <code>library(semweb/turtle)</code> extend the 
set of recognised extensions.
</dd>
<dt><strong>graph</strong>(<var>?Graph</var>)</dt>
<dd class="defbody">
Named graph in which to load the data. It is <b>not</b> allowed to load 
two sources into the same named graph. If <var>Graph</var> is unbound, 
it is unified to the graph into which the data is loaded. The default 
graph is a <code>file://</code> URL when loading a file or, if the 
specification is a URL, its normalized version without the optional <i>#fragment</i>.
</dd>
<dt><strong>if</strong>(<var>Condition</var>)</dt>
<dd class="defbody">
When to load the file. One of <code>true</code>, <code>changed</code> 
(default) or
<code>not_loaded</code>.
</dd>
<dt><strong>modified</strong>(<var>-Modified</var>)</dt>
<dd class="defbody">
Unify <var>Modified</var> with one of <code>not_modified</code>, <code>cached(File)</code>,
<code>last_modified(Stamp)</code> or <code>unknown</code>.
</dd>
<dt><strong>cache</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>false</code>, do not use or create a cache file.
</dd>
<dt><strong>register_namespaces</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), register <code>xmlns</code> 
namespace declarations or Turtle <code>@prefix</code> prefixes using
<a class="pred" href="#rdf_register_prefix/3">rdf_register_prefix/3</a> 
if there is no conflict.
</dd>
<dt><strong>silent</strong>(<var>+Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, the message reporting completion is printed using 
level <code>silent</code>. Otherwise the level is <code>informational</code>. 
See also <span class="pred-ext">print_message/2</span>.
</dd>
<dt><strong>prefixes</strong>(<var>-Prefixes</var>)</dt>
<dd class="defbody">
Returns the prefixes defined in the source data file as a list of pairs.
</dd>
<dt><strong>multifile</strong> <var><code><var>Boolean</var>+</code></var></dt>
<dd class="defbody">
Indicate that the addressed graph may be populated with triples from 
multiple sources. This disables caching and avoids that an <a class="pred" href="#rdf_load/2">rdf_load/2</a> 
call affecting the specified graph cleans the graph.
</dd>
</dl>

<p>Other options are forwarded to <span class="pred-ext">process_rdf/3</span>. 
By default,
<a class="pred" href="#rdf_load/2">rdf_load/2</a> only loads RDF/XML 
from files. It can be extended to load data from other formats and 
locations using plugins. The full set of plugins relevant to support 
different formats and locations is below:

<pre class="code">
:- use_module(library(semweb/turtle)).        % Turtle and TriG
:- use_module(library(semweb/rdf_ntriples)).
:- use_module(library(semweb/rdf_zlib_plugin)).
:- use_module(library(semweb/rdf_http_plugin)).
:- use_module(library(http/http_ssl_plugin)).
</pre>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_db:rdf_open_hook/3">rdf_db:rdf_open_hook/3</a>, <code>library(semweb/rdf_persistency)</code> 
and
<code>library(semweb/rdf_cache)</code>
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_unload/1"><strong>rdf_unload</strong>(<var>+Source</var>)</a></dt>
<dd class="defbody">
Identify the graph loaded from <var>Source</var> and use <a class="pred" href="#rdf_unload_graph/1">rdf_unload_graph/1</a> 
to erase this graph.

<dl class="tags">
<dt class="tag">deprecated</dt>
<dd>
For compatibility, this predicate also accepts a graph name instead of a 
source specification. Please update your code to use
<a class="pred" href="#rdf_unload_graph/1">rdf_unload_graph/1</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save/1"><strong>rdf_save</strong>(<var>+Out</var>)</a></dt>
<dd class="defbody">
Same as <code>rdf_save(Out, [])</code>. See <a class="pred" href="#rdf_save/2">rdf_save/2</a> 
for details.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save/2"><strong>rdf_save</strong>(<var>+Out, 
:Options</var>)</a></dt>
<dd class="defbody">
Write RDF data as RDF/XML. <var>Options</var> is a list of one or more 
of the following options:

<dl class="latex">
<dt><strong>graph</strong>(<var>+Graph</var>)</dt>
<dd class="defbody">
Save only triples associated to the given named <var>Graph</var>.
</dd>
<dt><strong>anon</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>false</code> (default <code>true</code>) do not save blank 
nodes that do not appear (indirectly) as object of a named resource.
</dd>
<dt><strong>base_uri</strong>(<var>URI</var>)</dt>
<dd class="defbody">
BaseURI used. If present, all URIs that can be represented relative to 
this base are written using their shorthand. See also <code>write_xml_base</code> 
option.
</dd>
<dt><strong>convert_typed_literal</strong>(<var>:Convertor</var>)</dt>
<dd class="defbody">
Call <var>Convertor</var>(-Type, -Content, +RDFObject), providing the 
opposite for the convert_typed_literal option of the RDF parser.
</dd>
<dt><strong>document_language</strong>(<var>+Lang</var>)</dt>
<dd class="defbody">
Initial <code>xml:lang</code> saved with rdf:RDF element.
</dd>
<dt><strong>encoding</strong>(<var>Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> for the output. Either utf8 or iso_latin_1.
</dd>
<dt><strong>inline</strong>(<var>+Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), inline resources when 
encountered for the first time. Normally, only bnodes are handled this 
way.
</dd>
<dt><strong>namespaces</strong>(<var>+List</var>)</dt>
<dd class="defbody">
Explicitly specify saved namespace declarations. See
<a class="pred" href="#rdf_save_header/2">rdf_save_header/2</a> option 
namespaces for details.
</dd>
<dt><strong>sorted</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), emit subjects sorted 
on the full URI. Useful to make file comparison easier.
</dd>
<dt><strong>write_xml_base</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>false</code>, do <i>not</i> include the <code>xml:base</code> 
declaration that is written normally when using the
<code>base_uri</code> option.
</dd>
<dt><strong>xml_attributes</strong>(<var>+Bool</var>)</dt>
<dd class="defbody">
If <code>false</code> (default <code>true</code>), never use xml 
attributes to save plain literal attributes, i.e., always used an XML 
element as in <code>&lt;name&gt;Joe&lt;/name&gt;</code>.
</dd>
</dl>

<table class="arglist">
<tr><td><var>Out</var> </td><td>Location to save the data. This can also 
be a file-url (<code>file://path</code>) or a stream wrapped in a term <code>stream(Out)</code>. </td></tr>
</table>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_save_db/1">rdf_save_db/1</a>
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_make/0"><strong>rdf_make</strong></a></dt>
<dd class="defbody">
Reload all loaded files that have been modified since the last time they 
were loaded.
</dd>
</dl>

<p><b>Partial save</b> <a id="sec:semweb-partial-save"></a>

<p>Sometimes it is necessary to make more arbitrary selections of 
material to be saved or exchange RDF descriptions over an open network 
link. The predicates in this section provide for this. Character 
encoding issues are derived from the encoding of the <i>Stream</i>, 
providing support for
<code>utf8</code>, <code>iso_latin_1</code> and <code>ascii</code>.

<dl class="latex">
<dt class="pubdef"><a id="rdf_save_header/2"><strong>rdf_save_header</strong>(<var>+Fd, 
+Options</var>)</a></dt>
<dd class="defbody">
Save XML document header, doctype and open the RDF environment. This 
predicate also sets up the namespace notation.

<p>Save an RDF header, with the XML header, DOCTYPE, ENTITY and opening 
the rdf:RDF element with appropriate namespace declarations. It uses the 
primitives from section 3.5 to generate the required namespaces and 
desired short-name. <var>Options</var> is one of:

<dl class="latex">
<dt><strong>graph</strong>(<var>+URI</var>)</dt>
<dd class="defbody">
Only search for namespaces used in triples that belong to the given 
named graph.
</dd>
<dt><strong>namespaces</strong>(<var>+List</var>)</dt>
<dd class="defbody">
Where <var>List</var> is a list of namespace abbreviations. With this 
option, the expensive search for all namespaces that may be used by your 
data is omitted. The namespaces <code>rdf</code> and <code>rdfs</code> 
are added to the provided <var>List</var>. If a namespace is not 
declared, the resource is emitted in non-abreviated form.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_footer/1"><strong>rdf_save_footer</strong>(<var>Out:stream</var>)</a></dt>
<dd class="defbody">
Finish XML generation and write the document footer.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_save_header/2">rdf_save_header/2</a>, <a class="pred" href="#rdf_save_subject/3">rdf_save_subject/3</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_subject/3"><strong>rdf_save_subject</strong>(<var>+Out, 
+Subject:resource, +Options</var>)</a></dt>
<dd class="defbody">
Save the triples associated to <var>Subject</var> to <var>Out</var>. <var>Options</var>:

<dl class="latex">
<dt><strong>graph</strong>(<var>+Graph</var>)</dt>
<dd class="defbody">
Only save properties from <var>Graph</var>.
</dd>
<dt><strong>base_uri</strong>(<var>+URI</var>)</dt>
<dt><strong>convert_typed_literal</strong>(<var>:Goal</var>)</dt>
<dt><strong>document_language</strong>(<var>+XMLLang</var>)</dt>
<dd class="defbody">
</dd>
</dl>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_save/2">rdf_save/2</a> for a description of 
these options.
</dd>
</dl>

</dd>
</dl>

<p><b>Fast loading and saving</b> <a id="sec:semweb-fast-load-save"></a>

<p>Loading and saving RDF format is relatively slow. For this reason we 
designed a binary format that is more compact, avoids the complications 
of the RDF parser and avoids repetitive lookup of (URL) identifiers. 
Especially the speed improvement of about 25 times is worth-while when 
loading large databases. These predicates are used for caching by
<a class="pred" href="#rdf_load/2">rdf_load/2</a> under certain 
conditions as well as for maintaining persistent snapshots of the 
database using
<code>library(semweb/rdf_persistency)</code>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_db/1"><strong>rdf_save_db</strong>(<var>+File</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_db/2"><strong>rdf_save_db</strong>(<var>+File, 
+Graph</var>)</a></dt>
<dd class="defbody">
Save triples into <var>File</var> in a quick-to-load binary format. If <var>Graph</var> 
is supplied only triples flagged to originate from that database are 
added. Files created this way can be loaded using
<a class="pred" href="#rdf_load_db/1">rdf_load_db/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_load_db/1"><strong>rdf_load_db</strong>(<var>+File</var>)</a></dt>
<dd class="defbody">
Load triples from a file created using <a class="pred" href="#rdf_save_db/2">rdf_save_db/2</a>.
</dd>
</dl>

<p><h4 id="sec:semweb-graphs"><a id="sec:3.3.7"><span class="sec-nr">3.3.7</span> <span class="sec-title">Graph 
manipulation</span></a></h4>

<p><a id="sec:semweb-graphs"></a>

<p>Many RDF stores turned triples into quadruples. This store is no 
exception, initially using the 4th argument to store the filename from 
which the triple was loaded. Currently, the 4th argument is the RDF
<i>named graph</i>. A named graph maintains some properties, notably to 
track origin, changes and modified state.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_create_graph/1"><strong>rdf_create_graph</strong>(<var>+Graph</var>)</a></dt>
<dd class="defbody">
Create an RDF graph without triples. Succeeds silently if the graph 
already exists.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_unload_graph/1"><strong>rdf_unload_graph</strong>(<var>+Graph</var>)</a></dt>
<dd class="defbody">
Remove <var>Graph</var> from the RDF store. Succeeds silently if the 
named graph does not exist.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_graph_property/2"><strong>rdf_graph_property</strong>(<var>?Graph, 
?Property</var>)</a></dt>
<dd class="defbody">
True when <var>Property</var> is a property of <var>Graph</var>. Defined 
properties are:

<dl class="latex">
<dt><strong>hash</strong>(<var>Hash</var>)</dt>
<dd class="defbody">
<var>Hash</var> is the (MD5-)hash for the content of <var>Graph</var>.
</dd>
<dt><strong>modified</strong>(<var>Boolean</var>)</dt>
<dd class="defbody">
True if the graph is modified since it was loaded or
<a class="pred" href="#rdf_set_graph/2">rdf_set_graph/2</a> was called 
with <code>modified(false)</code>.
</dd>
<dt><strong>source</strong>(<var>Source</var>)</dt>
<dd class="defbody">
The graph is loaded from the <var>Source</var> (a URL)
</dd>
<dt><strong>source_last_modified</strong>(<var>?Time</var>)</dt>
<dd class="defbody">
<var>Time</var> is the last-modified timestamp of Source at the moment 
the graph was loaded from Source.
</dd>
<dt><strong>triples</strong>(<var>Count</var>)</dt>
<dd class="defbody">
True when <var>Count</var> is the number of triples in <var>Graph</var>.
</dd>
</dl>

<p>Additional graph properties can be added by defining rules for the 
multifile predicate <span class="pred-ext">property_of_graph/2</span>. 
Currently, the following extensions are defined:

<p>
<ul class="latex">
<li><code>library(semweb/rdf_persistency)</code>

<dl class="latex">
<dt><strong>persistent</strong>(<var>Boolean</var>)</dt>
<dd class="defbody">
<var>Boolean</var> is <code>true</code> if the graph is persistent.
</dd>
</dl>

</ul>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_set_graph/2"><strong>rdf_set_graph</strong>(<var>+Graph, 
+Property</var>)</a></dt>
<dd class="defbody">
Set properties of <var>Graph</var>. Defined properties are:

<dl class="latex">
<dt><strong>modified</strong>(<var>false</var>)</dt>
<dd class="defbody">
Set the modified state of <var>Graph</var> to false.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:semweb-literals"><a id="sec:3.3.8"><span class="sec-nr">3.3.8</span> <span class="sec-title">Literal 
matching and indexing</span></a></h4>

<p><a id="sec:semweb-literals"></a>

<p>Literal values are ordered and indexed using a <i>skip list</i>. The 
aim of this index is threefold.

<p>
<ul class="latex">
<li>Unlike hash-tables, binary trees allow for efficient
<i>prefix</i> and <i>range</i> matching. Prefix matching is useful in 
interactive applications to provide feedback while typing such as 
auto-completion.
<li>Having a table of unique literals we generate creation and 
destruction events (see <a class="pred" href="#rdf_monitor/2">rdf_monitor/2</a>). 
These events can be used to maintain additional indexing on literals, 
such as&lsquo;by word'. See <code>library(semweb/litindex)</code>.
</ul>

<p>As string literal matching is most frequently used for searching 
purposes, the match is executed case-insensitive and after removal of 
diacritics. Case matching and diacritics removal is based on Unicode 
character properties and independent from the current locale. Case 
conversion is based on the&lsquo;simple uppercase mapping' defined by 
Unicode and diacritic removal on the&lsquo;decomposition type'. The 
approach is lightweight, but somewhat simpleminded for some languages. 
The tables are generated for Unicode characters upto 0x7fff. For more 
information, please check the source-code of the mapping-table generator
<code>unicode_map.pl</code> available in the sources of this package.

<p>Currently the total order of literals is first based on the type of 
literal using the ordering <i>numeric <var>&lt;</var> string <var>&lt;</var> 
term</i> Numeric values (integer and float) are ordered by value, 
integers preceed floats if they represent the same value. Strings are 
sorted alphabetically after case-mapping and diacritic removal as 
described above. If they match equal, uppercase preceeds lowercase and 
diacritics are ordered on their unicode value. If they still compare 
equal literals without any qualifier preceeds literals with a type 
qualifier which preceeds literals with a language qualifier. Same 
qualifiers (both type or both language) are sorted alphabetically.

<p>The ordered tree is used for indexed execution of
<code>literal(prefix(Prefix), Literal)</code> as well as <code>literal(like(Like), Literal)</code> 
if <i>Like</i> does not start with a&lsquo;*'. Note that results of 
queries that use the tree index are returned in alphabetical order.

<p><h4 id="sec:semweb-predicates"><a id="sec:3.3.9"><span class="sec-nr">3.3.9</span> <span class="sec-title">Predicate 
properties</span></a></h4>

<p><a id="sec:semweb-predicates"></a>

<p>The predicates below form an experimental interface to provide more 
reasoning inside the kernel of the rdb_db engine. Note that <code>symetric</code>,
<code>inverse_of</code> and <code>transitive</code> are not yet 
supported by the rest of the engine. Also note that there is no relation 
to defined RDF properties. Properties that have no triples are not 
reported by this predicate, while predicates that are involved in 
triples do not need to be defined as an instance of rdf:Property.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_set_predicate/2"><strong>rdf_set_predicate</strong>(<var>+Predicate, 
+Property</var>)</a></dt>
<dd class="defbody">
Define a property of the predicate. This predicate currently supports 
the following properties:

<dl class="latex">
<dt><strong>symmetric</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
Set/unset the predicate as being symmetric. Using
<code>symmetric(true)</code> is the same as <code>inverse_of(Predicate)</code>, 
i.e., creating a predicate that is the inverse of itself.
</dd>
<dt><strong>transitive</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
Sets the transitive property.
</dd>
<dt><strong>inverse_of</strong>(<var>+Predicate2</var>)</dt>
<dd class="defbody">
Define <var>Predicate</var> as the inverse of <var>Predicate2</var>. An 
inverse relation is deleted using <code>inverse_of([])</code>.
</dd>
</dl>

<p>The <code>transitive</code> property is currently not used. The <code>symmetric</code> 
and <code>inverse_of</code> properties are considered by <a class="pred" href="#rdf_has/3">rdf_has/3</a>,4 
and
<a class="pred" href="#rdf_reachable/3">rdf_reachable/3</a>.

<dl class="tags">
<dt class="tag">To be done</dt>
<dd>
Maintain these properties based on OWL triples.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_predicate_property/2"><strong>rdf_predicate_property</strong>(<var>?Predicate, 
?Property</var>)</a></dt>
<dd class="defbody">
Query properties of a defined predicate. Currently defined properties 
are given below.

<dl class="latex">
<dt><strong>symmetric</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
True if the predicate is defined to be symetric. I.e., {A} P
{B} implies {B} P {A}. Setting symmetric is equivalent to
<code>inverse_of(Self)</code>.
</dd>
<dt><strong>inverse_of</strong>(<var>Inverse</var>)</dt>
<dd class="defbody">
True if this predicate is the inverse of <var>Inverse</var>. This 
property is used by <a class="pred" href="#rdf_has/3">rdf_has/3</a>, <a class="pred" href="#rdf_has/4">rdf_has/4</a>, <a class="pred" href="#rdf_reachable/3">rdf_reachable/3</a> 
and
<a class="pred" href="#rdf_reachable/5">rdf_reachable/5</a>.
</dd>
<dt><strong>transitive</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
True if this predicate is transitive. This predicate is currently not 
used. It might be used to make <a class="pred" href="#rdf_has/3">rdf_has/3</a> 
imply
<a class="pred" href="#rdf_reachable/3">rdf_reachable/3</a> for 
transitive predicates.
</dd>
<dt><strong>triples</strong>(<var>Triples</var>)</dt>
<dd class="defbody">
Unify <var>Triples</var> with the number of existing triples using this 
predicate as second argument. Reporting the number of triples is 
intended to support query optimization.
</dd>
<dt><strong>rdf_subject_branch_factor</strong>(<var>-Float</var>)</dt>
<dd class="defbody">
Unify <var>Float</var> with the average number of triples associated 
with each unique value for the subject-side of this relation. If there 
are no triples the value 0.0 is returned. This value is cached with the 
predicate and recomputed only after substantial changes to the triple 
set associated to this relation. This property is intended for path 
optimalisation when solving conjunctions of <a class="pred" href="#rdf/3">rdf/3</a> 
goals.
</dd>
<dt><strong>rdf_object_branch_factor</strong>(<var>-Float</var>)</dt>
<dd class="defbody">
Unify <var>Float</var> with the average number of triples associated 
with each unique value for the object-side of this relation. In addition 
to the comments with the <code>rdf_subject_branch_factor</code> 
property, uniqueness of the object value is computed from the hash key 
rather than the actual values.
</dd>
<dt><strong>rdfs_subject_branch_factor</strong>(<var>-Float</var>)</dt>
<dd class="defbody">
Same as <code>rdf_subject_branch_factor</code>, but also considering 
triples of&lsquo;subPropertyOf' this relation. See also <a class="pred" href="#rdf_has/3">rdf_has/3</a>.
</dd>
<dt><strong>rdfs_object_branch_factor</strong>(<var>-Float</var>)</dt>
<dd class="defbody">
Same as <code>rdf_object_branch_factor</code>, but also considering 
triples of&lsquo;subPropertyOf' this relation. See also <a class="pred" href="#rdf_has/3">rdf_has/3</a>.
</dd>
</dl>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#rdf_set_predicate/2">rdf_set_predicate/2</a>.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:semweb-prefixes"><a id="sec:3.3.10"><span class="sec-nr">3.3.10</span> <span class="sec-title">Prefix 
Handling</span></a></h4>

<p><a id="sec:semweb-prefixes"></a>

<p>Prolog code often contains references to constant resources with a 
known
<i>prefix</i> (also known as XML <i>namespaces</i>). For example,
<code>http://www.w3.org/2000/01/rdf-schema#Class</code> refers to the 
most general notion of an RDFS class. Readability and maintability 
concerns require for abstraction here. The RDF database maintains a 
table of known <i>prefixes</i>. This table can be queried using <a class="pred" href="#rdf_current_ns/2">rdf_current_ns/2</a> 
and can be extended using <span class="pred-ext">rdf_register_ns/3</span>. 
The prefix database is used to expand <code>prefix:local</code> terms 
that appear as arguments to calls which are known to accept a <i>resource</i>. 
This expansion is achieved by Prolog preprocessor using <span class="pred-ext">expand_goal/2</span>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_current_prefix/2"><strong>rdf_current_prefix</strong>(<var>:Alias, 
?URI</var>)</a></dt>
<dd class="defbody">
Query predefined prefixes and prefixes defined with
<a class="pred" href="#rdf_register_prefix/2">rdf_register_prefix/2</a> 
and local prefixes defined with
<span class="pred-ext">rdf_prefix/2</span>. If <var>Alias</var> is 
unbound and one <var>URI</var> is the prefix of another, the longest is 
returned first. This allows turning a resource into a prefix/local 
couple using the simple enumeration below. See <a class="pred" href="#rdf_global_id/2">rdf_global_id/2</a>.

<pre class="code">
rdf_current_prefix(Prefix, Expansion),
atom_concat(Expansion, Local, URI),
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_register_prefix/2"><strong>rdf_register_prefix</strong>(<var>+Prefix, 
+URI</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_register_prefix/3"><strong>rdf_register_prefix</strong>(<var>+Prefix, 
+URI, +Options</var>)</a></dt>
<dd class="defbody">
Register <var>Prefix</var> as an abbreviation for <var>URI</var>. <var>Options</var>:

<dl class="latex">
<dt><strong>force</strong>(<var>Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code>, replace existing namespace alias. Please note that 
replacing a namespace is dangerous as namespaces affect preprocessing. 
Make sure all code that depends on a namespace is compiled after 
changing the registration.
</dd>
<dt><strong>keep</strong>(<var>Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> and Alias is already defined, keep the original 
binding for <var>Prefix</var> and succeed silently.
</dd>
</dl>

<p>Without options, an attempt to redefine an alias raises a permission 
error.

<p>Predefined prefixes are:
<blockquote>
<table class="latex frame-box">
<tr><td><b>Alias</b> </td><td><b>IRI prefix</b> </td></tr>
<tr><td>dc</td><td><a class="url" href="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</a> </td></tr>
<tr><td>dcterms</td><td><a class="url" href="http://purl.org/dc/terms/">http://purl.org/dc/terms/</a> </td></tr>
<tr><td>eor</td><td><a class="url" href="http://dublincore.org/2000/03/13/eor#">http://dublincore.org/2000/03/13/eor#</a> </td></tr>
<tr><td>foaf</td><td><a class="url" href="http://xmlns.com/foaf/0.1/">http://xmlns.com/foaf/0.1/</a> </td></tr>
<tr><td>owl</td><td><a class="url" href="http://www.w3.org/2002/07/owl#">http://www.w3.org/2002/07/owl#</a> </td></tr>
<tr><td>rdf</td><td><a class="url" href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a> </td></tr>
<tr><td>rdfs</td><td><a class="url" href="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a> </td></tr>
<tr><td>serql</td><td><a class="url" href="http://www.openrdf.org/schema/serql#">http://www.openrdf.org/schema/serql#</a> </td></tr>
<tr><td>skos</td><td><a class="url" href="http://www.w3.org/2004/02/skos/core#">http://www.w3.org/2004/02/skos/core#</a> </td></tr>
<tr><td>void</td><td><a class="url" href="http://rdfs.org/ns/void#">http://rdfs.org/ns/void#</a> </td></tr>
<tr><td>xsd</td><td><a class="url" href="http://www.w3.org/2001/XMLSchema#">http://www.w3.org/2001/XMLSchema#</a> </td></tr>
</table>
</blockquote>
</dd>
</dl>

<p><i>Explicit</i> expansion is achieved using the predicates below. The 
predicate <a class="pred" href="#rdf_equal/2">rdf_equal/2</a> performs 
this expansion at compile time, while the other predicates do it at 
runtime.

<dl class="latex">
<dt class="pubdef"><a id="rdf_equal/2"><strong>rdf_equal</strong>(<var>?Resource1, 
?Resource2</var>)</a></dt>
<dd class="defbody">
Simple equality test to exploit goal-expansion.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_global_id/2"><strong>rdf_global_id</strong>(<var>?IRISpec, 
:IRI</var>)</a></dt>
<dd class="defbody">
Convert between Prefix:Local and full <var>IRI</var> (an atom). If <var>IRISpec</var> 
is an atom, it is simply unified with <var>IRI</var>. This predicate 
fails silently if <var>IRI</var> is an RDF literal.

<p>Note that this predicate is a meta-predicate on its output argument. 
This is necessary to get the module context while the first argument may 
be of the form (:)/2. The above mode description is correct, but should 
be interpreted as (?,?).

<dl class="tags">
<dt class="tag">Errors</dt>
<dd>
<code>existence_error(rdf_prefix, Prefix)</code></dd>
<dt class="mtag">See also</dt>
<dd>
- <a class="pred" href="#rdf_equal/2">rdf_equal/2</a> provides a compile 
time alternative <br>
- The <span class="pred-ext">rdf_meta/1</span> directive asks for 
compile time expansion of arguments.
</dd>
<dt class="tag">bug</dt>
<dd>
Error handling is incomplete. In its current implementation the same 
code is used for compile-time expansion and to facilitate runtime 
conversion and checking. These use cases have different requirements.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_global_object/2"><strong>rdf_global_object</strong>(<var>+Object, 
:GlobalObject</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_global_object/2"><strong>rdf_global_object</strong>(<var>-Object, 
:GlobalObject</var>)</a></dt>
<dd class="defbody">
Same as <a class="pred" href="#rdf_global_id/2">rdf_global_id/2</a>, but 
intended for dealing with the object part of a triple, in particular the 
type for typed literals. Note that the predicate is a meta-predicate on 
the output argument. This is necessary to get the module context while 
the first argument may be of the form (:)/2.

<dl class="tags">
<dt class="tag">Errors</dt>
<dd>
<code>existence_error(rdf_prefix, Prefix)</code>
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_global_term/2"><strong>rdf_global_term</strong>(<var>+TermIn, 
:GlobalTerm</var>)</a></dt>
<dd class="defbody">
Performs <a class="pred" href="#rdf_global_id/2">rdf_global_id/2</a> on 
predixed IRIs and <a class="pred" href="#rdf_global_object/2">rdf_global_object/2</a> 
on RDF literals, by recursively analysing the term. Note that the 
predicate is a meta-predicate on the output argument. This is necessary 
to get the module context while the first argument may be of the form 
(:)/2.

<p>Terms of the form <code>Prefix:Local</code> that appear in <var>TermIn</var> 
for which
<var>Prefix</var> is not defined are not replaced. Unlike <a class="pred" href="#rdf_global_id/2">rdf_global_id/2</a> 
and
<a class="pred" href="#rdf_global_object/2">rdf_global_object/2</a>, no 
error is raised.
</dd>
</dl>

<p><b>Namespace handling for custom predicates</b> <a id="sec:semweb-meta"></a>

<p>If we implement a new predicate based on one of the predicates of the 
semweb libraries that expands namespaces, namespace expansion is not 
automatically available to it. Consider the following code computing the 
number of distinct objects for a certain property on a certain object.

<pre class="code">
cardinality(S, P, C) :-
      (   setof(O, rdf_has(S, P, O), Os)
      -&gt;  length(Os, C)
      ;   C = 0
      ).
</pre>

<p>Now assume we want to write <span class="pred-ext">labels/2</span> 
that returns the number of distict labels of a resource:

<pre class="code">
labels(S, C) :-
      cardinality(S, rdfs:label, C).
</pre>

<p>This code will <i>not</i> work because <code>rdfs:label</code> is not 
expanded at compile time. To make this work, we need to add an <span class="pred-ext">rdf_meta/1</span> 
declaration.

<pre class="code">
:- rdf_meta
      cardinality(r,r,-).
</pre>

<p>
<ul class="compact">
<li><i>[<span class="pred-ext">rdf_meta/1</span>]</i><br>
</ul>

<p>The example below defines the rule <span class="pred-ext">concept/1</span>.

<pre class="code">
:- use_module(library(semweb/rdf_db)).  % for rdf_meta
:- use_module(library(semweb/rdfs)).    % for rdfs_individual_of

:- rdf_meta
        concept(r).

%%      concept(?C) is nondet.
%
%       True if C is a concept.

concept(C) :-
        rdfs_individual_of(C, skos:'Concept').
</pre>

<p>In addition to expanding <i>calls</i>, <span class="pred-ext">rdf_meta/1</span> 
also causes expansion of
<i>clause heads</i> for predicates that match a declaration. This is 
typically used write Prolog statements about resources. The following 
example produces three clauses with expanded (single-atom) arguments:

<pre class="code">
:- use_module(library(semweb/rdf_db)).

:- rdf_meta
        label_predicate(r).

label_predicate(rdfs:label).
label_predicate(skos:prefLabel).
label_predicate(skos:altLabel).
</pre>

<p><h4 id="sec:semweb-misc"><a id="sec:3.3.11"><span class="sec-nr">3.3.11</span> <span class="sec-title">Miscellaneous 
predicates</span></a></h4>

<p><a id="sec:semweb-misc"></a>

<p>This section describes the remaining predicates of the
<code>library(semweb/rdf_db)</code> module.

<dl class="latex">
<dt class="pubdef"><a id="rdf_bnode/1"><strong>rdf_bnode</strong>(<var>-Id</var>)</a></dt>
<dd class="defbody">
Generate a unique anonymous identifier for a subject.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_source_location/2"><strong>rdf_source_location</strong>(<var>+Subject, 
-Location</var>)</a></dt>
<dd class="defbody">
True when triples for <var>Subject</var> are loaded from <var>Location</var>.
<table class="arglist">
<tr><td><var>Location</var> </td><td>is a term File:Line. </td></tr>
</table>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_generation/1"><strong>rdf_generation</strong>(<var>-Generation</var>)</a></dt>
<dd class="defbody">
True when <var>Generation</var> is the current generation of the 
database. Each modification to the database increments the generation. 
It can be used to check the validity of cached results deduced from the 
database. Committing a non-empty transaction increments the generation 
by one.

<p>When inside a transaction, <var>Generation</var> is unified to a term
<i>TransactionStartGen</i> + <i>InsideTransactionGen</i>. E.g., 4+3 
means that the transaction was started at generation 4 of the global 
database and we have created 3 new generations inside the transaction. 
Note that this choice of representation allows for comparing generations 
using Prolog arithmetic. Comparing a generation in one transaction with 
a generation in another transaction is meaningless.</dd>
<dt class="pubdef"><a id="rdf_estimate_complexity/4"><strong>rdf_estimate_complexity</strong>(<var>?Subject, 
?Predicate, ?Object, -Complexity</var>)</a></dt>
<dd class="defbody">
Return the number of alternatives as indicated by the database internal 
hashed indexing. This is a rough measure for the number of alternatives 
we can expect for an <a class="pred" href="#rdf_has/3">rdf_has/3</a> 
call using the given three arguments. When called with three variables, 
the total number of triples is returned. This estimate is used in query 
optimisation. See also <a class="pred" href="#rdf_predicate_property/2">rdf_predicate_property/2</a> 
and
<a class="pred" href="#rdf_statistics/1">rdf_statistics/1</a> for 
additional information to help optimizers.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="rdf_statistics/1"><strong>rdf_statistics</strong>(<var>?KeyValue</var>)</a></dt>
<dd class="defbody">
Obtain statistics on the RDF database. Defined statistics are:

<dl class="latex">
<dt><strong>graphs</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of named graphs.
</dd>
<dt><strong>triples</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Total number of triples in the database. This is the number of asserted 
triples minus the number of retracted ones. The number of <i>visible</i> 
triples in a particular context may be different due to visibility rules 
defined by the logical update view and transaction isolation.
</dd>
<dt><strong>resources</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of resources that appear as subject or object in a triple. See <a class="pred" href="#rdf_resource/1">rdf_resource/1</a>.
</dd>
<dt><strong>properties</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of current predicates. See <a class="pred" href="#rdf_current_predicate/1">rdf_current_predicate/1</a>.
</dd>
<dt><strong>literals</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of current literals. See <a class="pred" href="#rdf_current_literal/1">rdf_current_literal/1</a>.
</dd>
<dt><strong>gc</strong>(<var>GCCount, ReclaimedTriples, 
ReindexedTriples, Time</var>)</dt>
<dd class="defbody">
Information about the garbage collector.
</dd>
<dt><strong>searched_nodes</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of nodes expanded by <a class="pred" href="#rdf_reachable/3">rdf_reachable/3</a> 
and
<a class="pred" href="#rdf_reachable/5">rdf_reachable/5</a>.
</dd>
<dt><strong>lookup</strong>(<var>rdf(S,P,O,G), Count</var>)</dt>
<dd class="defbody">
Number of queries that have been performed for this particular 
instantiation pattern. Each of <var>S</var>,<var>P</var>,<var>O</var>,<var>G</var> 
is either + or -. Fails in case the number of performed queries is zero.
</dd>
<dt><strong>hash_quality</strong>(<var>rdf(S,P,O,G), Buckets, Quality, 
PendingResize</var>)</dt>
<dd class="defbody">
Statistics on the index for this pattern. Indices are created lazily on 
the first relevant query.
</dd>
<dt><strong>triples_by_graph</strong>(<var>Graph, Count</var>)</dt>
<dd class="defbody">
This statistics is produced for each named graph. See
<code>triples</code> for the interpretation of this value.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_match_label/3"><strong>rdf_match_label</strong>(<var>+How, 
+Pattern, +Label</var>)</a></dt>
<dd class="defbody">
True if <var>Label</var> matches <var>Pattern</var> according to <var>How</var>. <var>How</var> 
is one of
<code>icase</code>, <code>substring</code>, <code>word</code>, <code>prefix</code> 
or <code>like</code>. For backward compatibility, <code>exact</code> is 
a synonym for <code>icase</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="lang_matches/2"><strong>lang_matches</strong>(<var>+Lang, 
+Pattern</var>)</a></dt>
<dd class="defbody">
True if <var>Lang</var> matches <var>Pattern</var>. This implements XML 
language matching conform RFC 4647. Both <var>Lang</var> and <var>Pattern</var> 
are dash-separated strings of identifiers or (for <var>Pattern</var>) 
the wildcard *. Identifiers are matched case-insensitive and a * matches 
any number of identifiers. A short pattern is the same as *.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="lang_equal/2"><strong>lang_equal</strong>(<var>+Lang1, 
+Lang2</var>)</a></dt>
<dd class="defbody">
True if two RFC language specifiers denote the same language

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#lang_matches/2">lang_matches/2</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_reset_db/0"><strong>rdf_reset_db</strong></a></dt>
<dd class="defbody">
Remove all triples from the RDF database and reset all its statistics.

<dl class="tags">
<dt class="tag">bug</dt>
<dd>
This predicate checks for active queries, but this check is not properly 
synchronized and therefore the use of this predicate is unsafe in 
multi-threaded contexts. It is mainly used to run functionality tests 
that need to start with an empty database.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_version/1"><strong>rdf_version</strong>(<var>-Version</var>)</a></dt>
<dd class="defbody">
True when <var>Version</var> is the numerical version-id of this 
library. The version is computed as

<pre class="code">
Major*10000 + Minor*100 + Patch.
</pre>

<p></dd>
</dl>

<p><h4 id="sec:semweb-memory-management"><a id="sec:3.3.12"><span class="sec-nr">3.3.12</span> <span class="sec-title">Memory 
management considerations</span></a></h4>

<p><a id="sec:semweb-memory-management"></a>

<p>Storing RDF triples in main memory provides much better performance 
than using external databases. Unfortunately, although memory is fairly 
cheap these days, main memory is severely limited when compared to 
disks. Memory usage breaks down to the following categories. Rough 
estimates of the memory usage is given <b>for 64-bit systems</b>. 32-bit 
system use slightly more than half these amounts.

<p>
<ul class="latex">
<li>Actually storing the triples. A triple is stored in a C struct of 
144 bytes. This struct both holds the quintuple, some bookkeeping 
information and the 10 next-pointers for the (max) to hash tables.
<li>The bucket array for the hashes. Each bucket maintains a
<i>head</i>, and <i>tail</i> pointer, as well as a count for the number 
of entries. The bucket array is allocated if a particular index is 
created, which implies the first query that requires the index. Each 
bucket requires 24 bytes.

<p>Bucket arrays are resized if necessary. Old triples remain at their 
original location. This implies that a query may need to scan multiple 
buckets. The garbage collector may relocate old indexed triples. It does 
so by copying the old triple. The old triple is later reclaimed by GC. 
Reindexed triples will be reused, but many reindexed triples may result 
in a significant memory fragmentation.
<li>Resources are maintained in a separate table to support
<a class="pred" href="#rdf_resource/1">rdf_resource/1</a>. A resources 
requires approximately 32 bytes.
<li>Identical literals are shared (see <a class="pred" href="#rdf_current_literal/1">rdf_current_literal/1</a>) 
and stored in a <i>skip list</i>. A literal requires approximately 40 
bytes, excluding the atom used for the lexical representation.
<li>Resources are stored in the Prolog atom-table. Atoms with the 
average length of a resource require approximately 88 bytes.
</ul>

<p>The hash parameters can be controlled with <a class="pred" href="#rdf_set/1">rdf_set/1</a>. 
Applications that are tight on memory and for which the query 
characteristics are more or less known can optimize performance and 
memory by fixing the hash-tables. By fixing the hash-tables we can 
tailor them to the frequent query patterns, we avoid the need for to 
check multiple hash buckets (see above) and we avoid memory 
fragmentation due to optimizing triples for resized hashes.

<pre class="code">
set_hash_parameters :-
      rdf_set(hash(s,   size, 1048576)),
      rdf_set(hash(p,   size, 1024)),
      rdf_set(hash(sp,  size, 2097152)),
      rdf_set(hash(o,   size, 1048576)),
      rdf_set(hash(po,  size, 2097152)),
      rdf_set(hash(spo, size, 2097152)),
      rdf_set(hash(g,   size, 1024)),
      rdf_set(hash(sg,  size, 1048576)),
      rdf_set(hash(pg,  size, 2048)).
</pre>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_set/1"><strong>rdf_set</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Set properties of the RDF store. Currently defines:

<dl class="latex">
<dt><strong>hash</strong>(<var>+Hash, +Parameter, +Value</var>)</dt>
<dd class="defbody">
Set properties for a triple index. <var>Hash</var> is one of <code>s</code>,
<code>p</code>, <code>sp</code>, <code>o</code>, <code>po</code>, <code>spo</code>, <code>g</code>, <code>sg</code> 
or <code>pg</code>. <var>Parameter</var> is one of:

<dl class="latex">
<dt><strong>size</strong></dt>
<dd class="defbody">
<var>Value</var> defines the number of entries in the hash-table.
<var>Value</var> is rounded <i>down</i> to a power of 2. After setting 
the size explicitly, auto-sizing for this table is disabled. Setting the 
size smaller than the current size results in a <code>permission_error</code> 
exception.
</dd>
<dt><strong>average_chain_len</strong></dt>
<dd class="defbody">
Set maximum average collision number for the hash.
</dd>
<dt><strong>optimize_threshold</strong></dt>
<dd class="defbody">
Related to resizing hash-tables. If 0, all triples are moved to the new 
size by the garbage collector. If more then zero, those of the last <var>Value</var> 
resize steps remain at their current location. Leaving cells at their 
current location reduces memory fragmentation and slows down access.
</dd>
</dl>

</dd>
</dl>

</dd>
</dl>

<p><b>The garbage collector</b> <a id="sec:semweb-gc"></a>

<p>The RDF store has a garbage collector that runs in a separate thread 
named =__rdf_GC=. The garbage collector removes the following objects:

<p>
<ul class="latex">
<li>Triples that have died before the the generation of last still 
active query.
<li>Entailment matrices for <code>rdfs:subPropertyOf</code> relations 
that are related to old queries.
</ul>

<p>In addition, the garbage collector reindexes triples associated to 
the hash-tables before the table was resized. The most recent resize 
operation leads to the largest number of triples that require 
reindexing, while the oldest resize operation causes the largest 
slowdown. The parameter <code>optimize_threshold</code> controlled by <a class="pred" href="#rdf_set/1">rdf_set/1</a> 
can be used to determine the number of most recent resize operations for 
which triples will not be reindexed. The default is 2.

<p>Normally, the garbage collector does it job in the background at a 
low priority. The predicate <a class="pred" href="#rdf_gc/0">rdf_gc/0</a> 
can be used to reclaim all garbage and optimize all indexes.<b>Warming 
up the database</b> <a id="sec:semweb-warming-up"></a>

<p>The RDF store performs many operations lazily or in background 
threads. For maximum performance, perform the following steps:

<p>
<ul class="latex">
<li>Load all the data without doing queries or retracting data in 
between. This avoids creating the indexes and therefore the need to 
resize them.
<li>Perform each of the indexed queries. The following call performs 
this. Note that it is irrelevant whether or not the query succeeds.

<pre class="code">
warm_indexes :-
    ignore(rdf(s, _, _)),
    ignore(rdf(_, p, _)),
    ignore(rdf(_, _, o)),
    ignore(rdf(s, p, _)),
    ignore(rdf(_, p, o)),
    ignore(rdf(s, p, o)),
    ignore(rdf(_, _, _, g)),
    ignore(rdf(s, _, _, g)),
    ignore(rdf(_, p, _, g)).
</pre>

<p>
<li>Duplicate adminstration is initialized in the background after the 
first call that returns a significant amount of duplicates. Creating the 
adminstration can be forced by calling <a class="pred" href="#rdf_update_duplicates/0">rdf_update_duplicates/0</a>.
</ul>

<p>Predicates:

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_gc/0"><strong>rdf_gc</strong></a></dt>
<dd class="defbody">
Run the RDF-DB garbage collector until no garbage is left and all tables 
are fully optimized. Under normal operation a separate thread with 
identifier <code>__rdf_GC</code> performs garbage collection as long as 
it is considered&lsquo;useful'.

<p>Using <a class="pred" href="#rdf_gc/0">rdf_gc/0</a> should only be 
needed to ensure a fully clean database for analysis purposes such as 
leak detection.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_update_duplicates/0"><strong>rdf_update_duplicates</strong></a></dt>
<dd class="defbody">
Update the duplicate administration of the RDF store. This marks every 
triple that is potentionally a duplicate of another as duplicate. Being 
potentially a duplicate means that subject, predicate and object are 
equivalent and the life-times of the two triples overlap.

<p>The duplicates marks are used to reduce the administrative load of 
avoiding duplicate answers. Normally, the duplicates are marked using a 
background thread that is started on the first query that produces a 
substantial amount of duplicates.
</dd>
</dl>

<p><h3 id="sec:rdfmonitor"><a id="sec:3.4"><span class="sec-nr">3.4</span> <span class="sec-title">Monitoring 
the database</span></a></h3>

<a id="sec:rdfmonitor"></a>

<p>The predicate <a id="idx:rdfmonitor2:3"></a><a class="pred" href="#rdf_monitor/2">rdf_monitor/2</a> 
allows registrations of call-backs with the RDF store. These call-backs 
are typically used to keep other databases in sync with the RDF store. 
For example,
<code>library(library(semweb/rdf_persistency))</code> monitors the RDF 
store for maintaining a persistent copy in a set of files and
<code>library(library(semweb/rdf_litindex))</code> uses added and 
deleted literal values to maintain a fulltext index of literals.

<dl class="latex">
<dt class="pubdef"><a id="rdf_monitor/2"><strong>rdf_monitor</strong>(<var>:Goal, 
+Mask</var>)</a></dt>
<dd class="defbody">
<var>Goal</var> is called for modifications of the database. It is 
called with a single argument that describes the modification. Defined 
events are:

<dl class="latex">
<dt><strong>assert</strong>(<var>+S, +P, +O, +DB</var>)</dt>
<dd class="defbody">
A triple has been asserted.
</dd>
<dt><strong>retract</strong>(<var>+S, +P, +O, +DB</var>)</dt>
<dd class="defbody">
A triple has been deleted.
</dd>
<dt><strong>update</strong>(<var>+S, +P, +O, +DB, +Action</var>)</dt>
<dd class="defbody">
A triple has been updated.
</dd>
<dt><strong>new_literal</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
A new literal has been created. <var>Literal</var> is the argument of
<code>literal(Arg)</code> of the triple's object. This event is 
introduced in version 2.5.0 of this library.
</dd>
<dt><strong>old_literal</strong>(<var>+Literal</var>)</dt>
<dd class="defbody">
The literal <var>Literal</var> is no longer used by any triple.
</dd>
<dt><strong>transaction</strong>(<var>+BeginOrEnd, +Id</var>)</dt>
<dd class="defbody">
Mark begin or end of the <em>commit</em> of a transaction started by
<a id="idx:rdftransaction2:4"></a><a class="pred" href="#rdf_transaction/2">rdf_transaction/2</a>. <var>BeginOrEnd</var> 
is <code>begin(Nesting)</code> or
<code>end(Nesting)</code>. <var>Nesting</var> expresses the nesting 
level of transactions, starting at&lsquo;0' for a toplevel transaction. <var>Id</var> 
is the second argument of <a id="idx:rdftransaction2:5"></a><a class="pred" href="#rdf_transaction/2">rdf_transaction/2</a>. 
The following transaction Ids are pre-defined by the library:

<dl class="latex">
<dt><strong>parse</strong>(<var>Id</var>)</dt>
<dd class="defbody">
A file is loaded using <a id="idx:rdfload2:6"></a><a class="pred" href="#rdf_load/2">rdf_load/2</a>. <var>Id</var> 
is one of <code>file(Path)</code> or <code>stream(Stream)</code>.
</dd>
<dt><strong>unload</strong>(<var>DB</var>)</dt>
<dd class="defbody">
All triples with source <var>DB</var> are being unloaded using <a id="idx:rdfunload1:7"></a><a class="pred" href="#rdf_unload/1">rdf_unload/1</a>.
</dd>
<dt><strong>reset</strong></dt>
<dd class="defbody">
Issued by <a id="idx:rdfresetdb0:8"></a><a class="pred" href="#rdf_reset_db/0">rdf_reset_db/0</a>.
</dd>
</dl>

</dd>
<dt><strong>load</strong>(<var>+BeginOrEnd, +Spec</var>)</dt>
<dd class="defbody">
Mark begin or end of <a id="idx:rdfloaddb1:9"></a><a class="pred" href="#rdf_load_db/1">rdf_load_db/1</a> 
or load through <a id="idx:rdfload2:10"></a><a class="pred" href="#rdf_load/2">rdf_load/2</a> 
from a cached file. <var>Spec</var> is currently defined as <code>file(Path)</code>.
</dd>
<dt><strong>rehash</strong>(<var>+BeginOrEnd</var>)</dt>
<dd class="defbody">
Marks begin/end of a re-hash due to required re-indexing or garbage 
collection.
</dd>
</dl>

<p><var>Mask</var> is a list of events this monitor is interested in. 
Default (empty list) is to report all events. Otherwise each element is 
of the form +Event or -Event to include or exclude monitoring for 
certain events. The event-names are the functor names of the events 
described above. The special name <code>all</code> refers to all events 
and
<code>assert(load)</code> to assert events originating from <a id="idx:rdfloaddb1:11"></a><a class="pred" href="#rdf_load_db/1">rdf_load_db/1</a>. 
As loading triples using <a id="idx:rdfloaddb1:12"></a><a class="pred" href="#rdf_load_db/1">rdf_load_db/1</a> 
is very fast, monitoring this at the triple level may seriously harm 
performance.

<p>This predicate is intended to maintain derived data, such as a 
journal, information for <em>undo</em>, additional indexing in literals, 
etc. There is no way to remove registered monitors. If this is required 
one should register a monitor that maintains a dynamic list of 
subscribers like the XPCE broadcast library. A second subscription of 
the same hook predicate only re-assignes the mask.

<p>The monitor hooks are called in the order of registration and in the 
same thread that issued the database manipulation. To process all 
changes in one thread they should be send to a thread message queue. For 
all updating events, the monitor is called while the calling thread has 
a write lock on the RDF store. This implies that these events are 
processed strickly synchronous, even if modifications originate from 
multiple threads. In particular, the <code>transaction</code> <em>begin</em>, 
... <em>updates</em> ... <em>end</em> sequence is never interleaved with 
other events. Same for <code>load</code> and <code>parse</code>.
</dd>
</dl>

<p><h3 id="sec:rdfissues"><a id="sec:3.5"><span class="sec-nr">3.5</span> <span class="sec-title">Issues 
with rdf_db</span></a></h3>

<a id="sec:rdfissues"></a>

<p>This RDF low-level module has been created after two year 
experimenting with a plain Prolog based module and a brief evaluation of 
a second generation pure Prolog implementation. The aim was to be able 
to handle upto about 5 million triples on standard (notebook) hardware 
and deal efficiently with <code>subPropertyOf</code> which was 
identified as a crucial feature of RDFS to realise fusion of different 
data-sets.

<p>The following issues are identified and not solved in suitable 
manner.

<dl class="latex">
<dt><b><code>subPropertyOf</code> of <code>subPropertyOf</code></b></dt>
<dd>
is not supported.</dd>
<dt><b>Equivalence</b></dt>
<dd>
Similar to <code>subPropertyOf</code>, it is likely to be profitable to 
handle resource identity efficient. The current system has no support 
for it.
</dd>
</dl>

<p><h2 id="sec:plugin"><a id="sec:4"><span class="sec-nr">4</span> <span class="sec-title">Plugin 
modules for rdf_db</span></a></h2>

<a id="sec:plugin"></a>

<p>The <code>library(rdf_db)</code> module provides several hooks for 
extending its functionality. Database updates can be monitored and acted 
upon through the features described in <a class="sec" href="#sec:3.4">section 
3.4</a>. The predicate <a id="idx:rdfload2:13"></a><a class="pred" href="#rdf_load/2">rdf_load/2</a> 
can be hooked to deal with different formats such as <em>rdfturtle</em>, 
different input sources (e.g. http) and different strategies for caching 
results.

<p><h3 id="sec:semweb-hooks"><a id="sec:4.1"><span class="sec-nr">4.1</span> <span class="sec-title">Hooks 
into the RDF library</span></a></h3>

<a id="sec:semweb-hooks"></a>

<p>The hooks below are used to add new RDF file formats and sources from 
which to load data to the library. They are used by the modules 
described below and distributed with the package. Please examine the 
source-code if you want to add new formats or locations.

<dl class="latex">
<dt><b><code>library(library(semweb/turtle))</code></b></dt>
<dd>
Load files in the Turtle format. See <a class="sec" href="#sec:5">section 
5</a>.
</dd>
<dt><b><code>library(library(semweb/rdf_zlib_plugin))</code></b></dt>
<dd>
Load <b>gzip</b> compressed files transparently. See
<a class="sec" href="#sec:4.2">section 4.2</a>.
</dd>
<dt><b><code>library(library(semweb/rdf_http_plugin))</code></b></dt>
<dd>
Load RDF documents from HTTP servers. See <a class="sec" href="#sec:4.3">section 
4.3</a>.
</dd>
<dt><b><code>library(library(http/http_ssl_plugin))</code></b></dt>
<dd>
May be combined with <code>library(library(semweb/rdf_http_plugin))</code> 
to load RDF from HTTPS servers.
</dd>
<dt><b><code>library(library(semweb/rdf_persistency))</code></b></dt>
<dd>
Provide persistent backup of the triple store.
</dd>
<dt><b><code>library(library(semweb/rdf_cache))</code></b></dt>
<dd>
Provide caching RDF sources using fast load/safe files to speedup 
restarting an application.
</dd>
</dl>

<dl class="latex">
<dt class="pubdef"><a id="rdf_db:rdf_open_hook/3"><strong>rdf_db:rdf_open_hook</strong>(<var>+Input, 
-Stream, -Format</var>)</a></dt>
<dd class="defbody">
Open an input. <var>Input</var> is one of <code>file(+Name)</code>,
<code>stream(+Stream)</code> or <code>url(Protocol, URL)</code>. If this 
hook succeeds, the RDF will be read from Stream using <a id="idx:rdfloadstream3:14"></a><span class="pred-ext">rdf_load_stream/3</span>. 
Otherwise the default open functionality for file and stream are used.</dd>
<dt class="pubdef"><a id="rdf_db:rdf_load_stream/3"><strong>rdf_db:rdf_load_stream</strong>(<var>+Format, 
+Stream, +Options</var>)</a></dt>
<dd class="defbody">
Actually load the RDF from <var>Stream</var> into the RDF database.
<var>Format</var> describes the format and is produced either by
<a id="idx:rdfinputinfo3:15"></a><span class="pred-ext">rdf_input_info/3</span> 
or <a id="idx:rdffiletype2:16"></a><span class="pred-ext">rdf_file_type/2</span>.</dd>
<dt class="pubdef"><a id="rdf_db:rdf_input_info/3"><strong>rdf_db:rdf_input_info</strong>(<var>+Input, 
-Modified, -Format</var>)</a></dt>
<dd class="defbody">
Gather information on <var>Input</var>. <var>Modified</var> is the last 
modification time of the source as a POSIX time-stamp (see <a id="idx:timefile2:17"></a><span class="pred-ext">time_file/2</span>).
<var>Format</var> is the RDF format of the file. See <a id="idx:rdffiletype2:18"></a><span class="pred-ext">rdf_file_type/2</span> 
for details. It is allowed to leave the output variables unbound. 
Ultimately the default modified time is&lsquo;0' and the format is 
assumed to be
<code>xml</code>.</dd>
<dt class="pubdef"><a id="rdf_db:rdf_file_type/2"><strong>rdf_db:rdf_file_type</strong>(<var>?Extension, 
?Format</var>)</a></dt>
<dd class="defbody">
True if <var>Format</var> is the default RDF file format for files with 
the given extension. <var>Extension</var> is lowercase and without a&rsquo;.'. 
E.g. <code>owl</code>. <var>Format</var> is either a built-in format (<code>xml</code> 
or <code>triples</code>) or a format understood by the <a id="idx:rdfloadstream3:19"></a><span class="pred-ext">rdf_load_stream/3</span> 
hook.</dd>
<dt class="pubdef"><a id="rdf_db:url_protocol/1"><strong>rdf_db:url_protocol</strong>(<var>?Protocol</var>)</a></dt>
<dd class="defbody">
True if <var>Protocol</var> is a URL protocol recognised by <a id="idx:rdfload2:20"></a><a class="pred" href="#rdf_load/2">rdf_load/2</a>.
</dd>
</dl>

<p><h3 id="sec:semweb-zlib"><a id="sec:4.2"><span class="sec-nr">4.2</span> <span class="sec-title">library(semweb/rdf_zlib_plugin): 
Reading compressed RDF</span></a></h3>

<a id="sec:semweb-zlib"></a>

<p><a id="idx:gzformat:21"></a><a id="idx:gzip:22"></a><a id="idx:compresseddata:23"></a>This 
module uses the <code>library(zlib)</code> library to load compressed 
files on the fly. The extension of the file must be <code>.gz</code>. 
The file format is deduced by the extension after stripping the <code>.gz</code> 
extension. E.g. <code>rdf_load('file.rdf.gz')</code>.

<p><h3 id="sec:http"><a id="sec:4.3"><span class="sec-nr">4.3</span> <span class="sec-title">library(semweb/rdf_http_plugin): 
Reading RDF from a HTTP server</span></a></h3>

<a id="sec:http"></a>

<p><a id="idx:xhtml:24"></a>This module allows for <code>rdf_load('http://...')</code>. 
It exploits the library <code>library(http/http_open.pl)</code>. The 
format of the URL is determined from the mime-type returned by the 
server if this is one of
<code>text/rdf+xml</code>, <code>application/x-turtle</code> or
<code>application/turtle</code>. As RDF mime-types are not yet widely 
supported, the plugin uses the extension of the URL if the claimed 
mime-type is not one of the above. In addition, it recognises
<code>text/html</code> and <code>application/xhtml+xml</code>, scanning 
the XML content for embedded RDF.

<p><h3 id="sec:rdfcache"><a id="sec:4.4"><span class="sec-nr">4.4</span> <span class="sec-title">library(semweb/rdf_cache): 
Cache RDF triples</span></a></h3>

<p><a id="sec:rdfcache"></a>

<p>The library <code>library(semweb/rdf_cache)</code> defines the 
caching strategy for triples sources. When using large RDF sources, 
caching triples greatly speedup loading RDF documents. The cache library 
implements two caching strategies that are controlled by <a class="pred" href="#rdf_set_cache_options/1">rdf_set_cache_options/1</a>.

<p><b>Local caching</b> This approach applies to files only. Triples are 
cached in a sub-directory of the directory holding the source. This 
directory is called <code>.cache</code> (<code>_cache</code> on 
Windows). If the cache option <code>create_local_directory</code> is <code>true</code>, 
a cache directory is created if posible.

<p><b>Global caching</b> This approach applies to all sources, except 
for unnamed streams. Triples are cached in directory defined by the 
cache option <code>global_directory</code>.

<p>When loading an RDF file, the system scans the configured cache files 
unless <code>cache(false)</code> is specified as option to <a class="pred" href="#rdf_load/2">rdf_load/2</a> 
or caching is disabled. If caching is enabled but no cache exists, the 
system will try to create a cache file. First it will try to do this 
locally. On failure it will try to configured global cache.

<dl class="latex">
<dt class="pubdef"><a id="rdf_set_cache_options/1"><strong>rdf_set_cache_options</strong>(<var>+Options</var>)</a></dt>
<dd class="defbody">
Change the cache policy. Provided options are:

<p>
<ul class="latex">
<li><code>enabled(Boolean)</code> If <code>true</code>, caching is 
enabled.
<li><code>local_directory(Name)</code>. Plain name of local directory. 
Default <code>.cache</code> (<code>_cache</code> on Windows).
<li><code>create_local_directory(Bool)</code> If <code>true</code>, try 
to create local cache directories
<li><code>global_directory(Dir)</code> Writeable directory for storing 
cached parsed files.
<li><code>create_global_directory(Bool)</code> If <code>true</code>, try 
to create the global cache directory.
</ul>
</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_cache_file/3"><strong>rdf_cache_file</strong>(<var>+URL, 
+ReadWrite, -File</var>)</a></dt>
<dd class="defbody">
<var>File</var> is the cache file for <var>URL</var>. If <var>ReadWrite</var> 
is <code>read</code>, it returns the name of an existing file. If <code>write</code> 
it returns where a new cache file can be overwritten or created.
</dd>
</dl>

<p><h3 id="sec:rdflitindex"><a id="sec:4.5"><span class="sec-nr">4.5</span> <span class="sec-title">library(semweb/rdf_litindex): 
Indexing words in literals</span></a></h3>

<a id="sec:rdflitindex"></a>

<p>The library <code>library(semweb/rdf_litindex.pl)</code> exploits the 
primitives of <a class="sec" href="#sec:4.5.1">section 4.5.1</a> and the 
NLP package to provide indexing on words inside literal constants. It 
also allows for fuzzy matching using stemming and&lsquo;sounds-like' 
based on the <em>double metaphone</em> algorithm of the NLP package.

<dl class="latex">
<dt class="pubdef"><a id="rdf_find_literals/2"><strong>rdf_find_literals</strong>(<var>+Spec, 
-ListOfLiterals</var>)</a></dt>
<dd class="defbody">
Find literals (without type or language specification) that satisfy
<var>Spec</var>. The required indices are created as needed and kept 
up-to-date using hooks registered with <a id="idx:rdfmonitor2:25"></a><a class="pred" href="#rdf_monitor/2">rdf_monitor/2</a>. 
Numerical indexing is currently limited to integers in the range <var>&#177;2^30</var> 
(<var>&#177;2^62 on 64-bit platforms</var>). <var>Spec</var> is defined 
as:

<dl class="latex">
<dt><strong>and</strong>(<var>Spec1, Spec2</var>)</dt>
<dd class="defbody">
Intersection of both specifications.</dd>
<dt><strong>or</strong>(<var>Spec1, Spec2</var>)</dt>
<dd class="defbody">
Union of both specifications.</dd>
<dt><strong>not</strong>(<var>Spec</var>)</dt>
<dd class="defbody">
Negation of <var>Spec</var>. After translation of the full specification 
to
<em>Disjunctive Normal Form</em> (DNF), negations are only allowed 
inside a conjunction with at least one positive literal.</dd>
<dt><strong>case</strong>(<var>Word</var>)</dt>
<dd class="defbody">
Matches all literals containing the word <var>Word</var>, doing the 
match case insensitive and after removing diacritics.</dd>
<dt><strong>stem</strong>(<var>Like</var>)</dt>
<dd class="defbody">
Matches all literals containing at least one word that has the same stem 
as <var>Like</var> using the Porter stem algorithm. See NLP package for 
details.</dd>
<dt><strong>sounds</strong>(<var>Like</var>)</dt>
<dd class="defbody">
Matches all literals containing at least one word that&lsquo;sounds 
like'
<var>Like</var> using the double metaphone algorithm. See NLP package 
for details.</dd>
<dt><strong>prefix</strong>(<var>Prefix</var>)</dt>
<dd class="defbody">
Matches all literals containing at least one word that starts with 
Prefix, discarding diacritics and case.</dd>
<dt><strong>between</strong>(<var>Low, High</var>)</dt>
<dd class="defbody">
Matches all literals containing an integer token in the range
<var>Low</var>..<var>High</var>, including the boundaries.</dd>
<dt><strong>ge</strong>(<var>Low</var>)</dt>
<dd class="defbody">
Matches all literals containing an integer token with value
<var>Low</var> or higher.</dd>
<dt><strong>le</strong>(<var>High</var>)</dt>
<dd class="defbody">
Matches all literals containing an integer token with value
<var>High</var> or lower.</dd>
<dt><strong>Token</strong></dt>
<dd class="defbody">
Matches all literals containing the given token. See <a id="idx:tokenizeatom2:26"></a><span class="pred-ext">tokenize_atom/2</span> 
of the NLP package for details.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_token_expansions/2"><strong>rdf_token_expansions</strong>(<var>+Spec, 
-Expansions</var>)</a></dt>
<dd class="defbody">
Uses the same database as <a id="idx:rdffindliterals2:27"></a><a class="pred" href="#rdf_find_literals/2">rdf_find_literals/2</a> 
to find possible expansions of <var>Spec</var>, i.e. which words&lsquo;sound 
like',&lsquo;have prefix', etc. <var>Spec</var> is a compound expression 
as in <a id="idx:rdffindliterals2:28"></a><a class="pred" href="#rdf_find_literals/2">rdf_find_literals/2</a>.
<var>Expansions</var> is unified to a list of terms <code>sounds(Like, 
Words)</code>, <code>stem(Like, Words)</code> or <code>prefix(Prefix, 
Words)</code>. On compound expressions, only combinations that provide 
literals are returned. Below is an example after loading the ULAN<sup class="fn">2<span class="fn-text">Unified 
List of Artist Names from the Getty Foundation.</span></sup> database 
and showing all words that sounds like&lsquo;rembrandt' and appear 
together in a literal with the word&lsquo;Rijn'. Finding this result 
from the 228,710 literals contained in ULAN requires 0.54 milliseconds 
(AMD 1600+).

<pre class="code">
?- rdf_token_expansions(and('Rijn', sounds(rembrandt)), L).

L = [sounds(rembrandt, ['Rambrandt', 'Reimbrant', 'Rembradt',
                        'Rembrand', 'Rembrandt', 'Rembrandtsz',
                        'Rembrant', 'Rembrants', 'Rijmbrand'])]
</pre>

<p>Here is another example, illustrating handling of diacritics:
<blockquote>

<pre class="code">
?- rdf_token_expansions(case(cafe), L).

L = [case(cafe, [cafe, caf\'e])]
</pre>

</blockquote>
</dd>
<dt class="pubdef"><a id="rdf_tokenize_literal/2"><strong>rdf_tokenize_literal</strong>(<var>+Literal, 
-Tokens</var>)</a></dt>
<dd class="defbody">
Tokenize a literal, returning a list of atoms and integers in the range
<var>-1073741824 ... 1073741823</var>. As tokenization is in general 
domain and task-dependent this predicate first calls the hook
<code>rdf_litindex:tokenization(Literal, -Tokens)</code>. On failure it 
calls <a id="idx:tokenizeatom2:29"></a><span class="pred-ext">tokenize_atom/2</span> 
from the NLP package and deletes the following: atoms of length 1, 
floats, integers that are out of range and the english words <code>and</code>, <code>an</code>, <code>or</code>, <code>of</code>,
<code>on</code>, <code>in</code>, <code>this</code> and <code>the</code>. 
Deletion first calls the hook <code>rdf_litindex:exclude_from_index(token, 
X)</code>. This hook is called as follows:

<pre class="code">
no_index_token(X) :-
        exclude_from_index(token, X), !.
no_index_token(X) :-
        ...
</pre>

<p></dd>
</dl>

<p><h4 id="sec:rdflitmap"><a id="sec:4.5.1"><span class="sec-nr">4.5.1</span> <span class="sec-title">Literal 
maps: Creating additional indices on literals</span></a></h4>

<a id="sec:rdflitmap"></a>

<p>&lsquo;Literal maps' provide a relation between literal values, 
intended to create additional indexes on literals. The current 
implementation can only deal with integers and atoms (string literals). 
A literal map maintains an ordered set of <em>keys</em>. The ordering 
uses the same rules as described in <a class="sec" href="#sec:4.5">section 
4.5</a>. Each key is associated with an ordered set of <em>values</em>. 
Literal map objects can be shared between threads, using a locking 
strategy that allows for multiple concurrent readers.

<p>Typically, this module is used together with <a id="idx:rdfmonitor2:30"></a><a class="pred" href="#rdf_monitor/2">rdf_monitor/2</a> 
on the channals <code>new_literal</code> and <code>old_literal</code> to 
maintain an index of words that appear in a literal. Further abstraction 
using Porter stemming or Metaphone can be used to create additional 
search indices. These can map either directly to the literal values, or 
indirectly to the plain word-map. The SWI-Prolog NLP package provides 
complimentary building blocks, such as a tokenizer, Porter stem and 
Double Metaphone.

<dl class="latex">
<dt class="pubdef"><a id="rdf_new_literal_map/1"><strong>rdf_new_literal_map</strong>(<var>-Map</var>)</a></dt>
<dd class="defbody">
Create a new literal map, returning an opaque handle.</dd>
<dt class="pubdef"><a id="rdf_destroy_literal_map/1"><strong>rdf_destroy_literal_map</strong>(<var>+Map</var>)</a></dt>
<dd class="defbody">
Destroy a literal map. After this call, further use of the <var>Map</var> 
handle is illegal. Additional synchronisation is needed if maps that are 
shared between threads are destroyed to guarantee the handle is no 
longer used. In some scenarios <a id="idx:rdfresetliteralmap1:31"></a><a class="pred" href="#rdf_reset_literal_map/1">rdf_reset_literal_map/1</a> 
provides a safe alternative.</dd>
<dt class="pubdef"><a id="rdf_reset_literal_map/1"><strong>rdf_reset_literal_map</strong>(<var>+Map</var>)</a></dt>
<dd class="defbody">
Delete all content from the literal map.</dd>
<dt class="pubdef"><a id="rdf_insert_literal_map/3"><strong>rdf_insert_literal_map</strong>(<var>+Map, 
+Key, +Value</var>)</a></dt>
<dd class="defbody">
Add a relation between <var>Key</var> and <var>Value</var> to the map. 
If this relation already exists no action is performed.</dd>
<dt class="pubdef"><a id="rdf_insert_literal_map/4"><strong>rdf_insert_literal_map</strong>(<var>+Map, 
+Key, +Value, -KeyCount</var>)</a></dt>
<dd class="defbody">
As <a id="idx:rdfinsertliteralmap3:32"></a><a class="pred" href="#rdf_insert_literal_map/3">rdf_insert_literal_map/3</a>. 
In addition, if <var>Key</var> is a new key in
<var>Map</var>, unify <var>KeyCount</var> with the number of keys in <var>Map</var>. 
This serves two purposes. Derived maps, such as the stem and metaphone 
maps need to know about new keys and it avoids additional foreign calls 
for doing the progress in <code>rdf_litindex.pl</code>.</dd>
<dt class="pubdef"><a id="rdf_delete_literal_map/2"><strong>rdf_delete_literal_map</strong>(<var>+Map, 
+Key</var>)</a></dt>
<dd class="defbody">
Delete <var>Key</var> and all associated values from the map. Succeeds 
always.</dd>
<dt class="pubdef"><a id="rdf_delete_literal_map/2"><strong>rdf_delete_literal_map</strong>(<var>+Map, 
+Key, +Value</var>)</a></dt>
<dd class="defbody">
Delete the association between <var>Key</var> and <var>Value</var> from 
the map. Succeeds always.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_find_literal_map/3"><strong>rdf_find_literal_map</strong>(<var>+Map, 
+KeyList, -ValueList</var>)</a></dt>
<dd class="defbody">
Unify <var>ValueList</var> with an ordered set of values associated to 
all keys from <var>KeyList</var>. Each key in <var>KeyList</var> is 
either an atom, an integer or a term <code>not(Key)</code>. If not-terms 
are provided, there must be at least one positive keywords. The 
negations are tested after establishing the positive matches.</dd>
<dt class="pubdef"><a id="rdf_keys_in_literal_map/3"><strong>rdf_keys_in_literal_map</strong>(<var>+Map, 
+Spec, -Answer</var>)</a></dt>
<dd class="defbody">
Realises various queries on the key-set:

<dl class="latex">
<dt><strong>all</strong></dt>
<dd class="defbody">
Unify <var>Answer</var> with an ordered list of all keys.</dd>
<dt><strong>key</strong>(<var>+Key</var>)</dt>
<dd class="defbody">
Succeeds if <var>Key</var> is a key in the map and unify <var>Answer</var> 
with the number of values associated with the key. This provides a fast 
test of existence without fetching the possibly large associated value 
set as with <a id="idx:rdffindliteralmap3:33"></a><a class="pred" href="#rdf_find_literal_map/3">rdf_find_literal_map/3</a>.</dd>
<dt><strong>prefix</strong>(<var>+Prefix</var>)</dt>
<dd class="defbody">
Unify <var>Answer</var> with an ordered set of all keys that have the 
given prefix. <var>Prefix</var> must be an atom. This call is intended 
for auto-completion in user interfaces.</dd>
<dt><strong>ge</strong>(<var>+Min</var>)</dt>
<dd class="defbody">
Unify <var>Answer</var> with all keys that are larger or equal to the 
integer <var>Min</var>.</dd>
<dt><strong>le</strong>(<var>+Max</var>)</dt>
<dd class="defbody">
Unify <var>Answer</var> with all keys that are smaller or equal to the 
integer <var>Max</var>.</dd>
<dt><strong>between</strong>(<var>+Min, +Max</var>)</dt>
<dd class="defbody">
Unify <var>Answer</var> with all keys between <var>Min</var> and <var>Max</var> 
(including).
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_statistics_literal_map/2"><strong>rdf_statistics_literal_map</strong>(<var>+Map, 
+Key(-Arg...)</var>)</a></dt>
<dd class="defbody">
Query some statistics of the map. Provides keys are:

<dl class="latex">
<dt><strong>size</strong>(<var>-Keys, -Relations</var>)</dt>
<dd class="defbody">
Unify <var>Keys</var> with the total key-count of the index and
<var>Relation</var> with the total <var>Key</var>-<var>Value</var> 
count.
</dd>
</dl>

</dd>
</dl>

<p><h3 id="sec:rdfpersistency"><a id="sec:4.6"><span class="sec-nr">4.6</span> <span class="sec-title">library(semweb/rdf_persistency): 
Providing persistent storage</span></a></h3>

<a id="sec:rdfpersistency"></a>

<p><a id="idx:Persistentstore:34"></a>The <code>library(semweb/rdf_persistency)</code> 
provides reliable persistent storage for the RDF data. The store uses a 
directory with files for each source (see <a id="idx:rdfsource1:35"></a><span class="pred-ext">rdf_source/1</span>) 
present in the database. Each source is represented by two files, one in 
binary format (see <a id="idx:rdfsavedb2:36"></a><a class="pred" href="#rdf_save_db/2">rdf_save_db/2</a>) 
representing the base state and one represented as Prolog terms 
representing the changes made since the base state. The latter is called 
the <em>journal</em>.

<dl class="latex">
<dt class="pubdef"><a id="rdf_attach_db/2"><strong>rdf_attach_db</strong>(<var>+Directory, 
+Options</var>)</a></dt>
<dd class="defbody">
Attach <var>Directory</var> as the persistent database. If <var>Directory</var> 
does not exist it is created. Otherwise all sources defined in the 
directory are loaded into the RDF database. Loading a source means 
loading the base state (if any) and replaying the journal (if any). The 
current implementation does not synchronise triples that are in the 
store before attaching a database. They are not removed from the 
database, nor added to the presistent store. Different merging options 
may be supported through the <var>Options</var> argument later. 
Currently defined options are:

<dl class="latex">
<dt><strong>concurrency</strong>(<var>+PosInt</var>)</dt>
<dd class="defbody">
Number of threads used to reload databased and journals from the files 
in <var>Directory</var>. Default is the number of physical CPUs 
determined by the Prolog flag <code>cpu_count</code> or 1 (one) on 
systems where this number is unknown. See also <a id="idx:concurrent3:37"></a><span class="pred-ext">concurrent/3</span>.</dd>
<dt><strong>max_open_journals</strong>(<var>+PosInt</var>)</dt>
<dd class="defbody">
The library maintains a pool of open journal files. This option 
specifies the size of this pool. The default is 10. Raising the option 
can make sense if many writes occur on many different named graphs. The 
value can be lowered for scenarios where write operations are very 
infrequent.</dd>
<dt><strong>silent</strong>(<var>Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code>, supress loading messages from <a id="idx:rdfattachdb2:38"></a><a class="pred" href="#rdf_attach_db/2">rdf_attach_db/2</a>.</dd>
<dt><strong>log_nested_transactions</strong>(<var>Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code>, nested <em>log</em> transactions are added to the 
journal information. By default (<code>false</code>), no log-term is 
added for nested transactions.
</dd>
</dl>

<p>The database is locked against concurrent access using a file
<code>lock</code> in <var>Directory</var>. An attempt to attach to a 
locked database raises a <code>permission_error</code> exception. The 
error context contains a term <code>rdf_locked(Args)</code>, where args 
is a list containing <code>time(Stamp)</code> and <code>pid(PID)</code>. 
The error can be caught by the application. Otherwise it prints:

<pre class="code">
ERROR: No permission to lock rdf_db `/home/jan/src/pl/packages/semweb/DB'
ERROR: locked at Wed Jun 27 15:37:35 2007 by process id 1748
</pre>

</dd>
<dt class="pubdef"><a id="rdf_detach_db/0"><strong>rdf_detach_db</strong></a></dt>
<dd class="defbody">
Detaches the persistent store. No triples are removed from the RDF 
triple store.</dd>
<dt class="pubdef"><a id="rdf_current_db/1"><strong>rdf_current_db</strong>(<var>-Directory</var>)</a></dt>
<dd class="defbody">
Unify <var>Directory</var> with the current database directory. Fails if 
no persistent database is attached.</dd>
<dt class="pubdef"><a id="rdf_persistency/2"><strong>rdf_persistency</strong>(<var>+DB, 
+Bool</var>)</a></dt>
<dd class="defbody">
Change presistency of named database (4th argument of <a id="idx:rdf4:39"></a><a class="pred" href="#rdf/4">rdf/4</a>). 
By default all databases are presistent. Using <code>false</code>, the 
journal and snapshot for the database are deleted and further changes to 
triples associated with <var>DB</var> are not recorded. If <var>Bool</var> 
is <code>true</code> a snapshot is created for the current state and 
further modifications are monitored. Switching persistency does not 
affect the triples in the in-memory RDF database.</dd>
<dt class="pubdef"><a id="rdf_flush_journals/1"><strong>rdf_flush_journals</strong>(<var>+Options</var>)</a></dt>
<dd class="defbody">
Flush dirty journals. With the option <code>min_size(KB)</code> only 
journals larger than <var>KB</var> Kbytes are merged with the base 
state. Flushing a journal takes the following steps, ensuring a stable 
state can be recovered at any moment.
<ol class="latex">
<li>Save the current database in a new file using the extension <code>.new</code>.
<li>On success, delete the journal
<li>On success, atomically move the <code>.new</code> file over the base 
state.
</ol>

<p>Note that journals are <em>not</em> merged automatically for two 
reasons. First of all, some applications may decide never to merge as 
the journal contains a complete <em>changelog</em> of the database. 
Second, merging large databases can be slow and the application may wish 
to schedule such actions at quiet times or scheduled maintenance 
periods.
</dd>
</dl>

<p><h4 id="sec:enrich"><a id="sec:4.6.1"><span class="sec-nr">4.6.1</span> <span class="sec-title">Enriching 
the journals</span></a></h4>

<a id="sec:enrich"></a>

<p>The above predicates suffice for most applications. The predicates in 
this section provide access to the journal files and the base state 
files and are intented to provide additional services, such as reasoning 
about the journals, loaded files, etc.<sup class="fn">3<span class="fn-text">A 
library <code>library(rdf_history)</code> is under development 
exploiting these features supporting wiki style editing of RDF.</span></sup>

<p>Using <code>rdf_transaction(Goal, log(Message))</code>, we can add 
additional records to enrich the journal of affected databases with <var>Term</var> 
and some additional bookkeeping information. Such a transaction adds a 
term
<code>begin(Id, Nest, Time, Message)</code> before the change operations 
on each affected database and <code>end(Id, Nest, Affected)</code> after 
the change operations. Here is an example call and content of the 
journal file <code>mydb.jrn</code>. A full explanation of the terms that 
appear in the journal is in the description of <a id="idx:rdfjournalfile2:40"></a><a class="pred" href="#rdf_journal_file/2">rdf_journal_file/2</a>.

<pre class="code">
?- rdf_transaction(rdf_assert(s,p,o,mydb), log(by(jan))).
</pre>

<pre class="code">
start([time(1183540570)]).
begin(1, 0, 1183540570.36, by(jan)).
assert(s, p, o).
end(1, 0, []).
end([time(1183540578)]).
</pre>

<p>Using <code>rdf_transaction(Goal, log(Message, DB))</code>, where <var>DB</var> 
is an atom denoting a (possibly empty) named graph, the system 
guarantees that a non-empty transaction will leave a possibly empty 
transaction record in DB. This feature assumes named graphs are named 
after the user making the changes. If a user action does not affect the 
user's graph, such as deleting a triple from another graph, we still 
find record of all actions performed by some user in the journal of that 
user.

<dl class="latex">
<dt class="pubdef"><a id="rdf_journal_file/2"><strong>rdf_journal_file</strong>(<var>?DB, 
?JournalFile</var>)</a></dt>
<dd class="defbody">
True if
<var>File</var> is the absolute file name of an existing named graph
<var>DB</var>. A journal file contains a sequence of Prolog terms of the 
following format.<sup class="fn">4<span class="fn-text">Future versions 
of this library may use an XML based language neutral format.</span></sup>

<dl class="latex">
<dt><strong>start</strong>(<var>Attributes</var>)</dt>
<dd class="defbody">
Journal has been opened. Currently <var>Attributes</var> contains a term <code>time(Stamp)</code>.</dd>
<dt><strong>end</strong>(<var>Attributes</var>)</dt>
<dd class="defbody">
Journal was closed. Currently <var>Attributes</var> contains a term <code>time(Stamp)</code>.</dd>
<dt><strong>assert</strong>(<var>Subject, Predicate, Object</var>)</dt>
<dd class="defbody">
A triple {Subject, Predicate, Object} was added to the database.</dd>
<dt><strong>assert</strong>(<var>Subject, Predicate, Object, Line</var>)</dt>
<dd class="defbody">
A triple {Subject, Predicate, Object} was added to the database with 
given <var>Line</var> context.</dd>
<dt><strong>retract</strong>(<var>Subject, Predicate, Object</var>)</dt>
<dd class="defbody">
A triple {Subject, Predicate, Object} was deleted from the database. 
Note that an <a id="idx:rdfretractall3:41"></a><a class="pred" href="#rdf_retractall/3">rdf_retractall/3</a> 
call can retract multiple triples. Each of them have a record in the 
journal. This allows for&lsquo;undo'.</dd>
<dt><strong>retract</strong>(<var>Subject, Predicate, Object, Line</var>)</dt>
<dd class="defbody">
Same as above, for a triple with associated line info.</dd>
<dt><strong>update</strong>(<var>Subject, Predicate, Object, Action</var>)</dt>
<dd class="defbody">
See <a id="idx:rdfupdate4:42"></a><a class="pred" href="#rdf_update/4">rdf_update/4</a>.</dd>
<dt><strong>begin</strong>(<var>Id, Nest, Time, Message</var>)</dt>
<dd class="defbody">
Added before the changes in each database affected by a transaction with 
transaction identifier <code>log(Message)</code>. <var>Id</var> is an 
integer counting the logged transactions to this database. Numbers are 
increasing and designed for binary search within the journal file.
<var>Nest</var> is the nesting level, where&lsquo;0' is a toplevel 
transaction.
<var>Time</var> is a time-stamp, currently using float notation with two 
fractional digits. <var>Message</var> is the term provided by the user 
as argument of the <code>log(Message)</code> transaction.</dd>
<dt><strong>end</strong>(<var>Id, Nest, Others</var>)</dt>
<dd class="defbody">
Added after the changes in each database affected by a transaction with 
transaction identifier <code>log(Message)</code>. <var>Id</var> and <var>Nest</var> 
match the begin-term. <var>Others</var> gives a list of other databases 
affected by this transaction and the <var>Id</var> of these records. The 
terms in this list have the format <var>DB</var>:<var>Id</var>.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="rdf_db_to_file/2"><strong>rdf_db_to_file</strong>(<var>?DB, 
?FileBase</var>)</a></dt>
<dd class="defbody">
Convert between <var>DB</var> (see <a id="idx:rdfsource1:43"></a><span class="pred-ext">rdf_source/1</span>) 
and file base-file used for storing information on this database. The 
full file is located in the directory described by <a id="idx:rdfcurrentdb1:44"></a><a class="pred" href="#rdf_current_db/1">rdf_current_db/1</a> 
and has the extension
<code>.trp</code> for the base state and <code>.jrn</code> for the 
journal.
</dd>
</dl>

<p><h2 id="sec:turtle"><a id="sec:5"><span class="sec-nr">5</span> <span class="sec-title">library(semweb/turtle): 
Turtle: Terse RDF Triple Language</span></a></h2>

<p><a id="sec:turtle"></a>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="url" href="http://www.w3.org/TR/turtle/">http://www.w3.org/TR/turtle/</a> 
(used W3C Recommendation 25 February 2014)
</dd>
</dl>

<p>This module implements the Turtle language for representing the RDF 
triple model as defined by Dave Beckett from the Institute for Learning 
and Research Technology University of Bristol and later standardized by 
the W3C RDF working group.

<p>This module acts as a plugin to <a class="pred" href="#rdf_load/2">rdf_load/2</a>, 
for processing files with one of the extensions <code>.ttl</code> or <code>.n3</code>.

<dl class="latex">
<dt class="pubdef"><a id="rdf_read_turtle/3"><strong>rdf_read_turtle</strong>(<var>+Input, 
-Triples, +Options</var>)</a></dt>
<dd class="defbody">
Read a stream or file into a set of triples or quadruples (if faced with 
TriG input) of the format

<pre class="code">
rdf(Subject, Predicate, Object [, Graph])
</pre>

<p>The representation is consistent with the SWI-Prolog RDF/XML and 
ntriples parsers. Provided options are:

<dl class="latex">
<dt><strong>base_uri</strong>(<var>+BaseURI</var>)</dt>
<dd class="defbody">
Initial base URI. Defaults to file://<var>&lt;</var>file<var>&gt;</var> 
for loading files.
</dd>
<dt><strong>anon_prefix</strong>(<var>+Prefix</var>)</dt>
<dd class="defbody">
Blank nodes are generated as <var>&lt;</var><var>Prefix</var><var>&gt;</var>1, <var>&lt;</var><var>Prefix</var><var>&gt;</var>2, 
etc. If <var>Prefix</var> is not an atom blank nodes are generated as
<code>node(1)</code>, <code>node(2)</code>, ...
</dd>
<dt><strong>format</strong>(<var>+Format</var>)</dt>
<dd class="defbody">
One of <code>auto</code> (default), <code>turtle</code> or <code>trig</code>. 
The auto mode switches to TriG format of there is a
<code>{</code> before the first triple. Finally, of the format is 
explicitly stated as <code>turtle</code> and the file appears to be a 
TriG file, a warning is printed and the data is loaded while ignoring 
the graphs.
</dd>
<dt><strong>resources</strong>(<var>URIorIRI</var>)</dt>
<dd class="defbody">
Officially, Turtle resources are IRIs. Quite a few applications however 
send URIs. By default we do URI<code>-&gt;</code>IRI mapping because 
this rarely causes errors. To force strictly conforming mode, pass <code>iri</code>.
</dd>
<dt><strong>prefixes</strong>(<var>-Pairs</var>)</dt>
<dd class="defbody">
Return encountered prefix declarations as a list of Alias-URI
</dd>
<dt><strong>namespaces</strong>(<var>-Pairs</var>)</dt>
<dd class="defbody">
Same as <code>prefixes(Pairs)</code>. Compatibility to <a class="pred" href="#rdf_load/2">rdf_load/2</a>.
</dd>
<dt><strong>base_used</strong>(<var>-Base</var>)</dt>
<dd class="defbody">
<var>Base</var> URI used for processing the data. Unified to
<code>[]</code> if there is no base-uri.
</dd>
<dt><strong>on_error</strong>(<var>+ErrorMode</var>)</dt>
<dd class="defbody">
In <code>warning</code> (default), print the error and continue parsing 
the remainder of the file. If <code>error</code>, abort with an 
exception on the first error encountered.
</dd>
<dt><strong>error_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
If <code>on_error(warning)</code> is active, this option cane be used to 
retrieve the number of generated errors.
</dd>
</dl>

<table class="arglist">
<tr><td><var>Input</var> </td><td>is one of <code>stream(Stream)</code>, <code>atom(Atom)</code>, 
a <code>http</code>,
<code>https</code> or <code>file</code> url or a filename specification 
as accepted by <span class="pred-ext">absolute_file_name/3</span>. </td></tr>
</table>
</dd>
<dt class="pubdef"><a id="rdf_load_turtle/3"><strong>rdf_load_turtle</strong>(<var>+Input, 
-Triples, +Options</var>)</a></dt>
<dd class="defbody">

<dl class="tags">
<dt class="tag">deprecated</dt>
<dd>
Use <a class="pred" href="#rdf_read_turtle/3">rdf_read_turtle/3</a>
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_process_turtle/3"><strong>rdf_process_turtle</strong>(<var>+Input, 
:OnObject, +Options</var>)</a></dt>
<dd class="defbody">
Streaming Turtle parser. The predicate <a class="pred" href="#rdf_process_turtle/3">rdf_process_turtle/3</a> 
processes Turtle data from <var>Input</var>, calling <var>OnObject</var> 
with a list of triples for every Turtle <i>statement</i> found in <var>Input</var>. <var>OnObject</var> 
is called as below, where <var>ListOfTriples</var> is a list of
<code>rdf(S,P,O)</code> terms for a normal Turtle file or <code>rdf(S,P,O,G)</code> 
terms if the <code>GRAPH</code> keyword is used to associate a set of 
triples in the document with a particular graph. The <var>Graph</var> 
argument provides the default graph for storing the triples and <i>Line</i> 
is the line number where the statement started.

<pre class="code">
call(OnObject, ListOfTriples, Graph:Line)
</pre>

<p>This predicate supports the same <var>Options</var> as <a class="pred" href="#rdf_load_turtle/3">rdf_load_turtle/3</a>.

<p>Errors encountered are sent to <span class="pred-ext">print_message/2</span>, 
after which the parser tries to recover and parse the remainder of the 
data.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
This predicate is normally used by <span class="pred-ext">load_rdf/2</span> 
for processing RDF data.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="turtle_pn_local/1"><strong>turtle_pn_local</strong>(<var>+Atom:atom</var>)</a></dt>
<dd class="defbody">
True if <var>Atom</var> is a valid Turtle <i>PN_LOCAL</i> name. The 
PN_LOCAL name is what can follow the : in a resource. In the new Turtle, 
this can be anything and this function becomes meaningless. In the old 
turtle, PN_LOCAL is defined similar (but not equal) to an XML name. This 
predicate is used by <a class="pred" href="#rdf_save_turtle/2">rdf_save_turtle/2</a> 
to write files such that can be read by old parsers.

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<span class="pred-ext">xml_name/2</span>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="turtle_write_quoted_string/2"><strong>turtle_write_quoted_string</strong>(<var>+Out, 
+Value</var>)</a></dt>
<dd class="defbody">
Same as <code>turtle_write_quoted_string(Out, Value, false)</code>, 
writing a string with only a single <code>"</code>. Embedded newlines 
are escapes as <code>\n</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="turtle_write_uri/2"><strong>turtle_write_uri</strong>(<var>+Out, 
+Value</var>)</a></dt>
<dd class="defbody">
Write a URI as <code>&lt;...&gt;</code></dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="rdf_db:rdf_load_stream/3"><span class="module">rdf_db</span>:<strong>rdf_load_stream</strong>(<var>+Format, 
+Stream, :Options</var>)</a></dt>
<dd class="defbody">
(Turtle clauses)</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_ntriples/2"><strong>rdf_save_ntriples</strong>(<var>+Spec, 
:Options</var>)</a></dt>
<dd class="defbody">
Save RDF using ntriples format. The ntriples format is a subset of 
Turtle, writing each triple fully qualified on its own line.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_canonical_trig/2"><strong>rdf_save_canonical_trig</strong>(<var>+Spec, 
:Options</var>)</a></dt>
<dd class="defbody">
Save triples in a canonical format. See
<a class="pred" href="#rdf_save_canonical_turtle/2">rdf_save_canonical_turtle/2</a> 
foir details.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_trig/2"><strong>rdf_save_trig</strong>(<var>+Spec, 
:Options</var>)</a></dt>
<dd class="defbody">
Save multiple RDF graphs into a TriG file. <var>Options</var> are the 
same as for <a class="pred" href="#rdf_save_turtle/2">rdf_save_turtle/2</a>. <a class="pred" href="#rdf_save_trig/2">rdf_save_trig/2</a> 
ignores the
<code>graph(+Graph)</code> option and instead processes one additional 
option:

<dl class="latex">
<dt><strong>graphs</strong>(<var>+ListOfGraphs</var>)</dt>
<dd class="defbody">
List of graphs to save. When omitted, all graphs in the RDF store are 
stored in the TriG file.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_canonical_turtle/2"><strong>rdf_save_canonical_turtle</strong>(<var>+Spec, 
:Options</var>)</a></dt>
<dd class="defbody">
Save triples in a canonical format. This is the same as
<a class="pred" href="#rdf_save_turtle/2">rdf_save_turtle/2</a>, but 
using different defaults. In particular:

<p>
<ul class="compact">
<li><code>encoding(utf8)</code>,
<li><code>indent(0)</code>,
<li><code>tab_distance(0)</code>,
<li><code>subject_white_lines(1)</code>,
<li><code>align_prefixes(false)</code>,
<li><code>user_prefixes(false)</code>
<li><code>comment(false)</code>,
<li><code>group(false)</code>,
<li><code>single_line_bnodes(true)</code>
</ul>

<dl class="tags">
<dt class="tag">To be done</dt>
<dd>
Work in progress. Notably blank-node handling is incomplete.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_save_turtle/2"><strong>rdf_save_turtle</strong>(<var>+Out, 
:Options</var>)</a></dt>
<dd class="defbody">
Save an RDF graph as Turtle. <var>Options</var> processed are:

<dl class="latex">
<dt><strong>a</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), use <code>a</code> for the predicate <code>rdf:type</code>. 
Otherwise use the full resource.
</dd>
<dt><strong>align_prefixes</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
Nicely align the @prefix declarations
</dd>
<dt><strong>base</strong>(<var>+Base</var>)</dt>
<dd class="defbody">
Save relative to the given <var>Base</var>
</dd>
<dt><strong>canonize_numbers</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), emit numeric 
datatypes using Prolog's write to achieve canonical output.
</dd>
<dt><strong>comment</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
It <code>true</code> (default), write some informative comments between 
the output segments
</dd>
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> used for the output stream. Default is UTF-8.
</dd>
<dt><strong>expand</strong>(<var>:Goal</var>)</dt>
<dd class="defbody">
Query an alternative graph-representation. See below.
</dd>
<dt><strong>indent</strong>(<var>+Column</var>)</dt>
<dd class="defbody">
Indentation for ; -lists.&lsquo;0' does not indent, but writes on the 
same line. Default is 8.
</dd>
<dt><strong>graph</strong>(<var>+Graph</var>)</dt>
<dd class="defbody">
Save only the named graph
</dd>
<dt><strong>group</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), using P-O and O-grouping.
</dd>
<dt><strong>inline_bnodes</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
if <code>true</code> (default), inline bnodes that are used once.
</dd>
<dt><strong>abbreviate_literals</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
if <code>true</code> (default), omit the type if allowed by turtle.
</dd>
<dt><strong>only_known_prefixes</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
Only use prefix notation for known prefixes. Without, some documents 
produce <i>huge</i> amounts of prefixes.
</dd>
<dt><strong>prefixes</strong>(<var>+List</var>)</dt>
<dd class="defbody">
If provided, uses exactly these prefixes. <var>List</var> is a list of 
prefix specifications, where each specification is either a term <i>Prefix_-_URI</i> 
or a prefix that is known to
<a class="pred" href="#rdf_current_prefix/2">rdf_current_prefix/2</a>.
</dd>
<dt><strong>silent</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), do not print the 
final informational message.
</dd>
<dt><strong>single_line_bnodes</strong>(<var>+Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), write [...] and (...) 
on a single line.
</dd>
<dt><strong>subject_white_lines</strong>(<var>+Count</var>)</dt>
<dd class="defbody">
Extra white lines to insert between statements about a different 
subject. Default is 1.
</dd>
<dt><strong>tab_distance</strong>(<var>+Tab</var>)</dt>
<dd class="defbody">
Distance between tab-stops.&lsquo;0' forces the library to use only 
spaces for layout. Default is 8.
</dd>
<dt><strong>user_prefixes</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), use prefixes from <a class="pred" href="#rdf_current_prefix/2">rdf_current_prefix/2</a>.
</dd>
</dl>

<p>The option <code>expand</code> allows for serializing alternative 
graph representations. It is called through <span class="pred-ext">call/5</span>, 
where the first argument is the expand-option, followed by S,P,O,G. G is 
the graph-option (which is by default a variable). This notably allows 
for writing RDF graphs represented as <code>rdf(S,P,O)</code> using the 
following code fragment:

<pre class="code">
triple_in(RDF, S,P,O,_G) :-
    member(rdf(S,P,O), RDF).

    ...,
    rdf_save_turtle(Out, [ expand(triple_in(RDF)) ]),
</pre>

<table class="arglist">
<tr><td><var>Out</var> </td><td>is one of <code>stream(Stream)</code>, a 
stream handle, a file-URL or an atom that denotes a filename. </td></tr>
</table>
</dd>
</dl>

<p><h2 id="sec:rdfntriples"><a id="sec:6"><span class="sec-nr">6</span> <span class="sec-title">library(semweb/rdf_ntriples): 
Process files in the RDF N-Triples format</span></a></h2>

<p><a id="sec:rdfntriples"></a>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="url" href="http://www.w3.org/TR/n-triples/">http://www.w3.org/TR/n-triples/</a>
</dd>
<dt class="tag">To be done</dt>
<dd>
Sync with RDF 1.1. specification.
</dd>
</dl>

<p>The <code>library(semweb/rdf_ntriples)</code> provides a fast reader 
for the RDF N-Triples and N-Quads format. N-Triples is a simple format, 
originally used to support the W3C RDF test suites. The current format 
has been extended and is a subset of the Turtle format (see
<code>library(semweb/turtle)</code>).

<p>The API of this library is almost identical to <code>library(semweb/turtle)</code>. 
This module provides a plugin into <a class="pred" href="#rdf_load/2">rdf_load/2</a>, 
making this predicate support the format <code>ntriples</code> and <code>nquads</code>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="read_ntriple/2"><strong>read_ntriple</strong>(<var>+Stream, 
-Triple</var>)</a></dt>
<dd class="defbody">
Read the next triple from <var>Stream</var> as <var>Triple</var>. <var>Stream</var> 
must have UTF-8 encoding.
<table class="arglist">
<tr><td><var>Triple</var> </td><td>is a term <code>triple(Subject,Predicate,Object)</code>. 
Arguments follow the normal conventions of the RDF libraries. NodeID 
elements are mapped to <code>node(Id)</code>. If end-of-file is reached, <var>Triple</var> 
is unified with
<code>end_of_file</code>. </td></tr>
</table>

<dl class="tags">
<dt class="tag">Errors</dt>
<dd>
<code>syntax_error(Message)</code> on syntax errors
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="read_nquad/2"><strong>read_nquad</strong>(<var>+Stream, 
-Quad</var>)</a></dt>
<dd class="defbody">
Read the next quad from <var>Stream</var> as <var>Quad</var>. <var>Stream</var> 
must have UTF-8 encoding.
<table class="arglist">
<tr><td><var>Quad</var> </td><td>is a term <code>quad(Subject,Predicate,Object,Graph)</code>. 
Arguments follow the normal conventions of the RDF libraries. NodeID 
elements are mapped to <code>node(Id)</code>. If end-of-file is reached, <var>Quad</var> 
is unified with
<code>end_of_file</code>. </td></tr>
</table>

<dl class="tags">
<dt class="tag">Errors</dt>
<dd>
<code>syntax_error(Message)</code> on syntax errors
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="read_ntuple/2"><strong>read_ntuple</strong>(<var>+Stream, 
-Tuple</var>)</a></dt>
<dd class="defbody">
Read the next triple or quad from <var>Stream</var> as <var>Tuple</var>. <var>Tuple</var> 
is one of the terms below. See <a class="pred" href="#read_ntriple/2">read_ntriple/2</a> 
and <a class="pred" href="#read_nquad/2">read_nquad/2</a> for details.

<p>
<ul class="compact">
<li><code>triple(Subject,Predicate,Object)</code>
<li><code>quad(Subject,Predicate,Object,Graph)</code>.
</ul>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_read_ntriples/3"><strong>rdf_read_ntriples</strong>(<var>+Input, 
-Triples, +Options</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_read_nquads/3"><strong>rdf_read_nquads</strong>(<var>+Input, 
-Quads, +Options</var>)</a></dt>
<dd class="defbody">
True when <var>Triples</var>/<var>Quads</var> is a list of triples/quads 
from <var>Input</var>.
<var>Options</var>:

<dl class="latex">
<dt><strong>anon_prefix</strong>(<var>+AtomOrNode</var>)</dt>
<dd class="defbody">
Prefix nodeIDs with this atom. If <var>AtomOrNode</var> is the term
<code>node(_)</code>, bnodes are returned as <code>node(Id)</code>.
</dd>
<dt><strong>base_uri</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
Defines the default anon_prefix as _<code>:&lt;</code>baseuri<var>&gt;</var>_
</dd>
<dt><strong>on_error</strong>(<var>Action</var>)</dt>
<dd class="defbody">
One of <code>warning</code> (default) or <code>error</code>
</dd>
<dt><strong>error_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
If <code>on_error</code> is <code>warning</code>, unify <var>Count</var> 
with th number of errors.
</dd>
<dt><strong>graph</strong>(<var>+Graph</var>)</dt>
<dd class="defbody">
For <a class="pred" href="#rdf_read_nquads/3">rdf_read_nquads/3</a>, 
this defines the graph associated to <i>triples</i> loaded from the 
input. For <a class="pred" href="#rdf_read_ntriples/3">rdf_read_ntriples/3</a> 
this opion is ignored.
</dd>
</dl>

<table class="arglist">
<tr><td><var>Triples</var> </td><td>is a list of <code>rdf(Subject, Predicate, Object)</code> </td></tr>
<tr><td><var>Quads</var> </td><td>is a list of <code>rdf(Subject, Predicate, Object, Graph)</code> </td></tr>
</table>
</dd>
<dt class="pubdef"><a id="rdf_process_ntriples/3"><strong>rdf_process_ntriples</strong>(<var>+Input, 
:CallBack, +Options</var>)</a></dt>
<dd class="defbody">
Call-back interface, compatible with the other triple readers. In 
addition to the options from <a class="pred" href="#rdf_read_ntriples/3">rdf_read_ntriples/3</a>, 
this processes the option <code>graph(Graph)</code>.
<table class="arglist">
<tr><td><var>CallBack</var> </td><td>is called as <code>call(CallBack, Triples, Graph)</code>, 
where Triples is a list holding a single <code>rdf(S,P,O)</code> triple. 
Graph is passed from the <code>graph</code> option and unbound if this 
option is omitted. </td></tr>
</table>
</dd>
<dt class="multidef"><span class="pred-tag">[semidet,multifile]</span><a id="rdf_db:rdf_load_stream/3"><span class="module">rdf_db</span>:<strong>rdf_load_stream</strong>(<var>+Format, 
+Stream, :Options</var>)</a></dt>
<dd class="defbody">
Plugin rule that supports loading the <code>ntriples</code> and <code>nquads</code> 
formats.</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="rdf_db:rdf_file_type/2"><span class="module">rdf_db</span>:<strong>rdf_file_type</strong>(<var>+Extension, 
-Format</var>)</a></dt>
<dd class="defbody">
Bind the ntriples reader to files with the extensions <code>nt</code>,
<code>ntriples</code> and <code>nquads</code>.
</dd>
</dl>

<p><h2 id="sec:rdfa"><a id="sec:7"><span class="sec-nr">7</span> <span class="sec-title">library(semweb/rdfa): 
Extract RDF from an HTML or XML DOM</span></a></h2>

<p><a id="sec:rdfa"></a>

<dl class="tags">
<dt class="mtag">See also</dt>
<dd>
- <a class="url" href="http://www.w3.org/TR/2013/REC-rdfa-core-20130822/">http://www.w3.org/TR/2013/REC-rdfa-core-20130822/</a> <br>
- <a class="url" href="http://www.w3.org/TR/html-rdfa/">http://www.w3.org/TR/html-rdfa/</a>
</dd>
</dl>

<p>This module implements extraction of RDFa triples from parsed XML or 
HTML documents. It has two interfaces: <a class="pred" href="#read_rdfa/3">read_rdfa/3</a> 
to read triples from some input (stream, file, URL) and <a class="pred" href="#xml_rdfa/3">xml_rdfa/3</a> 
to extract triples from an HTML or XML document that is already parsed 
with <span class="pred-ext">load_html/3</span> or
<span class="pred-ext">load_xml/3</span>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="read_rdfa/3"><strong>read_rdfa</strong>(<var>+Input, 
-Triples, +Options</var>)</a></dt>
<dd class="defbody">
True when <var>Triples</var> is a list of <code>rdf(S,P,O)</code> 
triples extracted from
<var>Input</var>. <var>Input</var> is either a stream, a file name, a 
URL referencing a file name or a URL that is valid for <span class="pred-ext">http_open/3</span>. <var>Options</var> 
are passed to <span class="pred-ext">open/4</span>, <span class="pred-ext">http_open/3</span> 
and <a class="pred" href="#xml_rdfa/3">xml_rdfa/3</a>. If no base is 
provided in <var>Options</var>, a base is deduced from <var>Input</var>.</dd>
<dt class="pubdef"><a id="xml_rdfa/3"><strong>xml_rdfa</strong>(<var>+DOM, 
-RDF, +Options</var>)</a></dt>
<dd class="defbody">
True when <var>RDF</var> is a list of <code>rdf(S,P,O)</code> terms 
extracted from <var>DOM</var> according to the RDFa specification. <var>Options</var> 
processed:

<dl class="latex">
<dt><strong>base</strong>(<var>+BaseURI</var>)</dt>
<dd class="defbody">
URI to use for&rdquo; . Normally set to the document URI.
</dd>
<dt><strong>anon_prefix</strong>(<var>+AnnonPrefix</var>)</dt>
<dd class="defbody">
Prefix for blank nodes.
</dd>
<dt><strong>lang</strong>(<var>+Lang</var>)</dt>
<dd class="defbody">
Default for <code>lang</code>
</dd>
<dt><strong>vocab</strong>(<var>+Vocab</var>)</dt>
<dd class="defbody">
Default for <code>vocab</code>
</dd>
<dt><strong>markup</strong>(<var>+Markup</var>)</dt>
<dd class="defbody">
<var>Markup</var> language processed (xhtml, xml, ...)
</dd>
</dl>

</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="rdf_db:rdf_load_stream/3"><span class="module">rdf_db</span>:<strong>rdf_load_stream</strong>(<var>+Format, 
+Stream, :Options</var>)</a></dt>
<dd class="defbody">
Register <code>library(semweb/rdfa)</code> as loader for HTML RDFa 
files.

<dl class="tags">
<dt class="tag">To be done</dt>
<dd>
Which options need to be forwarded to <a class="pred" href="#read_rdfa/3">read_rdfa/3</a>?
</dd>
</dl>

</dd>
</dl>

<p><h2 id="sec:rdfs"><a id="sec:8"><span class="sec-nr">8</span> <span class="sec-title">library(semweb/rdfs): 
RDFS related queries</span></a></h2>

<a id="sec:rdfs"></a>

<p><a id="idx:RDFSchema:45"></a>The <code>library(semweb/rdfs)</code> 
library adds interpretation of the triple store in terms of concepts 
from RDF-Schema (RDFS). There are two ways to provide support for more 
high level languages in RDF. One is to view such languages as a set of <em>entailment 
rules</em>. In this model the rdfs library would provide a predicate <span class="pred-ext">rdfs/3</span> 
providing the same functionality as <a id="idx:rdf3:46"></a><a class="pred" href="#rdf/3">rdf/3</a> 
on union of the raw graph and triples that can be derived by applying 
the RDFS entailment rules.

<p>Alternatively, RDFS provides a view on the RDF store in terms of 
individuals, classes, properties, etc., and we can provide predicates 
that query the database with this view in mind. This is the approach 
taken in the <code>library(semweb/rdfs.p)</code>l library, providing 
calls like
<code>rdfs_individual_of(?Resource, ?Class)</code>.<sup class="fn">5<span class="fn-text">The 
SeRQL language is based on querying the deductive closure of the triple 
set. The SWI-Prolog SeRQL library provides <em>entailment modules</em> 
that take the approach outlined above.</span></sup>

<p><h3 id="sec:semweb-rdfs-classes"><a id="sec:8.1"><span class="sec-nr">8.1</span> <span class="sec-title">Hierarchy 
and class-individual relations</span></a></h3>

<a id="sec:semweb-rdfs-classes"></a>

<p>The predicates in this section explore the <code>rdfs:subPropertyOf</code>,
<code>rdfs:subClassOf</code> and <code>rdf:type</code> relations. Note 
that the most fundamental of these, <code>rdfs:subPropertyOf</code>, is 
also used by <a id="idx:rdfhas34:47"></a><a class="pred" href="#rdf_has/3">rdf_has/[3,4]</a>.

<dl class="latex">
<dt class="pubdef"><a id="rdfs_subproperty_of/2"><strong>rdfs_subproperty_of</strong>(<var>?SubProperty, 
?Property</var>)</a></dt>
<dd class="defbody">
True if <var>SubProperty</var> is equal to <var>Property</var> or <var>Property</var> 
can be reached from <var>SubProperty</var> following the
<code>rdfs:subPropertyOf</code> relation. It can be used to test as well 
as generate sub-properties or super-properties. Note that the commonly 
used semantics of this predicate is wired into <a id="idx:rdfhas34:48"></a><a class="pred" href="#rdf_has/3">rdf_has/[3,4]</a>.<sup class="fn">bug<span class="fn-text">The 
current implementation cannot deal with cycles</span></sup>.<sup class="fn">bug<span class="fn-text">The 
current implementation cannot deal with predicates that are an <code>rdfs:subPropertyOf</code> 
of <code>rdfs:subPropertyOf</code>, such as <code>owl:samePropertyAs</code>.</span></sup></dd>
<dt class="pubdef"><a id="rdfs_subclass_of/2"><strong>rdfs_subclass_of</strong>(<var>?SubClass, 
?Class</var>)</a></dt>
<dd class="defbody">
True if <var>SubClass</var> is equal to <var>Class</var> or <var>Class</var> 
can be reached from <var>SubClass</var> following the
<code>rdfs:subClassOf</code> relation. It can be used to test as well as 
generate sub-classes or super-classes.<sup class="fn">bug<span class="fn-text">The 
current implementation cannot deal with cycles</span></sup>.</dd>
<dt class="pubdef"><a id="rdfs_class_property/2"><strong>rdfs_class_property</strong>(<var>+Class, 
?Property</var>)</a></dt>
<dd class="defbody">
True if the domain of <var>Property</var> includes <var>Class</var>. 
Used to generate all properties that apply to a class.</dd>
<dt class="pubdef"><a id="rdfs_individual_of/2"><strong>rdfs_individual_of</strong>(<var>?Resource, 
?Class</var>)</a></dt>
<dd class="defbody">
True if <var>Resource</var> is an indivisual of <var>Class</var>. This 
implies
<var>Resource</var> has an <code>rdf:type</code> property that refers to
<var>Class</var> or a sub-class thereof. Can be used to test, generate 
classes <var>Resource</var> belongs to or generate individuals described 
by <var>Class</var>.
</dd>
</dl>

<p><h3 id="sec:semweb-rdfs-containers"><a id="sec:8.2"><span class="sec-nr">8.2</span> <span class="sec-title">Collections 
and Containers</span></a></h3>

<a id="sec:semweb-rdfs-containers"></a>

<p><a id="idx:parseTypeCollection:49"></a><a id="idx:CollectionparseType:50"></a>The 
RDF construct <code>rdf:parseType</code>=<code>Collection</code> 
constructs a list using the <code>rdf:first</code> and <code>rdf:next</code> 
relations.

<dl class="latex">
<dt class="pubdef"><a id="rdfs_member/2"><strong>rdfs_member</strong>(<var>?Resource, 
+Set</var>)</a></dt>
<dd class="defbody">
Test or generate the members of <var>Set</var>. <var>Set</var> is either 
an individual of <code>rdf:List</code> or <code>rdfs:Container</code>.</dd>
<dt class="pubdef"><a id="rdfs_list_to_prolog_list/2"><strong>rdfs_list_to_prolog_list</strong>(<var>+Set, 
-List</var>)</a></dt>
<dd class="defbody">
Convert <var>Set</var>, which must be an individual of <code>rdf:List</code> 
into a Prolog list of objects.</dd>
<dt class="pubdef"><a id="rdfs_assert_list/2"><strong>rdfs_assert_list</strong>(<var>+List, 
-Resource</var>)</a></dt>
<dd class="defbody">
Equivalent to <a id="idx:rdfsassertlist3:51"></a><a class="pred" href="#rdfs_assert_list/3">rdfs_assert_list/3</a> 
using <var>DB</var> = <code>user</code>.</dd>
<dt class="pubdef"><a id="rdfs_assert_list/3"><strong>rdfs_assert_list</strong>(<var>+List, 
-Resource, +DB</var>)</a></dt>
<dd class="defbody">
If <var>List</var> is a list of resources, create an RDF list <var>Resource</var> 
that reflects these resources. <var>Resource</var> and the sublist 
resources are generated with <a id="idx:rdfbnode1:52"></a><a class="pred" href="#rdf_bnode/1">rdf_bnode/1</a>. 
The new triples are associated with the database <var>DB</var>.
</dd>
</dl>

<p><h2 id="sec:rdflib"><a id="sec:9"><span class="sec-nr">9</span> <span class="sec-title">Managing 
RDF input files</span></a></h2>

<a id="sec:rdflib"></a>

<p>Complex projects require RDF resources from many locations and 
typically wish to load these in different combinations. For example 
loading a small subset of the data for debugging purposes or load a 
different set of files for experimentation. The library <code>library(semweb/rdf_library.pl)</code> 
manages sets of RDF files spread over different locations, including 
file and network locations. The original version of this library 
supported metadata about collections of RDF sources in an RDF file 
called <em>Manifest</em>. The current version supports both the
<a class="url" href="http://www.w3.org/TR/void/">VoID</a> format and the 
original format. VoID files (typically named <code>void.ttl</code>) can 
use elements from the RDF Manifest vocabulary to support features that 
are not supported by VoID.

<p><h3 id="sec:semweb-rdf-manifest"><a id="sec:9.1"><span class="sec-nr">9.1</span> <span class="sec-title">The 
Manifest file</span></a></h3>

<a id="sec:semweb-rdf-manifest"></a>

<p>A manifest file is an RDF file, often in
<a class="url" href="http://www.w3.org/TeamSubmission/turtle/">Turtle</a> 
format, that provides meta-data about RDF resources. Often, a manifest 
will describe RDF files in the current directory, but it can also 
describe RDF resources at arbitrary URL locations. The RDF schema for 
RDF library meta-data can be found in <code>rdf_library.ttl</code>. The 
namespace for the RDF library format is defined as
<a class="url" href="http://www.swi-prolog.org/rdf/library/">http://www.swi-prolog.org/rdf/library/</a> 
and abbreviated as
<code>lib</code>.

<p>The schema defines three root classes: lib:Namespace, lib:Ontology 
and lib:Virtual, which we describe below.

<dl class="latex">
<dt class="pubdef"><a id="lib:Ontology"><strong>lib:Ontology</strong></a></dt>
<dd class="defbody">
This is a subclass of owl:Ontology. It has two subclasses, lib:Schema 
and lib:Instances. These three classes are currently processed equally. 
The following properties are recognised on lib:Ontology:

<dl class="latex">
<dt class="pubdef"><a id="dc:title"><strong>dc:title</strong></a></dt>
<dd class="defbody">
Title of the ontology. Displayed by <a id="idx:rdflistlibrary0:53"></a><a class="pred" href="#rdf_list_library/0">rdf_list_library/0</a>.
</dd>
<dt class="pubdef"><a id="owl:versionInfo"><strong>owl:versionInfo</strong></a></dt>
<dd class="defbody">
Version of the ontology. Displayed by <a id="idx:rdflistlibrary0:54"></a><a class="pred" href="#rdf_list_library/0">rdf_list_library/0</a>.
</dd>
<dt class="pubdef"><a id="owl:imports"><strong>owl:imports</strong></a></dt>
<dd class="defbody">
Ontologies imported. If <a id="idx:rdfloadlibrary2:55"></a><a class="pred" href="#rdf_load_library/2">rdf_load_library/2</a> 
is used to load this ontology, the ontologies referenced here are loaded 
as well. There are two subProperties: lib:schema and lib:instances with 
the obvious meaning.
</dd>
<dt class="pubdef"><a id="lib:source"><strong>lib:source</strong></a></dt>
<dd class="defbody">
Defines the named graph into which the resource is loaded. If this ends 
in a <code><code>/</code></code>, the basename of each loaded file is 
appended to the given source. Defaults to the URL the RDF is loaded 
from.
</dd>
<dt class="pubdef"><a id="lib:baseURI"><strong>lib:baseURI</strong></a></dt>
<dd class="defbody">
Defines the base for processing the RDF data. If not provided this 
defaults to the named graph, which in turn defaults to the URL the RDF 
is loaded from.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="lib:Virtual"><strong>lib:Virtual</strong></a></dt>
<dd class="defbody">
Virtual ontologies do not refer to an RDF resource themselves. They only 
import other resources. For example the W3C WordNet manifest defines <code>wn-basic</code> 
and <code>wn-full</code> as virtual resources. The lib:Virtual resource 
is used as a second rdf:type:

<pre class="code">
&lt;wn-basic&gt;
        a lib:Ontology ;
        a lib:Virtual ;
        ...
</pre>

</dd>
<dt class="pubdef"><a id="lib:CloudNode"><strong>lib:CloudNode</strong></a></dt>
<dd class="defbody">
Used by ClioPatria to combine this ontology and all data it imports into 
a node in the automatically generated datacloud.</dd>
<dt class="pubdef"><a id="lib:Namespace"><strong>lib:Namespace</strong></a></dt>
<dd class="defbody">
Defines a URL to be a namespace. The definition provides the preferred 
mnemonic and can be referenced in the lib:providesNamespace and 
lib:usesNamespace properties. The <a id="idx:rdfloadlibrary2:56"></a><a class="pred" href="#rdf_load_library/2">rdf_load_library/2</a> 
predicates registers encountered namespace mnemonics with rdf-db using
<a id="idx:rdfregisterns2:57"></a><span class="pred-ext">rdf_register_ns/2</span>. 
Typically namespace declarations use @prefix declarations. E.g. 

<pre class="code">
@prefix     lib: &lt;http://www.swi-prolog.org/rdf/library/&gt; .
@prefix    rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

[ a lib:Namespace ;
  lib:mnemonic "rdfs" ;
  lib:namespace rdfs:
] .
</pre>

<p></dd>
</dl>

<p><h4 id="sec:semweb-void"><a id="sec:9.1.1"><span class="sec-nr">9.1.1</span> <span class="sec-title">Support 
for the VoID and VANN vocabularies</span></a></h4>

<a id="sec:semweb-void"></a>

<p>The <a class="url" href="http://www.w3.org/TR/void/">VoID</a> aims at 
resolving the same problem as the Manifest files described here. In 
addition, the
<a class="url" href="http://vocab.org/vann/">VANN</a> vocabulary 
provides the information about preferred namepaces prefixes. The RDF 
library manager can deal with VoID files. The following relations apply:

<p>
<ul class="latex">
<li>VoID <code>Dataset</code> and <code>Linkset</code> are similar to
<code>lib:Ontology</code>, but a VoID resource is always
<em>Virtual</em>. I.e., the VoID URI itself never refers to an RDF 
document.

<p>
<li>The <code>owl:imports</code> and its lib specializations are 
replaced by <code>void:subset</code> (referring to another VoID dataset) 
and <code>void:dataDump</code> (referring to a concrete document).

<p>
<li>A description of the dataset is given using <code>dcterms:description</code> 
rather than <code>rdfs:comment</code>

<p>
<li>The RDF library recognises <code>lib:source</code>, <code>lib:baseURI</code> 
and <code>lib:Cloudnode</code>, which have no equivalent in VoID.

<p>
<li>The RDF library recognises <code>vann:preferredNamespacePrefix</code> 
and
<code>vann:preferredNamespaceUri</code> as alternatives to its 
proprietary way for defining prefixes. The domain of these predicates is 
unclear. The library recognises them regardless of the domain. Note that 
the range of <code>vann:preferredNamespaceUri</code> is a <em>literal</em>. 
A disadvantage of that is that the Turtle prefix declaration cannot be 
reused.
</ul>

<p>Currently, the RDF metadata is <em>not</em> stored in the RDF 
database. It is processed by low-level primitives that do <em>not</em> 
perform RDFS reasoning. In particular, this means that 
rdfs:supPropertyOf and rdfs:subClassOf cannot be used to specialise the 
RDF meta vocabulary.

<p><h4 id="sec:semweb-find-manifest"><a id="sec:9.1.2"><span class="sec-nr">9.1.2</span> <span class="sec-title">Finding 
manifest files</span></a></h4>

<a id="sec:semweb-find-manifest"></a>

<p>The initial metadata file(s) are loaded into the system using
<a id="idx:rdfattachlibrary1:58"></a><a class="pred" href="#rdf_attach_library/1">rdf_attach_library/1</a>.

<dl class="latex">
<dt class="pubdef"><a id="rdf_attach_library/1"><strong>rdf_attach_library</strong>(<var>+FileOrDirectory</var>)</a></dt>
<dd class="defbody">
Load meta-data on RDF repositories from <var>FileOrDirectory</var>. If 
the argument is a directory, this directory is processed recursively and 
each for each directory, a file named <code>void.ttl</code>,
<code>Manifest.ttl</code> or <code>Manifest.rdf</code> is loaded (in 
this order of preference).

<p>Declared namespaces are added to the rdf-db namespace list. 
Encountered ontologies are added to a private database of
<code>rdf_list_library.pl</code>. Each ontology is given an
<em>identifier</em>, derived from the basename of the URL without the 
extension. This, using the declaration below, the identifier of the 
declared ontology is <code>wn-basic</code>.

<pre class="code">
&lt;wn-basic&gt;
        a void:Dataset ;
        dcterms:title "Basic WordNet" ;
        ...
</pre>

</dd>
<dt class="pubdef"><a id="rdf_list_library/0"><strong>rdf_list_library</strong></a></dt>
<dd class="defbody">
List the available resources in the library. Currently only lists 
resources that have a dcterms:title property. See <a class="sec" href="#sec:9.2">section 
9.2</a> for an example.
</dd>
</dl>

<p>It is possible for the initial set of manifests to refer to RDF files 
that are not covered by a manifest. If such a reference is encountered 
while loading or listing a library, the library manager will look for a 
manifest file in the directory holding the referenced RDF file and load 
this manifest. If a manifest is found that covers the referenced file, 
the directives found in the manifest will be followed. Otherwise the RDF 
resource is simply loaded using the current defaults.

<p>Further exploration of the library is achieved using <a id="idx:rdflistlibrary1:59"></a><a class="pred" href="#rdf_list_library/1">rdf_list_library/1</a> 
or <a id="idx:rdflistlibrary2:60"></a><a class="pred" href="#rdf_list_library/2">rdf_list_library/2</a>:

<dl class="latex">
<dt class="pubdef"><a id="rdf_list_library/1"><strong>rdf_list_library</strong>(<var>+Id</var>)</a></dt>
<dd class="defbody">
Same as <code>rdf_list_library(Id,[])</code>.</dd>
<dt class="pubdef"><a id="rdf_list_library/2"><strong>rdf_list_library</strong>(<var>+Id, 
+Options</var>)</a></dt>
<dd class="defbody">
Lists the resources that will be loaded if <var>Id</var> is handed to
<a id="idx:rdfloadlibrary2:61"></a><a class="pred" href="#rdf_load_library/2">rdf_load_library/2</a>. 
See <a id="idx:rdfattachlibrary1:62"></a><a class="pred" href="#rdf_attach_library/1">rdf_attach_library/1</a> 
for how ontology identifiers are generated. In addition it checks the 
existence of each resource to help debugging library dependencies. 
Before doing its work,
<a id="idx:rdflistlibrary2:63"></a><a class="pred" href="#rdf_list_library/2">rdf_list_library/2</a> 
reloads manifests that have changed since they were loaded the last 
time. For HTTP resources it uses the HEAD method to verify existence and 
last modification time of resources.</dd>
<dt class="pubdef"><a id="rdf_load_library/2"><strong>rdf_load_library</strong>(<var>+Id, 
+Options</var>)</a></dt>
<dd class="defbody">
Load the given library. First <a id="idx:rdfloadlibrary2:64"></a><a class="pred" href="#rdf_load_library/2">rdf_load_library/2</a> 
will establish what resources need to be loaded and whether all 
resources exist. Than it will load the resources.
</dd>
</dl>

<p><h3 id="sec:usage"><a id="sec:9.2"><span class="sec-nr">9.2</span> <span class="sec-title">Usage 
scenarios</span></a></h3>

<a id="sec:usage"></a>

<p>Typically, a project will use a single file using the same format as 
a manifest file that defines alternative configurations that can be 
loaded. This file is loaded at program startup using
<a id="idx:rdfattachlibrary1:65"></a><a class="pred" href="#rdf_attach_library/1">rdf_attach_library/1</a>. 
Users can now list the available libraries using <a id="idx:rdflistlibrary0:66"></a><a class="pred" href="#rdf_list_library/0">rdf_list_library/0</a> 
and <a id="idx:rdflistlibrary1:67"></a><a class="pred" href="#rdf_list_library/1">rdf_list_library/1</a>:

<pre class="code">
1 ?- rdf_list_library.
ec-core-vocabularies E-Culture core vocabularies
ec-all-vocabularies All E-Culture vocabularies
ec-hacks            Specific hacks
ec-mappings         E-Culture ontology mappings
ec-core-collections E-Culture core collections
ec-all-collections  E-Culture all collections
ec-medium           E-Culture medium sized data (artchive+aria)
ec-all              E-Culture all data
</pre>

<p>Now we can list a specific category using <a id="idx:rdflistlibrary1:68"></a><a class="pred" href="#rdf_list_library/1">rdf_list_library/1</a>. 
Note this loads two additional manifests referenced by resources 
encountered in
<code>ec-mappings</code>. If a resource does not exist is is flagged 
using
<code>[NOT FOUND]</code>.

<pre class="code">
2 ?- rdf_list_library('ec-mappings').
% Loaded RDF manifest /home/jan/src/eculture/vocabularies/mappings/Manifest.ttl
% Loaded RDF manifest /home/jan/src/eculture/collections/aul/Manifest.ttl
&lt;file:///home/jan/src/eculture/src/server/ec-mappings&gt;
. &lt;file:///home/jan/src/eculture/vocabularies/mappings/mappings&gt;
. . &lt;file:///home/jan/src/eculture/vocabularies/mappings/interface&gt;
. . . file:///home/jan/src/eculture/vocabularies/mappings/interface_class_mapping.ttl
. . . file:///home/jan/src/eculture/vocabularies/mappings/interface_property_mapping.ttl
. . &lt;file:///home/jan/src/eculture/vocabularies/mappings/properties&gt;
. . . file:///home/jan/src/eculture/vocabularies/mappings/ethnographic_property_mapping.ttl
. . . file:///home/jan/src/eculture/vocabularies/mappings/eculture_properties.ttl
. . . file:///home/jan/src/eculture/vocabularies/mappings/eculture_property_semantics.ttl
. . &lt;file:///home/jan/src/eculture/vocabularies/mappings/situations&gt;
. . . file:///home/jan/src/eculture/vocabularies/mappings/eculture_situations.ttl
. &lt;file:///home/jan/src/eculture/collections/aul/aul&gt;
. . file:///home/jan/src/eculture/collections/aul/aul.rdfs
. . file:///home/jan/src/eculture/collections/aul/aul.rdf
. . file:///home/jan/src/eculture/collections/aul/aul9styles.rdf
. . file:///home/jan/src/eculture/collections/aul/extractedperiods.rdf
. . file:///home/jan/src/eculture/collections/aul/manual-periods.rdf
</pre>

<p><h4 id="sec:semweb-manifest-resources"><a id="sec:9.2.1"><span class="sec-nr">9.2.1</span> <span class="sec-title">Referencing 
resources</span></a></h4>

<a id="sec:semweb-manifest-resources"></a>

<p>Resources and manifests are located either on the local filesystem or 
on a network resource. The initial manifest can also be loaded from a 
file or a URL. This defines the initial <em>base URL</em> of the 
document. The base URL can be overruled using the Turtle @base 
directive. Other documents can be referenced relative to this base URL 
by exploiting Turtle's URI expansion rules. Turtle resources can be 
specified in three ways, as absolute URLs (e.g. <code>&lt;http://www.example.com/rdf/ontology.rdf</code>&gt;), 
as relative URL to the base (e.g. <code>&lt;../rdf/ontology.rdf</code>&gt;) 
or following a
<em>prefix</em> (e.g. prefix:ontology).

<p>The prefix notation is powerful as we can define multiple of them and 
define resources relative to them. Unfortunately, prefixes can only be 
defined as absolute URLs or URLs relative to the base URL. Notably, they 
cannot be defined relative to other prefixes. In addition, a prefix can 
only be followed by a Qname, which excludes <code>.</code> and <code>/</code>.

<p>Easily relocatable manifests must define all resources relative to 
the base URL. Relocation is automatic if the manifest remains in the 
same hierarchy as the resources it references. If the manifest is copied 
elsewhere (i.e. for creating a local version) it can use @base to refer 
to the resource hierarchy. We can point to directories holding manifest 
files using @prefix declarations. There, we can reference
<em>Virtual</em> resources using prefix:name. Here is an example, were 
we first give some line from the initial manifest followed by the 
definition of the virtual RDFS resource.

<pre class="code">
@base &lt;http://gollem.science.uva.nl/e-culture/rdf/&gt; .

@prefix base:           &lt;base_ontologies/&gt; .

&lt;ec-core-vocabularies&gt;
        a lib:Ontology ;
        a lib:Virtual ;
        dc:title "E-Culture core vocabularies" ;
        owl:imports
                base:rdfs ,
                base:owl ,
                base:dc ,
                base:vra ,
                ...
</pre>

<pre class="code">
&lt;rdfs&gt;
        a lib:Schema ;
        a lib:Virtual ;
        rdfs:comment "RDF Schema" ;
        lib:source rdfs: ;
        lib:schema &lt;rdfs.rdfs&gt; .
</pre>

<p><h3 id="sec:semweb-rdflib-example"><a id="sec:9.3"><span class="sec-nr">9.3</span> <span class="sec-title">Putting 
it all together</span></a></h3>

<a id="sec:semweb-rdflib-example"></a>

<p>In this section we provide skeleton code for filling the RDF database 
from a password protected HTTP repository. The first line loads the 
application. Next we include modules that enable us to manage the RDF 
library, RDF database caching and HTTP connections. Then we setup the 
HTTP authentication, enable caching of processed RDF files and load the 
initial manifest. Finally <a id="idx:loaddata0:69"></a><span class="pred-ext">load_data/0</span> 
loads all our RDF data.

<pre class="code">
:- use_module(server).

:- use_module(library(http/http_open)).
:- use_module(library(semweb/rdf_library)).
:- use_module(library(semweb/rdf_cache)).

:- http_set_authorization('http://www.example.org/rdf',
                          basic(john, secret)).

:- rdf_set_cache_options([ global_directory('RDF-Cache'),
                           create_global_directory(true)
                         ]).


:- rdf_attach_library('http://www.example.org/rdf/Manifest.ttl').

%%      load_data
%
%       Load our RDF data

load_data :-
        rdf_load_library('all').
</pre>

<p><h3 id="sec:w3cmanifest"><a id="sec:9.4"><span class="sec-nr">9.4</span> <span class="sec-title">Example: 
A metadata file for W3C WordNet</span></a></h3>

<a id="sec:w3cmanifest"></a>

<p>The VoID metadata below allows for loading WordNet in the two 
predefined versions using one of

<pre class="code">
?- rdf_load_library('wn-basic', []).
?- rdf_load_library('wn-full', []).
</pre>

<pre class="code">
@prefix    void: &lt;http://rdfs.org/ns/void#&gt; .
@prefix    vann: &lt;http://purl.org/vocab/vann/&gt; .
@prefix     lib: &lt;http://www.swi-prolog.org/rdf/library/&gt; .
@prefix     owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix     rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix    rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix     xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix      dc: &lt;http://purl.org/dc/terms/&gt; .
@prefix   wn20s: &lt;http://www.w3.org/2006/03/wn/wn20/schema/&gt; .
@prefix   wn20i: &lt;http://www.w3.org/2006/03/wn/wn20/instances/&gt; .

[ vann:preferredNamespacePrefix "wn20i" ;
  vann:preferredNamespaceUri "http://www.w3.org/2006/03/wn/wn20/instances/"
] .

[ vann:preferredNamespacePrefix "wn20s" ;
  vann:preferredNamespaceUri "http://www.w3.org/2006/03/wn/wn20/schema/"
] .

&lt;wn20-common&gt;
        a void:Dataset ;
        dc:description "Common files between full and basic version" ;
        lib:source wn20i: ;
        void:dataDump
                &lt;wordnet-attribute.rdf.gz&gt; ,
                &lt;wordnet-causes.rdf.gz&gt; ,
                &lt;wordnet-classifiedby.rdf.gz&gt; ,
                &lt;wordnet-entailment.rdf.gz&gt; ,
                &lt;wordnet-glossary.rdf.gz&gt; ,
                &lt;wordnet-hyponym.rdf.gz&gt; ,
                &lt;wordnet-membermeronym.rdf.gz&gt; ,
                &lt;wordnet-partmeronym.rdf.gz&gt; ,
                &lt;wordnet-sameverbgroupas.rdf.gz&gt; ,
                &lt;wordnet-similarity.rdf.gz&gt; ,
                &lt;wordnet-synset.rdf.gz&gt; ,
                &lt;wordnet-substancemeronym.rdf.gz&gt; ,
                &lt;wordnet-senselabels.rdf.gz&gt; .

&lt;wn20-skos&gt;
        a void:Dataset ;
        void:subset &lt;wnskosmap&gt; ;
        void:dataDump &lt;wnSkosInScheme.ttl.gz&gt; .

&lt;wnskosmap&gt;
        a lib:Schema ;
        lib:source wn20s: ;
        void:dataDump
                &lt;wnskosmap.rdfs&gt; .

&lt;wnbasic-schema&gt;
        a void:Dataset ;
        lib:source wn20s: ;
        void:dataDump
                &lt;wnbasic.rdfs&gt; .

&lt;wn20-basic&gt;
        a void:Dataset ;
        a lib:CloudNode ;
        dc:title "Basic WordNet" ;
        dc:description "Light version of W3C WordNet" ;
        owl:versionInfo "2.0" ;
        lib:source wn20i: ;
        void:subset
                &lt;wnbasic-schema&gt; ,
                &lt;wn20-skos&gt; ,
                &lt;wn20-common&gt; .

&lt;wnfull-schema&gt;
        a void:Dataset ;
        lib:source wn20s: ;
        void:dataDump
                &lt;wnfull.rdfs&gt; .

&lt;wn20-full&gt;
        a void:Dataset ;
        a lib:CloudNode ;
        dc:title "Full WordNet" ;
        dc:description "Full version of W3C WordNet" ;
        owl:versionInfo "2.0" ;
        lib:source wn20i: ;
        void:subset
                &lt;wnfull-schema&gt; ,
                &lt;wn20-skos&gt; ,
                &lt;wn20-common&gt; ;
        void:dataDump
                &lt;wordnet-antonym.rdf.gz&gt; ,
                &lt;wordnet-derivationallyrelated.rdf.gz&gt; ,
                &lt;wordnet-participleof.rdf.gz&gt; ,
                &lt;wordnet-pertainsto.rdf.gz&gt; ,
                &lt;wordnet-seealso.rdf.gz&gt; ,
                &lt;wordnet-wordsensesandwords.rdf.gz&gt; ,
                &lt;wordnet-frame.rdf.gz&gt; .
</pre>

<p><h2 id="sec:sparqlclient"><a id="sec:10"><span class="sec-nr">10</span> <span class="sec-title">library(semweb/sparql_client): 
SPARQL client library</span></a></h2>

<p><a id="sec:sparqlclient"></a>

<p>This module provides a SPARQL client. For example:

<pre class="code">
?- sparql_query('select * where { ?x rdfs:label "Amsterdam" }', Row,
                [ host('dbpedia.org'), path('/sparql/')]).

Row = row('http://www.ontologyportal.org/WordNet#WN30-108949737') ;
false.
</pre>

<p>Or, querying a local server using an <code>ASK</code> query:

<pre class="code">
?- sparql_query('ask { owl:Class rdfs:label "Class" }', Row,
                [ host('localhost'), port(3020), path('/sparql/')]).
Row = true.
</pre>

<p>HTTPS servers are supported using the <code>scheme(https)</code> 
option:

<pre class="code">
?- sparql_query('select * where { ?x rdfs:label "Amsterdam"@nl }',
                Row,
                [ scheme(https),
                  host('query.wikidata.org'),
                  path('/sparql')
                ]).
</pre>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="sparql_query/3"><strong>sparql_query</strong>(<var>+Query, 
-Result, +Options</var>)</a></dt>
<dd class="defbody">
Execute a SPARQL query on an HTTP SPARQL endpoint. <var>Query</var> is 
an atom that denotes the query. <var>Result</var> is unified to a term <code>rdf(S,P,O)</code> 
for
<code>CONSTRUCT</code> and <code>DESCRIBE</code> queries, <code>row(...)</code> 
for <code>SELECT</code> queries and <code>true</code> or <code>false</code> 
for <code>ASK</code> queries. <var>Options</var> are

<p>Variables that are unbound in SPARQL (e.g., due to SPARQL optional 
clauses), are bound in Prolog to the atom <code>'$null$'</code>.

<dl class="latex">
<dt><strong>endpoint</strong>(<var>+URL</var>)</dt>
<dd class="defbody">
May be used as alternative to Scheme, Host, Port and Path to specify the 
endpoint in a single option.
</dd>
<dt><strong>host</strong>(<var>+Host</var>)</dt>
<dt><strong>port</strong>(<var>+Port</var>)</dt>
<dt><strong>path</strong>(<var>+Path</var>)</dt>
<dt><strong>scheme</strong>(<var>+Scheme</var>)</dt>
<dd class="defbody">
The above four options set the location of the server.
</dd>
<dt><strong>search</strong>(<var>+ListOfParams</var>)</dt>
<dd class="defbody">
Provide additional query parameters, such as the graph.
</dd>
<dt><strong>variable_names</strong>(<var>-ListOfNames</var>)</dt>
<dd class="defbody">
Unifies <var>ListOfNames</var> with a list of atoms that describe the 
names of the variables in a <code>SELECT</code> query.
</dd>
</dl>

<p>Remaining options are passed to <span class="pred-ext">http_open/3</span>. 
The defaults for Host, Port and Path can be set using <a class="pred" href="#sparql_set_server/1">sparql_set_server/1</a>. 
The initial default for port is 80 and path is&lsquo;/sparql/`.

<p>For example, the ClioPatria server understands the parameter
<code>entailment</code>. The code below queries for all triples using 
_rdfs_entailment.

<pre class="code">
?- sparql_query('select * where { ?s ?p ?o }',
                Row,
                [ search([entailment=rdfs])
                ]).
</pre>

<p>Another useful option is the <code>request_header</code> which, for 
example, may be used to trick force a server to reply using a particular 
document format:

<pre class="code">
?- sparql_query(
       'select * where { ?s ?p ?o }',
        Row,
        [ host('integbio.jp'),
          path('/rdf/sparql'),
          request_header('Accept' =
                         'application/sparql-results+xml')
        ]).
</pre>

</dd>
<dt class="pubdef"><a id="sparql_set_server/1"><strong>sparql_set_server</strong>(<var>+OptionOrList</var>)</a></dt>
<dd class="defbody">
Set sparql server default options. Provided defaults are: host, port and 
repository. For example:

<pre class="code">
    sparql_set_server([ host(localhost),
                        port(8080)
                        path(world)
                      ])
</pre>

<p>The default for port is 80 and path is <code>/sparql/</code>.</dd>
<dt class="pubdef"><a id="sparql_read_xml_result/2"><strong>sparql_read_xml_result</strong>(<var>+Input, 
-Result</var>)</a></dt>
<dd class="defbody">
Specs from <a class="url" href="http://www.w3.org/TR/rdf-sparql-XMLres/">http://www.w3.org/TR/rdf-sparql-XMLres/</a>. 
The returned
<var>Result</var> term is of the format:

<dl class="latex">
<dt><strong>select</strong>(<var>VarNames, Rows</var>)</dt>
<dd class="defbody">
Where <var>VarNames</var> is a term <code>v(Name, ...)</code> and <var>Rows</var> 
is a list of <code>row(....)</code> containing the column values in the 
same order as the variable names.
</dd>
<dt><strong>ask</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
Where <var>Bool</var> is either <code>true</code> or <code>false</code>
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="sparql_read_json_result/2"><strong>sparql_read_json_result</strong>(<var>+Input, 
-Result</var>)</a></dt>
<dd class="defbody">
The returned <var>Result</var> term is of the format:

<dl class="latex">
<dt><strong>select</strong>(<var>VarNames, Rows</var>)</dt>
<dd class="defbody">
Where <var>VarNames</var> is a term <code>v(Name, ...)</code> and <var>Rows</var> 
is a list of <code>row(....)</code> containing the column values in the 
same order as the variable names.
</dd>
<dt><strong>ask</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
Where <var>Bool</var> is either <code>true</code> or <code>false</code>
</dd>
</dl>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="url" href="http://www.w3.org/TR/rdf-sparql-json-res/">http://www.w3.org/TR/rdf-sparql-json-res/</a>
</dd>
</dl>

</dd>
</dl>

<p><h2 id="sec:rdfcompare"><a id="sec:11"><span class="sec-nr">11</span> <span class="sec-title">library(semweb/rdf_compare): 
Compare RDF graphs</span></a></h2>

<p><a id="sec:rdfcompare"></a>

<p>This library provides predicates that compare RDF graphs. The current 
version only provides one predicate: <a class="pred" href="#rdf_equal_graphs/3">rdf_equal_graphs/3</a> 
verifies that two graphs are identical after proper labeling of the 
blank nodes.

<p>Future versions of this library may contain more advanced operations, 
such as diffing two graphs.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rdf_equal_graphs/3"><strong>rdf_equal_graphs</strong>(<var>+GraphA, 
+GraphB, -Substition</var>)</a></dt>
<dd class="defbody">
True if <var>GraphA</var> and <var>GraphB</var> are the same under <var>Substition</var>.
<var>Substition</var> is a list of BNodeA = BNodeB, where BNodeA is a 
blank node that appears in <var>GraphA</var> and BNodeB is a blank node 
that appears in <var>GraphB</var>.
<table class="arglist">
<tr><td><var>GraphA</var> </td><td>is a list of <code>rdf(S,P,O)</code> 
terms </td></tr>
<tr><td><var>GraphB</var> </td><td>is a list of <code>rdf(S,P,O)</code> 
terms </td></tr>
<tr><td><var>Substition</var> </td><td>is a list if NodeA = NodeB terms. </td></tr>
</table>

<dl class="tags">
<dt class="tag">To be done</dt>
<dd>
The current implementation is rather naive. After dealing with the 
subgraphs that contain no bnodes, it performs a fully non-deterministic 
substitution.
</dd>
</dl>

</dd>
</dl>

<p><h2 id="sec:rdfportray"><a id="sec:12"><span class="sec-nr">12</span> <span class="sec-title">library(semweb/rdf_portray): 
Portray RDF resources</span></a></h2>

<p><a id="sec:rdfportray"></a>

<dl class="tags">
<dt class="mtag">To be done</dt>
<dd>
- Define alternate predicate to use for providing a comment <br>
- Use rdf:type if there is no meaningful label? <br>
- Smarter guess whether or not the local identifier might be meaningful 
to the user without a comment. I.e. does it look&lsquo;word-like'?
</dd>
</dl>

<p>This module defines rules for <span class="pred-ext">user:portray/1</span> 
to help tracing and debugging RDF resources by printing them in a more 
concise representation and optionally adding comment from the label 
field to help the user interpreting the URL. The main predicates are:

<p>
<ul class="latex">
<li><a class="pred" href="#rdf_portray_as/1">rdf_portray_as/1</a> 
defines the overall style
<li><a class="pred" href="#rdf_portray_lang/1">rdf_portray_lang/1</a> 
selects languages for extracting label comments
</ul>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_portray_as/1"><strong>rdf_portray_as</strong>(<var>+Style</var>)</a></dt>
<dd class="defbody">
Set the style used to portray resources. <var>Style</var> is one of:

<dl class="latex">
<dt><b><code>prefix:id</code></b></dt>
<dd>
Write as NS:ID, compatible with what can be handed to the rdf 
predicates. This is the default.
</dd>
<dt><b><code>writeq</code></b></dt>
<dd>
Use quoted write of the full resource.
</dd>
<dt><b><code>prefix:label</code></b></dt>
<dd>
Write namespace followed by the label. This format cannot be handed to <a class="pred" href="#rdf/3">rdf/3</a> 
and friends, but can be useful if resource-names are meaningless 
identifiers.
</dd>
<dt><b><code>prefix:id=label</code></b></dt>
<dd>
This combines prefix:id with prefix:label, providing both human readable 
output and output that can be pasted into the commandline.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rdf_portray_lang/1"><strong>rdf_portray_lang</strong>(<var>+Lang</var>)</a></dt>
<dd class="defbody">
If <var>Lang</var> is a list, set the list or preferred languages. If it 
is a single atom, push this language as the most preferred language.
</dd>
</dl>

<p><h2 id="sec:semweb-related-packages"><a id="sec:13"><span class="sec-nr">13</span> <span class="sec-title">Related 
packages</span></a></h2>

<a id="sec:semweb-related-packages"></a>

<p><a id="idx:ClioPatria:70"></a><a id="idx:SPARQL:71"></a>The core 
infrastructure for storing and querying RDF is provided by this package, 
which is distributed as a core package with SWI-Prolog.
<a class="url" href="http://cliopatria.swi-prolog.org">ClioPatria</a> 
provides a comprehensive server infrastructure on top of the <i>semweb</i> 
and
<i>http</i> packages. ClioPatria provides a SPARQL&nbsp;1.1 endpoint, 
linked open data (LOD) support, user management, a web interface and an 
extension infrastructure for programming (semantic) web applications.

<p><a id="idx:Thea:72"></a><a id="idx:OWL2:73"></a><a class="url" href="http://www.semanticweb.gr/TheaOWLLib/">Thea</a> 
provides access to OWL ontologies at the level of the abstract syntax. 
Can interact with external DL reasoner using DIG.

<p><h2 id="sec:semweb-version3"><a id="sec:14"><span class="sec-nr">14</span> <span class="sec-title">Version 
3 release notes</span></a></h2>

<a id="sec:semweb-version3"></a>

<p>RDF-DB version 3 is a major redesign of the SWI-Prolog RDF 
infrastructure. Nevertheles, version&nbsp;3 is almost perfectly upward 
compatible with version&nbsp;2. Below are some issues to take into 
consideration when upgrading.

<p>Version&nbsp;2 did not allow for modifications while read operations 
were in progress, for example due to an open choice point. As a 
consequence, operations that both queried and modified the database had 
to be wrapped in a transaction or the modifications had to be buffered 
as Prolog data structures. In both cases, the RDF store was not modified 
during the query phase. In version&nbsp;3, modifications are allowed 
while read operations are in progress and follow the Prolog <b>logical 
update view</b> semantics. This is different from using a transaction in 
version&nbsp;2, where the view for all read operations was frozen at the 
start of the transaction. In version&nbsp;3, every read operation sees 
the store frozen at the moment that the operation was started.

<p>We illustrate the difference by writing a forwards entailment rule 
that adds a <em>sibling</em> relation. In <b>version&nbsp;2</b>, we 
could perform this operation using one of the following:

<pre class="code">
add_siblings_1 :-
        findall(S-O,
                ( rdf(S, f:parent, P),
                  rdf(O, f:parent, P),
                  S \== O
                ),
                Pairs),
        forall(member(S-O, Pairs), rdf_assert(S,f:sibling,O)).

add_siblings_2 :-
        rdf_transaction(
            forall(( rdf(S, f:parent, P),
                     rdf(O, f:parent, P),
                     S \== O
                   ),
                   rdf_assert(S, f:sibling, O))).
</pre>

<p>In <b>version&nbsp;3</b>, we can write this in the natural Prolog 
style below. In itself, this may not seem a big advantage because 
wrapping such operations in a transaction is often a good style anyway. 
The story changes with more complicated constrol structures that combine 
iterations with steps that depend on triples asserted in previous steps. 
Such scenarios can be programmed naturally in the current version.

<pre class="code">
add_siblings_3 :-
        forall(( rdf(S, f:parent, P),
                 rdf(O, f:parent, P),
                 S \== O
               ),
               rdf_assert(S, f:sibling, O)).
</pre>

<p>In version&nbsp;3, code that combines queries with modification has 
the same semantics whether executed inside or outside a transaction. 
This property makes reusing such predicates predictable.

<dl class="latex">
<dt><b><a id="idx:rdfstatistics2:74"></a><span class="pred-ext">rdf_statistics/2</span></b></dt>
<dd>
Various statistics have been renamed or changed:
<ul class="compact">
<li><code>sources</code> is renamed into <code>graphs</code>
<li><code>triples_by_file</code> is renamed into
<code>triples_by_graph</code>
<li><code>gc</code> has additional arguments
<li><code>core</code> is removed.
</ul>
</dd>
<dt><b><a id="idx:rdfgeneration1:75"></a><a class="pred" href="#rdf_generation/1">rdf_generation/1</a></b></dt>
<dd>
Generations inside a transaction are represented as
<var>BaseGeneration</var>+<var>TransactionGeneration</var>, where
<var>BaseGeneration</var> is the global generation where the transaction 
started and <var>TransactionGeneration</var> expresses the generation 
within the transaction. Counting generation has changed as well. In 
particular, comitting a transaction steps the generation only by one.</dd>
<dt><b><a id="idx:rdfcurrentns1:76"></a><span class="pred-ext">rdf_current_ns/1</span>, <a id="idx:rdfregisterns2:77"></a><span class="pred-ext">rdf_register_ns/2</span>, <a id="idx:rdfregisterns3:78"></a><span class="pred-ext">rdf_register_ns/3</span></b></dt>
<dd>
These predicates are renamed into <a id="idx:rdfcurrentprefix1:79"></a><span class="pred-ext">rdf_current_prefix/1</span>,
<a id="idx:rdfregisterprefix2:80"></a><a class="pred" href="#rdf_register_prefix/2">rdf_register_prefix/2</a>, <a id="idx:rdfregisterprefix3:81"></a><a class="pred" href="#rdf_register_prefix/3">rdf_register_prefix/3</a>. 
The old predicates are still available as deprecated predicates.</dd>
<dt><b><a id="idx:rdfunload1:82"></a><a class="pred" href="#rdf_unload/1">rdf_unload/1</a></b></dt>
<dd>
now only accepts a source location and deletes the associated graph 
using <a id="idx:rdfunloadgraph1:83"></a><a class="pred" href="#rdf_unload_graph/1">rdf_unload_graph/1</a>.
</dd>
</dl>

<h2>Acknowledgements</h2>

<p>This research was supported by the following projects: MIA and 
MultimediaN project (www.multimedian.nl) funded through the BSIK 
programme of the Dutch Government, the FP-6 project HOPS of the European 
Commission, the COMBINE project supported by the ONR Global NICOP grant 
N62909-11-1-7060 and the Dutch national program COMMIT.

<h1><a id="document-index">Index</a></h1>

<dl>
<dt class="index-sep">?</dt>
<dt>compressed data</dt>
<dd>
<a class="idx" href="#idx:compresseddata:23">4.2</a></dd>
<dt>concurrent/3</dt>
<dd>
<a class="idx" href="#idx:concurrent3:37">4.6</a></dd>
<dt><a class="idx" href="#dc:title">dc:title</a></dt>
<dt>gz, format</dt>
<dd>
<a class="idx" href="#idx:gzformat:21">4.2</a></dd>
<dt>gzip</dt>
<dd>
<a class="idx" href="#idx:gzip:22">4.2</a></dd>
<dt><a class="idx" href="#lang_equal/2">lang_equal/2</a></dt>
<dt><a class="idx" href="#lang_matches/2">lang_matches/2</a></dt>
<dt><a class="idx" href="#lib:source">lib:source</a></dt>
<dt>load_data/0</dt>
<dd>
<a class="idx" href="#idx:loaddata0:69">9.3</a></dd>
<dt><a class="idx" href="#owl:imports">owl:imports</a></dt>
<dt><a class="idx" href="#rdf/3">rdf/3</a></dt>
<dd>
<a class="idx" href="#idx:rdf3:1">1</a> <a class="idx" href="#idx:rdf3:46">8</a></dd>
<dt><a class="idx" href="#rdf/4">rdf/4</a></dt>
<dd>
<a class="idx" href="#idx:rdf4:39">4.6</a></dd>
<dt><a class="idx" href="#rdf_active_transaction/1">rdf_active_transaction/1</a></dt>
<dt><a class="idx" href="#rdf_alt/3">rdf_alt/3</a></dt>
<dt><a class="idx" href="#rdf_assert/3">rdf_assert/3</a></dt>
<dt><a class="idx" href="#rdf_assert/4">rdf_assert/4</a></dt>
<dt><a class="idx" href="#rdf_assert_alt/3">rdf_assert_alt/3</a></dt>
<dt><a class="idx" href="#rdf_assert_alt/4">rdf_assert_alt/4</a></dt>
<dt><a class="idx" href="#rdf_assert_bag/2">rdf_assert_bag/2</a></dt>
<dt><a class="idx" href="#rdf_assert_bag/3">rdf_assert_bag/3</a></dt>
<dt><a class="idx" href="#rdf_assert_list/2">rdf_assert_list/2</a></dt>
<dt><a class="idx" href="#rdf_assert_list/3">rdf_assert_list/3</a></dt>
<dt><a class="idx" href="#rdf_assert_seq/2">rdf_assert_seq/2</a></dt>
<dt><a class="idx" href="#rdf_assert_seq/3">rdf_assert_seq/3</a></dt>
<dt><a class="idx" href="#rdf_attach_db/2">rdf_attach_db/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfattachdb2:38">4.6</a></dd>
<dt><a class="idx" href="#rdf_attach_library/1">rdf_attach_library/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfattachlibrary1:58">9.1.2</a> <a class="idx" href="#idx:rdfattachlibrary1:62">9.1.2</a> <a class="idx" href="#idx:rdfattachlibrary1:65">9.2</a></dd>
<dt><a class="idx" href="#rdf_bag/2">rdf_bag/2</a></dt>
<dt><a class="idx" href="#rdf_bnode/1">rdf_bnode/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfbnode1:52">8.2</a></dd>
<dt><a class="idx" href="#rdf_cache_file/3">rdf_cache_file/3</a></dt>
<dt><a class="idx" href="#rdf_canonical_literal/2">rdf_canonical_literal/2</a></dt>
<dt><a class="idx" href="#rdf_compare/3">rdf_compare/3</a></dt>
<dt><a class="idx" href="#rdf_create_bnode/1">rdf_create_bnode/1</a></dt>
<dt><a class="idx" href="#rdf_create_graph/1">rdf_create_graph/1</a></dt>
<dt><a class="idx" href="#rdf_current_db/1">rdf_current_db/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfcurrentdb1:44">4.6.1</a></dd>
<dt><a class="idx" href="#rdf_current_literal/1">rdf_current_literal/1</a></dt>
<dt>rdf_current_ns/1</dt>
<dd>
<a class="idx" href="#idx:rdfcurrentns1:76">14</a></dd>
<dt><a class="idx" href="#rdf_current_ns/2">rdf_current_ns/2</a></dt>
<dt><a class="idx" href="#rdf_current_predicate/1">rdf_current_predicate/1</a></dt>
<dt>rdf_current_prefix/1</dt>
<dd>
<a class="idx" href="#idx:rdfcurrentprefix1:79">14</a></dd>
<dt><a class="idx" href="#rdf_current_prefix/2">rdf_current_prefix/2</a></dt>
<dt><a class="idx" href="#rdf_current_snapshot/1">rdf_current_snapshot/1</a></dt>
<dt><a class="idx" href="#rdf_db:rdf_file_type/2">rdf_db:rdf_file_type/2</a></dt>
<dt><a class="idx" href="#rdf_db:rdf_input_info/3">rdf_db:rdf_input_info/3</a></dt>
<dt><a class="idx" href="#rdf_db:rdf_load_stream/3">rdf_db:rdf_load_stream/3</a></dt>
<dt><a class="idx" href="#rdf_db:rdf_open_hook/3">rdf_db:rdf_open_hook/3</a></dt>
<dt><a class="idx" href="#rdf_db:url_protocol/1">rdf_db:url_protocol/1</a></dt>
<dt><a class="idx" href="#rdf_db_to_file/2">rdf_db_to_file/2</a></dt>
<dt><a class="idx" href="#rdf_default_graph/1">rdf_default_graph/1</a></dt>
<dt><a class="idx" href="#rdf_default_graph/2">rdf_default_graph/2</a></dt>
<dt><a class="idx" href="#rdf_delete_literal_map/2">rdf_delete_literal_map/2</a></dt>
<dt><a class="idx" href="#rdf_delete_snapshot/1">rdf_delete_snapshot/1</a></dt>
<dt><a class="idx" href="#rdf_destroy_literal_map/1">rdf_destroy_literal_map/1</a></dt>
<dt><a class="idx" href="#rdf_detach_db/0">rdf_detach_db/0</a></dt>
<dt><a class="idx" href="#rdf_equal/2">rdf_equal/2</a></dt>
<dt><a class="idx" href="#rdf_equal_graphs/3">rdf_equal_graphs/3</a></dt>
<dt><a class="idx" href="#rdf_estimate_complexity/4">rdf_estimate_complexity/4</a></dt>
<dt>rdf_file_type/2</dt>
<dd>
<a class="idx" href="#idx:rdffiletype2:16">4.1</a> <a class="idx" href="#idx:rdffiletype2:18">4.1</a></dd>
<dt><a class="idx" href="#rdf_find_literal_map/3">rdf_find_literal_map/3</a></dt>
<dd>
<a class="idx" href="#idx:rdffindliteralmap3:33">4.5.1</a></dd>
<dt><a class="idx" href="#rdf_find_literals/2">rdf_find_literals/2</a></dt>
<dd>
<a class="idx" href="#idx:rdffindliterals2:27">4.5</a> <a class="idx" href="#idx:rdffindliterals2:28">4.5</a></dd>
<dt><a class="idx" href="#rdf_flush_journals/1">rdf_flush_journals/1</a></dt>
<dt><a class="idx" href="#rdf_gc/0">rdf_gc/0</a></dt>
<dt><a class="idx" href="#rdf_generation/1">rdf_generation/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfgeneration1:75">14</a></dd>
<dt><a class="idx" href="#rdf_global_id/2">rdf_global_id/2</a></dt>
<dt><a class="idx" href="#rdf_global_object/2">rdf_global_object/2</a></dt>
<dt><a class="idx" href="#rdf_global_term/2">rdf_global_term/2</a></dt>
<dt><a class="idx" href="#rdf_graph/1">rdf_graph/1</a></dt>
<dt><a class="idx" href="#rdf_graph_property/2">rdf_graph_property/2</a></dt>
<dt><a class="idx" href="#rdf_has/3">rdf_has/3</a></dt>
<dt><a class="idx" href="#rdf_has/4">rdf_has/4</a></dt>
<dt>rdf_has/[3,4]</dt>
<dd>
<a class="idx" href="#idx:rdfhas34:47">8.1</a> <a class="idx" href="#idx:rdfhas34:48">8.1</a></dd>
<dt>rdf_input_info/3</dt>
<dd>
<a class="idx" href="#idx:rdfinputinfo3:15">4.1</a></dd>
<dt><a class="idx" href="#rdf_insert_literal_map/3">rdf_insert_literal_map/3</a></dt>
<dd>
<a class="idx" href="#idx:rdfinsertliteralmap3:32">4.5.1</a></dd>
<dt><a class="idx" href="#rdf_insert_literal_map/4">rdf_insert_literal_map/4</a></dt>
<dt><a class="idx" href="#rdf_iri/1">rdf_iri/1</a></dt>
<dt><a class="idx" href="#rdf_is_bnode/1">rdf_is_bnode/1</a></dt>
<dt><a class="idx" href="#rdf_is_iri/1">rdf_is_iri/1</a></dt>
<dt><a class="idx" href="#rdf_is_literal/1">rdf_is_literal/1</a></dt>
<dt><a class="idx" href="#rdf_is_name/1">rdf_is_name/1</a></dt>
<dt><a class="idx" href="#rdf_is_object/1">rdf_is_object/1</a></dt>
<dt><a class="idx" href="#rdf_is_predicate/1">rdf_is_predicate/1</a></dt>
<dt><a class="idx" href="#rdf_is_resource/1">rdf_is_resource/1</a></dt>
<dt><a class="idx" href="#rdf_is_subject/1">rdf_is_subject/1</a></dt>
<dt><a class="idx" href="#rdf_is_term/1">rdf_is_term/1</a></dt>
<dt><a class="idx" href="#rdf_journal_file/2">rdf_journal_file/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfjournalfile2:40">4.6.1</a></dd>
<dt><a class="idx" href="#rdf_keys_in_literal_map/3">rdf_keys_in_literal_map/3</a></dt>
<dt><a class="idx" href="#rdf_last/2">rdf_last/2</a></dt>
<dt><a class="idx" href="#rdf_length/2">rdf_length/2</a></dt>
<dt><a class="idx" href="#rdf_lexical_form/2">rdf_lexical_form/2</a></dt>
<dt><a class="idx" href="#rdf_list/1">rdf_list/1</a></dt>
<dt><a class="idx" href="#rdf_list/2">rdf_list/2</a></dt>
<dt><a class="idx" href="#rdf_list_library/0">rdf_list_library/0</a></dt>
<dd>
<a class="idx" href="#idx:rdflistlibrary0:53">9.1</a> <a class="idx" href="#idx:rdflistlibrary0:54">9.1</a> <a class="idx" href="#idx:rdflistlibrary0:66">9.2</a></dd>
<dt><a class="idx" href="#rdf_list_library/1">rdf_list_library/1</a></dt>
<dd>
<a class="idx" href="#idx:rdflistlibrary1:59">9.1.2</a> <a class="idx" href="#idx:rdflistlibrary1:67">9.2</a> <a class="idx" href="#idx:rdflistlibrary1:68">9.2</a></dd>
<dt><a class="idx" href="#rdf_list_library/2">rdf_list_library/2</a></dt>
<dd>
<a class="idx" href="#idx:rdflistlibrary2:60">9.1.2</a> <a class="idx" href="#idx:rdflistlibrary2:63">9.1.2</a></dd>
<dt><a class="idx" href="#rdf_literal/1">rdf_literal/1</a></dt>
<dt><a class="idx" href="#rdf_load/1">rdf_load/1</a></dt>
<dt><a class="idx" href="#rdf_load/2">rdf_load/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfload2:6">3.4</a> <a class="idx" href="#idx:rdfload2:10">3.4</a> <a class="idx" href="#idx:rdfload2:13">4</a> <a class="idx" href="#idx:rdfload2:20">4.1</a></dd>
<dt><a class="idx" href="#rdf_load_db/1">rdf_load_db/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfloaddb1:9">3.4</a> <a class="idx" href="#idx:rdfloaddb1:11">3.4</a> <a class="idx" href="#idx:rdfloaddb1:12">3.4</a></dd>
<dt><a class="idx" href="#rdf_load_library/2">rdf_load_library/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfloadlibrary2:55">9.1</a> <a class="idx" href="#idx:rdfloadlibrary2:56">9.1</a> <a class="idx" href="#idx:rdfloadlibrary2:61">9.1.2</a> <a class="idx" href="#idx:rdfloadlibrary2:64">9.1.2</a></dd>
<dt>rdf_load_stream/3</dt>
<dd>
<a class="idx" href="#idx:rdfloadstream3:14">4.1</a> <a class="idx" href="#idx:rdfloadstream3:19">4.1</a></dd>
<dt><a class="idx" href="#rdf_load_turtle/3">rdf_load_turtle/3</a></dt>
<dt><a class="idx" href="#rdf_make/0">rdf_make/0</a></dt>
<dt><a class="idx" href="#rdf_match_label/3">rdf_match_label/3</a></dt>
<dt><a class="idx" href="#rdf_member/2">rdf_member/2</a></dt>
<dt><a class="idx" href="#rdf_monitor/2">rdf_monitor/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfmonitor2:2">1</a> <a class="idx" href="#idx:rdfmonitor2:3">3.4</a> <a class="idx" href="#idx:rdfmonitor2:25">4.5</a> <a class="idx" href="#idx:rdfmonitor2:30">4.5.1</a></dd>
<dt><a class="idx" href="#rdf_name/1">rdf_name/1</a></dt>
<dt><a class="idx" href="#rdf_new_literal_map/1">rdf_new_literal_map/1</a></dt>
<dt><a class="idx" href="#rdf_node/1">rdf_node/1</a></dt>
<dt><a class="idx" href="#rdf_nth0/3">rdf_nth0/3</a></dt>
<dt><a class="idx" href="#rdf_nth1/3">rdf_nth1/3</a></dt>
<dt><a class="idx" href="#rdf_object/1">rdf_object/1</a></dt>
<dt><a class="idx" href="#rdf_persistency/2">rdf_persistency/2</a></dt>
<dt><a class="idx" href="#rdf_portray_as/1">rdf_portray_as/1</a></dt>
<dt><a class="idx" href="#rdf_portray_lang/1">rdf_portray_lang/1</a></dt>
<dt><a class="idx" href="#rdf_predicate/1">rdf_predicate/1</a></dt>
<dt><a class="idx" href="#rdf_predicate_property/2">rdf_predicate_property/2</a></dt>
<dt><a class="idx" href="#rdf_process_ntriples/3">rdf_process_ntriples/3</a></dt>
<dt><a class="idx" href="#rdf_process_turtle/3">rdf_process_turtle/3</a></dt>
<dt><a class="idx" href="#rdf_reachable/3">rdf_reachable/3</a></dt>
<dt><a class="idx" href="#rdf_reachable/5">rdf_reachable/5</a></dt>
<dt><a class="idx" href="#rdf_read_nquads/3">rdf_read_nquads/3</a></dt>
<dt><a class="idx" href="#rdf_read_ntriples/3">rdf_read_ntriples/3</a></dt>
<dt><a class="idx" href="#rdf_read_turtle/3">rdf_read_turtle/3</a></dt>
<dt>rdf_register_ns/2</dt>
<dd>
<a class="idx" href="#idx:rdfregisterns2:57">9.1</a> <a class="idx" href="#idx:rdfregisterns2:77">14</a></dd>
<dt>rdf_register_ns/3</dt>
<dd>
<a class="idx" href="#idx:rdfregisterns3:78">14</a></dd>
<dt><a class="idx" href="#rdf_register_prefix/2">rdf_register_prefix/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfregisterprefix2:80">14</a></dd>
<dt><a class="idx" href="#rdf_register_prefix/3">rdf_register_prefix/3</a></dt>
<dd>
<a class="idx" href="#idx:rdfregisterprefix3:81">14</a></dd>
<dt><a class="idx" href="#rdf_reset_db/0">rdf_reset_db/0</a></dt>
<dd>
<a class="idx" href="#idx:rdfresetdb0:8">3.4</a></dd>
<dt><a class="idx" href="#rdf_reset_literal_map/1">rdf_reset_literal_map/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfresetliteralmap1:31">4.5.1</a></dd>
<dt><a class="idx" href="#rdf_resource/1">rdf_resource/1</a></dt>
<dt><a class="idx" href="#rdf_retract_list/1">rdf_retract_list/1</a></dt>
<dt><a class="idx" href="#rdf_retractall/3">rdf_retractall/3</a></dt>
<dd>
<a class="idx" href="#idx:rdfretractall3:41">4.6.1</a></dd>
<dt><a class="idx" href="#rdf_retractall/4">rdf_retractall/4</a></dt>
<dt><a class="idx" href="#rdf_save/1">rdf_save/1</a></dt>
<dt><a class="idx" href="#rdf_save/2">rdf_save/2</a></dt>
<dt><a class="idx" href="#rdf_save_canonical_trig/2">rdf_save_canonical_trig/2</a></dt>
<dt><a class="idx" href="#rdf_save_canonical_turtle/2">rdf_save_canonical_turtle/2</a></dt>
<dt><a class="idx" href="#rdf_save_db/1">rdf_save_db/1</a></dt>
<dt><a class="idx" href="#rdf_save_db/2">rdf_save_db/2</a></dt>
<dd>
<a class="idx" href="#idx:rdfsavedb2:36">4.6</a></dd>
<dt><a class="idx" href="#rdf_save_footer/1">rdf_save_footer/1</a></dt>
<dt><a class="idx" href="#rdf_save_header/2">rdf_save_header/2</a></dt>
<dt><a class="idx" href="#rdf_save_ntriples/2">rdf_save_ntriples/2</a></dt>
<dt><a class="idx" href="#rdf_save_subject/3">rdf_save_subject/3</a></dt>
<dt><a class="idx" href="#rdf_save_trig/2">rdf_save_trig/2</a></dt>
<dt><a class="idx" href="#rdf_save_turtle/2">rdf_save_turtle/2</a></dt>
<dt><a class="idx" href="#rdf_seq/2">rdf_seq/2</a></dt>
<dt><a class="idx" href="#rdf_set/1">rdf_set/1</a></dt>
<dt><a class="idx" href="#rdf_set_cache_options/1">rdf_set_cache_options/1</a></dt>
<dt><a class="idx" href="#rdf_set_graph/2">rdf_set_graph/2</a></dt>
<dt><a class="idx" href="#rdf_set_predicate/2">rdf_set_predicate/2</a></dt>
<dt><a class="idx" href="#rdf_snapshot/1">rdf_snapshot/1</a></dt>
<dt>rdf_source/1</dt>
<dd>
<a class="idx" href="#idx:rdfsource1:35">4.6</a> <a class="idx" href="#idx:rdfsource1:43">4.6.1</a></dd>
<dt><a class="idx" href="#rdf_source_location/2">rdf_source_location/2</a></dt>
<dt><a class="idx" href="#rdf_statistics/1">rdf_statistics/1</a></dt>
<dt>rdf_statistics/2</dt>
<dd>
<a class="idx" href="#idx:rdfstatistics2:74">14</a></dd>
<dt><a class="idx" href="#rdf_statistics_literal_map/2">rdf_statistics_literal_map/2</a></dt>
<dt><a class="idx" href="#rdf_subject/1">rdf_subject/1</a></dt>
<dt><a class="idx" href="#rdf_term/1">rdf_term/1</a></dt>
<dt><a class="idx" href="#rdf_token_expansions/2">rdf_token_expansions/2</a></dt>
<dt><a class="idx" href="#rdf_tokenize_literal/2">rdf_tokenize_literal/2</a></dt>
<dt><a class="idx" href="#rdf_transaction/1">rdf_transaction/1</a></dt>
<dt><a class="idx" href="#rdf_transaction/2">rdf_transaction/2</a></dt>
<dd>
<a class="idx" href="#idx:rdftransaction2:4">3.4</a> <a class="idx" href="#idx:rdftransaction2:5">3.4</a></dd>
<dt><a class="idx" href="#rdf_transaction/3">rdf_transaction/3</a></dt>
<dt><a class="idx" href="#rdf_unload/1">rdf_unload/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfunload1:7">3.4</a> <a class="idx" href="#idx:rdfunload1:82">14</a></dd>
<dt><a class="idx" href="#rdf_unload_graph/1">rdf_unload_graph/1</a></dt>
<dd>
<a class="idx" href="#idx:rdfunloadgraph1:83">14</a></dd>
<dt><a class="idx" href="#rdf_update/4">rdf_update/4</a></dt>
<dd>
<a class="idx" href="#idx:rdfupdate4:42">4.6.1</a></dd>
<dt><a class="idx" href="#rdf_update/5">rdf_update/5</a></dt>
<dt><a class="idx" href="#rdf_update_duplicates/0">rdf_update_duplicates/0</a></dt>
<dt><a class="idx" href="#rdf_version/1">rdf_version/1</a></dt>
<dt><a class="idx" href="#rdf_where/1">rdf_where/1</a></dt>
<dt><a class="idx" href="#rdfs_assert_list/2">rdfs_assert_list/2</a></dt>
<dt><a class="idx" href="#rdfs_assert_list/3">rdfs_assert_list/3</a></dt>
<dd>
<a class="idx" href="#idx:rdfsassertlist3:51">8.2</a></dd>
<dt><a class="idx" href="#rdfs_class_property/2">rdfs_class_property/2</a></dt>
<dt><a class="idx" href="#rdfs_container/2">rdfs_container/2</a></dt>
<dt><a class="idx" href="#rdfs_container_membership_property/1">rdfs_container_membership_property/1</a></dt>
<dt><a class="idx" href="#rdfs_container_membership_property/2">rdfs_container_membership_property/2</a></dt>
<dt><a class="idx" href="#rdfs_individual_of/2">rdfs_individual_of/2</a></dt>
<dt><a class="idx" href="#rdfs_list_to_prolog_list/2">rdfs_list_to_prolog_list/2</a></dt>
<dt><a class="idx" href="#rdfs_member/2">rdfs_member/2</a></dt>
<dt><a class="idx" href="#rdfs_nth0/3">rdfs_nth0/3</a></dt>
<dt><a class="idx" href="#rdfs_subclass_of/2">rdfs_subclass_of/2</a></dt>
<dt><a class="idx" href="#rdfs_subproperty_of/2">rdfs_subproperty_of/2</a></dt>
<dt><a class="idx" href="#read_nquad/2">read_nquad/2</a></dt>
<dt><a class="idx" href="#read_ntriple/2">read_ntriple/2</a></dt>
<dt><a class="idx" href="#read_ntuple/2">read_ntuple/2</a></dt>
<dt><a class="idx" href="#read_rdfa/3">read_rdfa/3</a></dt>
<dt><a class="idx" href="#sparql_query/3">sparql_query/3</a></dt>
<dt><a class="idx" href="#sparql_read_json_result/2">sparql_read_json_result/2</a></dt>
<dt><a class="idx" href="#sparql_read_xml_result/2">sparql_read_xml_result/2</a></dt>
<dt><a class="idx" href="#sparql_set_server/1">sparql_set_server/1</a></dt>
<dt>time_file/2</dt>
<dd>
<a class="idx" href="#idx:timefile2:17">4.1</a></dd>
<dt>tokenize_atom/2</dt>
<dd>
<a class="idx" href="#idx:tokenizeatom2:26">4.5</a> <a class="idx" href="#idx:tokenizeatom2:29">4.5</a></dd>
<dt><a class="idx" href="#turtle_pn_local/1">turtle_pn_local/1</a></dt>
<dt><a class="idx" href="#turtle_write_quoted_string/2">turtle_write_quoted_string/2</a></dt>
<dt><a class="idx" href="#turtle_write_uri/2">turtle_write_uri/2</a></dt>
<dt>xhtml</dt>
<dd>
<a class="idx" href="#idx:xhtml:24">4.3</a></dd>
<dt><a class="idx" href="#xml_rdfa/3">xml_rdfa/3</a></dt>
<dt><a class="idx" href="#lib:CloudNode">lib:CloudNode</a></dt>
<dt>ClioPatria</dt>
<dd>
<a class="idx" href="#idx:ClioPatria:70">13</a></dd>
<dt>Collection,parseType</dt>
<dd>
<a class="idx" href="#idx:CollectionparseType:50">8.2</a></dd>
<dt class="index-sep">I</dt>
<dt><a class="idx" href="#owl:versionInfo">owl:versionInfo</a></dt>
<dt class="index-sep">N</dt>
<dt><a class="idx" href="#lib:Namespace">lib:Namespace</a></dt>
<dt class="index-sep">O</dt>
<dt><a class="idx" href="#lib:Ontology">lib:Ontology</a></dt>
<dt>OWL2</dt>
<dd>
<a class="idx" href="#idx:OWL2:73">13</a></dd>
<dt class="index-sep">P</dt>
<dt>Persistent store</dt>
<dd>
<a class="idx" href="#idx:Persistentstore:34">4.6</a></dd>
<dt class="index-sep">R</dt>
<dt>RDF-Schema</dt>
<dd>
<a class="idx" href="#idx:RDFSchema:45">8</a></dd>
<dt class="index-sep">S</dt>
<dt>SPARQL</dt>
<dd>
<a class="idx" href="#idx:SPARQL:71">13</a></dd>
<dt class="index-sep">T</dt>
<dt>Thea</dt>
<dd>
<a class="idx" href="#idx:Thea:72">13</a></dd>
<dt>parseType,Collection</dt>
<dd>
<a class="idx" href="#idx:parseTypeCollection:49">8.2</a></dd>
<dt class="index-sep">U</dt>
<dt><a class="idx" href="#lib:baseURI">lib:baseURI</a></dt>
<dt class="index-sep">V</dt>
<dt><a class="idx" href="#lib:Virtual">lib:Virtual</a></dt>
<dt class="index-sep">{</dt>
<dt><a class="idx" href="#{}/1">/1</a></dt>
<dd>
</dd>
</dl>

</body></html>