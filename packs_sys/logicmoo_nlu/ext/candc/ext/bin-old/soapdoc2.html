<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.00">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

<body bgcolor="#FFFFFF">



<title> The gSOAP Stub and Skeleton Compiler for C and C++ 2.1.6</title>
    
<h1 align="center">The gSOAP Stub and Skeleton Compiler for C and C++ 2.1.6 </h1>

<h3 align="center">Robert A. van Engelen <br />Department of Computer Science <br />Florida State University <br />Tallahassee, FL32306-4530 <br />engelen@cs.fsu.edu </h3>

<h3 align="center">Jul 14, 2002
<br /><a href="soapdoc2.pdf"><font color="#FF0000"><b>[This document is also available in PDF format (black and white only)]</b></font></a></h3>
 <br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; <font color="#0000FF">Introduction</font></a><br />
<a href="#tth_sEc2"
>2&nbsp; <font color="#0000FF">Notational Conventions</font></a><br />
<a href="#tth_sEc3"
>3&nbsp; <font color="#0000FF">Differences Between gSOAP Versions 1.X and 2.X</font></a><br />
<a href="#tth_sEc4"
>4&nbsp; <font color="#0000FF">Interoperability</font></a><br />
<a href="#tth_sEc5"
>5&nbsp; <font color="#0000FF">Quick User Guide</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; <font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Clients</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.1"
>5.1.1&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.2"
>5.1.2&nbsp; <font color="#0000FF">Namespace Considerations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.3"
>5.1.3&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.4"
>5.1.4&nbsp; <font color="#0000FF">Some SOAP Encoding Considerations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.5"
>5.1.5&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.6"
>5.1.6&nbsp; <font color="#0000FF">How to Change the Response Element Name</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.7"
>5.1.7&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.8"
>5.1.8&nbsp; <font color="#0000FF">How to Specify Multiple Output Parameters</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.9"
>5.1.9&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.10"
>5.1.10&nbsp; <font color="#0000FF">How to Specify Output Parameters With Complex Data Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.11"
>5.1.11&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.12"
>5.1.12&nbsp; <font color="#0000FF">How to Specify Anonymous Parameter Names</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.13"
>5.1.13&nbsp; <font color="#0000FF">How to Specify a Method with No Input Parameters</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; <font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Web Services</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.1"
>5.2.1&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.2"
>5.2.2&nbsp; <font color="#0000FF">How to Create a Stand-Alone Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.3"
>5.2.3&nbsp; <font color="#0000FF">How to Create a Multi-Threaded Stand-Alone Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.4"
>5.2.4&nbsp; <font color="#0000FF">Some Web Service Implementation Issues</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.5"
>5.2.5&nbsp; <font color="#0000FF">How to Generate WSDL Service Descriptions</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.6"
>5.2.6&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.7"
>5.2.7&nbsp; <font color="#0000FF">How to Import WSDL Service Descriptions</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.8"
>5.2.8&nbsp; <font color="#0000FF">How to Specify minOccurs and maxOccurs Schema Attributes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.9"
>5.2.9&nbsp; <font color="#0000FF">Combining a Client and Service into a Peer Application</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; <font color="#0000FF">How to Use gSOAP for One-Way SOAP Messaging</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; <font color="#0000FF">How to Separately Use the SOAP Serializers and Deserializers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.1"
>5.4.1&nbsp; <font color="#0000FF">Serializing a Data Type</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.2"
>5.4.2&nbsp; <font color="#0000FF">Deserializing a Data Type</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.3"
>5.4.3&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.4"
>5.4.4&nbsp; <font color="#0000FF">Default Values for Deserializing Omitted Data</font></a><br />
<a href="#tth_sEc6"
>6&nbsp; <font color="#0000FF">Using the gSOAP Stub and Skeleton Compiler</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; <font color="#0000FF">Compiler Options</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; <font color="#0000FF">Compiling a SOAP C++ Client</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; <font color="#0000FF">Compiling a SOAP C++ Web Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; <font color="#0000FF">Using gSOAP for Creating Web Services and Clients in C</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5"
>6.5&nbsp; <font color="#0000FF">Limitations of gSOAP</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.6"
>6.6&nbsp; <font color="#0000FF">gSOAP Serialization Options and Flags</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.7"
>6.7&nbsp; <font color="#0000FF">Memory Management</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.8"
>6.8&nbsp; <font color="#0000FF">Debugging</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.9"
>6.9&nbsp; <font color="#0000FF">Libraries</font></a><br />
<a href="#tth_sEc7"
>7&nbsp; <font color="#0000FF">The gSOAP Remote Method Specification Format</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; <font color="#0000FF">Remote Method Parameter Passing</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; <font color="#0000FF">Stub and Skeleton Routine Error Codes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; <font color="#0000FF">C++ Identifier Name to XML Element Name Translation</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; <font color="#0000FF">Namespace Mapping Table</font></a><br />
<a href="#tth_sEc8"
>8&nbsp; <font color="#0000FF">gSOAP Serialization and Deserialization Rules</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1"
>8.1&nbsp; <font color="#0000FF">Primitive Type Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2"
>8.2&nbsp; <font color="#0000FF">How to Encode and Decode Primitive Types as Built-In XML Schema Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.1"
>8.2.1&nbsp; <font color="#0000FF">How to Specify Multiple Storage Formats for a Single Primitive XML Schema Type</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.2"
>8.2.2&nbsp; <font color="#0000FF">How to Specify Polymorphic Primitive Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.3"
>8.2.3&nbsp; <font color="#0000FF">XML Schema Type Decoding Rules</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.4"
>8.2.4&nbsp; <font color="#0000FF">Multi-Reference Strings</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.5"
>8.2.5&nbsp; <font color="#0000FF">``Smart String'' Mixed-Content Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.6"
>8.2.6&nbsp; <font color="#0000FF">Changing the Encoding Precision of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.7"
>8.2.7&nbsp; <font color="#0000FF">INF, -INF, and NaN Values of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3"
>8.3&nbsp; <font color="#0000FF">Enumeration Type Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.1"
>8.3.1&nbsp; <font color="#0000FF">Symbolic Encoding of Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.2"
>8.3.2&nbsp; <font color="#0000FF">Literal Encoding of Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.3"
>8.3.3&nbsp; <font color="#0000FF">Initialized Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.4"
>8.3.4&nbsp; <font color="#0000FF">How to ``Reuse'' Symbolic Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.5"
>8.3.5&nbsp; <font color="#0000FF">Boolean Enumeration Type Encoding and Decoding for C Compilers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.6"
>8.3.6&nbsp; <font color="#0000FF">Bitmask Enumeration Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4"
>8.4&nbsp; <font color="#0000FF"><b>struct</b>&nbsp;Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5"
>8.5&nbsp; <font color="#0000FF"><b>class</b>&nbsp;Instance Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5.1"
>8.5.1&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5.2"
>8.5.2&nbsp; <font color="#0000FF">Initialized <b>static</b>&nbsp;<b>const</b>&nbsp;Fields</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5.3"
>8.5.3&nbsp; <font color="#0000FF">Class Methods</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5.4"
>8.5.4&nbsp; <font color="#0000FF">Polymorphism, Derived Classes, and Dynamic Binding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.6"
>8.6&nbsp; <font color="#0000FF">Pointer Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.6.1"
>8.6.1&nbsp; <font color="#0000FF">Multi-Reference Data</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.6.2"
>8.6.2&nbsp; <font color="#0000FF">NULL Pointers and Nil Elements</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.7"
>8.7&nbsp; <font color="#0000FF">Fixed-Size Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8"
>8.8&nbsp; <font color="#0000FF">Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.1"
>8.8.1&nbsp; <font color="#0000FF">One-Dimensional Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.2"
>8.8.2&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.3"
>8.8.3&nbsp; <font color="#0000FF">One-Dimensional Dynamic Arrays With Non-Zero Offset</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.4"
>8.8.4&nbsp; <font color="#0000FF">Nested One-Dimensional Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.5"
>8.8.5&nbsp; <font color="#0000FF">Multi-Dimensional Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.6"
>8.8.6&nbsp; <font color="#0000FF">Dynamic Array as List Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.7"
>8.8.7&nbsp; <font color="#0000FF">Polymorphic Dynamic Arrays and Lists</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.8"
>8.8.8&nbsp; <font color="#0000FF">How to Change the Tag Names of the Elements of a SOAP Array or List</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.8.9"
>8.8.9&nbsp; <font color="#0000FF">Embedded Arrays and Lists</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.9"
>8.9&nbsp; <font color="#0000FF">Base64Binary XML Schema Type Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.10"
>8.10&nbsp; <font color="#0000FF">hexBinary XML Schema Type Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.11"
>8.11&nbsp; <font color="#0000FF">Doc/Literal XML Encoding Style</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.11.1"
>8.11.1&nbsp; <font color="#0000FF">Serializing and Deserializing XML Into Strings</font></a><br />
<a href="#tth_sEc9"
>9&nbsp; <font color="#0000FF">SOAP Fault Processing</font></a><br />
<a href="#tth_sEc10"
>10&nbsp; <font color="#0000FF">SOAP Header Processing</font></a><br />
<a href="#tth_sEc11"
>11&nbsp; <font color="#0000FF">DIME Attachment Processing</font></a><br />
<a href="#tth_sEc12"
>12&nbsp; <font color="#0000FF">Advanced Features</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.1"
>12.1&nbsp; <font color="#0000FF">Internationalization</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.2"
>12.2&nbsp; <font color="#0000FF">Customizing the WSDL and Namespace Mapping Table File Contents</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.3"
>12.3&nbsp; <font color="#0000FF">Transient Data Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.4"
>12.4&nbsp; <font color="#0000FF">How to Declare User-Defined Serializers and Deserializers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.5"
>12.5&nbsp; <font color="#0000FF">How to Serialize Data Without XML   plus3 <tt>xsi:type</tt> Attributes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.6"
>12.6&nbsp; <font color="#0000FF">Function Callbacks for Customized I/O and HTTP Handling</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.7"
>12.7&nbsp; <font color="#0000FF">HTTP 1.0 and 1.1</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.8"
>12.8&nbsp; <font color="#0000FF">HTTP Keep-Alive</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.9"
>12.9&nbsp; <font color="#0000FF">HTTP Chunked Transfer Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.10"
>12.10&nbsp; <font color="#0000FF">Timeout Management for Non-Blocking Operations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.11"
>12.11&nbsp; <font color="#0000FF">Secure SOAP Clients with HTTPS/SSL</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.12"
>12.12&nbsp; <font color="#0000FF">Secure SOAP Web Services with HTTPS/SSL</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.13"
>12.13&nbsp; <font color="#0000FF">Client-Side Cookie Support</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.14"
>12.14&nbsp; <font color="#0000FF">Server-Side Cookie Support</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.15"
>12.15&nbsp; <font color="#0000FF">Connecting Clients Through Proxy Servers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.16"
>12.16&nbsp; <font color="#0000FF">FastCGI Support</font></a><br />
 
</td></tr></table><br></span>
<i>Copyright (C) Robert A. van Engelen 2000-2002, all rights reserved.</i>


<p>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;<font color="#0000FF">Introduction</font></h2>

<p>
The gSOAP toolkit provides a unique SOAP-to-C/C++ language binding for the development of SOAP Web Services and clients.
Other SOAP C++ implementations adopt a SOAP-centric view and offer SOAP APIs for C++ that require the use of class libraries for
SOAP-like data structures.  This often forces a user to adapt the application logic to these libraries.  In contrast, gSOAP
provides a C/C++ transparent SOAP API through the use of compiler technology that hides irrelevant SOAP-specific details from
the user.  The gSOAP stub and skeleton compiler automatically maps native and user-defined C and C++ data types to semantically
equivalent SOAP data types and vice-versa.  As a result, full SOAP interoperability is achieved with a simple API relieving the
user from the burden of SOAP details and enables him or her to concentrate on the application-essential logic.  The compiler
enables the integratation of (legacy) C/C++ and Fortran codes (through a Fortran-to-C interface), embedded systems, and
real-time software in SOAP applications that share computational resources and information with other SOAP applications,
possibly across different platforms, language environments, and disparate organizations located behind firewalls.

<p>
gSOAP minimizes application adaptation for building SOAP clients and Web Services.  The gSOAP compiler generates SOAP marshalling
routines that (de)serialize application-specific C/C++ data structures.  gSOAP includes a WSDL generator to generate Web service
descriptions for your Web services.  The gSOAP WSDL importer "closes the circle" in that it enables client development without the need
for users to analyze Web service details to implement a client.

<p>
Some of the highlights of gSOAP are:

<ul><p>
<li>Unique interoperability features: the gSOAP compiler generates SOAP marshalling routines that (de)serialize native and
user-defined C/C++ data structures.  gSOAP is also one of the few SOAP toolkits that support the full range of SOAP 1.1 features
including multi-dimensional arrays and polymorphic types. For example, a remote method with a base class parameter may accept
derived class instances from a client. Derived class instances keep their identity through dynamic binding.</li>
<p>
<li>
gSOAP includes a WSDL generator for convenient Web Service publishing.</li>
<p>
<li>
gSOAP includes a WSDL importer for automated client development.</li>
<p>
<li>
Generates source code for stand-alone Web Services and clients.</li>
<p>
<li>
Ideal for building web services that are compute-intensive and are therefore best written in C and C++.</li>
<p>
<li>
Platform independent: Windows, Unix, Linux, Pocket PC, etc.</li>
<p>
<li>
Fast <em>in situ</em> serialization and deserialization with SOAP encoding of arbitrary user-defined and built-in C and C++ data
structures.</li>
<p>
<li>
Fully SOAP 1.1 compliant data encoding and decoding. (Also SOAP 1.2 compliant, except for header faults, SOAP actors, SOAP root.)</li>
<p>
<li>
DIME compliant attachments.</li>
<p>
<li>
The schema-specific XML pull parser is fast and efficient and does not require intermediate data storage for
demarshalling to save space and time.</li>
<p>
<li>
Selective input and output buffering is used to increase efficiency, but full message buffering to determine HTTP message length
is not used. Instead, a three-phase serialization method is used to determine message length. As a result, large data sets
such as base64-encoded images can be transmitted with or without DIME attachments by small-memory devices such as PDAs.</li>
<p>
<li>
Supports C++ single class inheritance, dynamic binding, overloading, arbitrary pointer structures such as lists, trees, graphs,
cyclic graphs, fixed-size arrays, (multi-dimensional) dynamic arrays, enumerations, built-in XML schema types including
base64Binary encoding, and hexBinary encoding.</li>
<p>
<li>
No need to rewrite existing C/C++ applications for Web service deployment. However, parts of an application that use unions,
pointers to sequences of elements in memory, and <i><b>void</b>*</i> need to be modified, but <b>only</b> if the data structures that
adopt them are required to be serialized or deserialized as part of a remote method invocation.</li>
<p>
<li>
Three-phase marshalling: 1) analysis of pointers, single-reference, multi-reference, and cyclic data structures, 2) HTTP
message-length determination, and 3) serialization as per SOAP 1.1 encoding style or user-defined encoding styles.</li>
<p>
<li>
Two-phase demarshalling: 1) SOAP parsing and decoding, which involves the reconstruction of multi-reference and cyclic data
structures from the payload, and 2) resolution of "forward" pointers (i.e. resolution of the forward <tt>href</tt> attributes in SOAP).</li>
<p>
<li>
Full and customizable SOAP Fault processing (client receive and service send).</li>
<p>
<li>
Customizable SOAP Header processing (send and receive), which for example enables easy transaction processing for the service to
keep state information.</li>
</ul>

<p>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;<font color="#0000FF">Notational Conventions</font></h2>

<p>
The typographical conventions used by this document are:

<dl compact="compact">
 <dt><b><span class="roman"><i>Sans serif or italics font</i></b></dt>
	<dd> Denotes C and C++ source code, file names, and commands.</span></dd>
 <dt><b><i><b>Bold font</b></i></b></dt>
	<dd> Denotes C and C++ keywords.</dd>
 <dt><b><tt>Courier font</tt></b></dt>
	<dd> Denotes HTTP header content, HTML, XML, and XML schema fragments.</dd>
 <dt><b><span class="roman"><font size="+1"><span class="roman">[</span></font>Optional<font size="+1"><span class="roman">]</span></font></b></dt>
	<dd> Denotes an optional construct.</span></dd>
</dl>

<p>
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in RFC-2119.

<p>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;<font color="#0000FF">Differences Between gSOAP Versions 1.X and 2.X</font></h2>

<p>
gSOAP versions 2.0 and higher are redesigned and thread-safe.
All files in the gSOAP 2.X distribution are renamed to avoid confusion with gSOAP version 1.X files:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>gSOAP 1.X</b></font>	</td><td><font color="#FF0000"><b>gSOAP 2.X</b></font> </td></tr>
<tr><td>soapcpp		</td><td>soapcpp2 </td></tr>
<tr><td>soapcpp.exe	</td><td>soapcpp2.exe </td></tr>
<tr><td>stdsoap.h	</td><td>stdsoap2.h </td></tr>
<tr><td>stdsoap.c	</td><td>stdsoap2.c </td></tr>
<tr><td>stdsoap.cpp	</td><td>stdsoap2.cpp </td></tr></table>

</td></tr></table><br></span>
Changing the version 1.X application codes to accomodate gSOAP 2.X does not require a significant amount of recoding.
The change to gSOAP 2.X affects all functions defined in <i>stdsoap2.c[pp]</i> (the gSOAP runtime environment API) and the functions in the
sources generated by the gSOAP compiler (the gSOAP RPC+marshalling API).
Therefore, clients and services developed with gSOAP 1.X need to be modified to accomodate a change in the calling convention used in 2.X:
In 2.X, <b>all</b> gSOAP functions (including the remote method proxy routines) take an additional parameter which is an instance of the gSOAP runtime
environment that includes file descriptors, tables, buffers, and flags.
This additional parameter is <b>always</b> the first parameter of any gSOAP function.

<p>
The gSOAP runtime environment is stored in a <i><b>struct</b>&nbsp;soap</i> type. A <i><b>struct</b></i> was chosen to support application development in
C without the need for a separate gSOAP implementation.  An object-oriented approach with a class for the gSOAP runtime environment would have prohibited the implementation of pure C applications.
Before a client can invoke remote methods or before a service can accept requests, a runtime environment need to be allocated and
initialized.
Two new functions are added to gSOAP 2.X:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_init(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Initializes a runtime environment (required only once) </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_new()</i> </td><td>Allocates, initializes, and returns a pointer to a runtime environment </td></tr></table>

</td></tr></table><br></span>
An environment can be reused as many times as necessary and does not need to be reinitialized in doing so.
A new environment is only required for each new thread to guarantee exclusive access
to a new runtime environment by each thread.
For example, the following code stack-allocates the runtime environment which is used for multiple remote method calls:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // initialize runtime environment <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method1(&amp;soap, ...); // make a remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method2(&amp;soap, ...); // make another remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // clean up <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
The runtime environment can also be heap allocated:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap = soap_new(); // allocate and initialize runtime environment <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap) // couldn't allocate: stop <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method1(soap, ...); // make a remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method2(soap, ...); // make another remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end(soap); // clean up <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;free(soap); // deallocate runtime environment <br />
}
</td></tr></table><br></i>
A service need to allocate and initialize an environment before calling <i>soap_serve</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
}
</td></tr></table><br></i>
Or alternatively:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
}
</td></tr></table><br></i>
A service can use multi-threading to handle requests while running some other code that invokes remote methods:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap1, soap2; <br />
&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap1); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_bind(&amp;soap1, host, port, backlog)  &lt;  0) exit(-1); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_accept(&amp;soap1)  &lt;  0) exit(-1); <br />
&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, (<b>void</b>*(*)(<b>void</b>*))soap_serve, (<b>void</b>*)&amp;soap1]); <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap2); <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method(&amp;soap2, ...); // make a remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap2); <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;pthread_join(tid); // wait for thread to terminate <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap1); // release its data <br />
}
</td></tr></table><br></i>
In the example above, two runtime environments are required.
In comparison, gSOAP 1.X statically allocates the runtime environment, which prohibits multi-threading (only one thread can invoke
remote methods and/or accept requests due to the single runtime environment).

<p>
Section&nbsp;<a href="#sec:mt">5.2.3</a> presents a multi-threaded stand-alone Web Service that handles multiple SOAP requests by spawning a thread for each request.

<p>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;<font color="#0000FF">Interoperability</font></h2>

<p>
gSOAP interoperability has been verified with the following SOAP implementations and toolkits:

<dl compact="compact">
 <dt><b>Apache 2.2</b></dt>
	<dd></dd>
 <dt><b>Apache Axis</b></dt>
	<dd></dd>
 <dt><b>ASP.NET</b></dt>
	<dd></dd>
 <dt><b>Cape Connect</b></dt>
	<dd></dd>
 <dt><b>Delphi</b></dt>
	<dd></dd>
 <dt><b>easySOAP++</b></dt>
	<dd></dd>
 <dt><b>eSOAP</b></dt>
	<dd></dd>
 <dt><b>Frontier</b></dt>
	<dd></dd>
 <dt><b>GLUE</b></dt>
	<dd></dd>
 <dt><b>Iona XMLBus</b></dt>
	<dd></dd>
 <dt><b>kSOAP</b></dt>
	<dd></dd>
 <dt><b>MS SOAP</b></dt>
	<dd></dd>
 <dt><b>Phalanx</b></dt>
	<dd></dd>
 <dt><b>SIM</b></dt>
	<dd></dd>
 <dt><b>SOAP::Lite</b></dt>
	<dd></dd>
 <dt><b>SOAP4R</b></dt>
	<dd></dd>
 <dt><b>Spray</b></dt>
	<dd></dd>
 <dt><b>SQLData</b></dt>
	<dd></dd>
 <dt><b>Wasp Adv.</b></dt>
	<dd></dd>
 <dt><b>Wasp C++</b></dt>
	<dd></dd>
 <dt><b>White Mesa</b></dt>
	<dd></dd>
 <dt><b>xSOAP</b></dt>
	<dd></dd>
 <dt><b>ZSI</b></dt>
	<dd></dd>
 <dt><b>4S4C</b></dt>
	<dd></dd>
</dl>

<p>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;<font color="#0000FF">Quick User Guide</font></h2>

<p>
This user guide offers a quick way to get started with gSOAP.  This section requires a basic understanding of the SOAP 1.1
protocol and some familiarity with C and/or C++. In principle, SOAP clients and SOAP Web services can be developed in C and C++
with the gSOAP stub and skeleton compiler without a detailed understanding of the SOAP protocol when the applications
are build as an ensamble and only communicate within this group (i.e. meaning that you don't have to worry about
interoperability with other SOAP implementations).  This section is intended to illustrate the implementation of SOAP C/C++ Web
services and clients that connect to other existing SOAP implementations such as Apache SOAP and SOAP::Lite for which some
details of the SOAP protocol need to be understood.

<p>
	     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;<font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Clients</font></h3><a name="sec:client">
</a>

<p>
In general, the implementation of a SOAP client application requires a <b>stub</b> routine for each remote method that the client
application needs to invoke.  The primary stub's responsibility is to marshall the input data, send the request to the designated
SOAP service over the wire, to wait for the response, and to demarshall the output data when it arrives. The client application
invokes the stub routine for a remote method as if it would invoke a local method.  To write a stub routine in C or C++ by hand is
a tedious task, especially if the input and/or output data structures of a remote method are complex data types such as records,
arrays, and graphs.

<p>
The generation of stub routines for a SOAP client is fully automated with gSOAP.  The gSOAP stub and skeleton compiler is a <b>
preprocessor</b> that generates the necessary C++ sources to build SOAP C++ clients. The input to the gSOAP stub and skeleton
compiler consists of a standard C/C++ <b>header file</b>.  The header file can be generated from a WSDL (Web Service
Description Language) documentation of a service with the gSOAP WSDL importer, see&nbsp;<a href="#sec:wsdlin">5.2.7</a>.  The SOAP remote methods are specified in this header file as <b>function prototypes</b>. Stub routines in
C/C++ source form are automatically generated by the gSOAP compiler for these function prototypes of remote methods.  The
resulting stub routines allow C and C++ client applications to seamlessly interact with existing SOAP Web services.

<p>
The gSOAP stub and skeleton compiler also generates <b>skeleton</b> routines for each of the remote methods specified in the header
file. The skeleton routines can be readily used to implement one or more of the remote methods in a new SOAP Web service. These
skeleton routines are not used for building SOAP clients in C++, although they can be used to build mixed SOAP client/server
applications (peer applications).

<p>
The input and output parameters of a SOAP remote method may be simple data types or complex data types.  The necessary <b>type
declarations</b> of C/C++ user-defined data structures such as structs, classes, enumerations, arrays, and pointer-based data
structures (graphs) are to be provided in the header file.  The gSOAP stub and skeleton compiler automatically generates <b>
serializers</b> and <b>deserializers</b> for the data types to enable the generated stub routines to encode and decode the contents of
the parameters of the remote methods.

<p>
The remote method name and its parameterization can be found with a SOAP Web service description, typically in the form of an XML
schema. There is an almost one-to-one correspondence between the XML schema description of a SOAP remote method and the C++ type
declarations required to build a client application for the Web service. The schemas are typically part of the WSDL  specification of a SOAP Web service.  The gSOAP WSDL importer converts WSDL service descriptions into header files.

<p>
		      <h4><a name="tth_sEc5.1.1">
5.1.1</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example1">
</a>

<p>
The <i>getQuote</i> remote method of XMethods Delayed Stock Quote service provides a delayed stock quote for a given ticker name,
see <a href="http://xmethods.com/detail.html?id=2"><tt>http://xmethods.com/detail.html?id=2</tt></a> for details. The WSDL description of the Delayed Stock Quote service provides the
following details:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td>Endpoint URL: </td><td><tt>http://services.xmethods.net:80/soap</tt> </td></tr>
<tr><td>SOAP action: </td><td>"" (2 quotes) </td></tr>
<tr><td>Remote method namespace: </td><td><tt>urn:xmethods-delayed-quotes</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>getQuote</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameter: </td><td><tt>symbol</tt> of type <tt>xsd:string</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>Result</tt> of type <tt>xsd:float</tt>
</td></tr></table>

</td></tr></table><br></span>
The following <i>getQuote.h</i> <b>header file</b> is created from the WSDL description with the WSDL importer:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Content of file <tt>"getQuote.h"</tt>: <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The header file essentially specifies the remote method in C++.
The remote method is declared as a <i>ns1__getQuote</i> <b>function prototype</b> which specifies all of the necessary details for
the gSOAP compiler to generate the stub routine for a client application to interact with the Delayed Stock Quote service.

<p>
The Delayed Stock Quote service description requires that the <b>input parameter</b> of the <i>getQuote</i> remote method is a
<i>symbol</i> parameter of type string. The description also indicates that the <i>Result</i> <b>output parameter</b> is a floating
point number that represents the current unit price of the stock in dollars. The gSOAP compiler uses the convention the <b>last
parameter</b> of the function prototype must be the output parameter of the remote method, which is required to be passed by
reference using the reference operator (<i>&amp;</i>) or by using a pointer type. All other parameters except the last are input
parameters of the remote method, which are required to be passed by value or passed using a pointer to a value (by reference is
not allowed). The function prototype associated with a remote method is required to return an <i><b>int</b></i>, whose value indicates to
the caller whether the connection to a SOAP Web service was successful or resulted in an exception, see Section&nbsp;<a href="#sec:errcodes">7.2</a>
for the error codes. 

<p>
The use of the namespace prefix <i>ns1__</i> in the remote method name in the function prototype declaration is discussed in
detail in&nbsp;<a href="#sec:namespace">5.1.2</a>.  Basically, a namespace prefix is distinghuished by a <b>pair of underscores</b> in the function
name, as in <i>ns1__getQuote</i> where <i>ns1</i> is the namespace prefix and <i>getQuote</i> is the remote method name.  (A single
underscore in an identifier name will be translated to a dash in the XML output, see Section&nbsp;<a href="#sec:idtrans">7.3</a>.)

<p>
The gSOAP compiler is invoked from the command line with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 getQuote.h</i>
</td></tr></table><br></span>
The compiler generates the stub routine for the <i>getQuote</i> remote method specified in the <i>getQuote.h</i> header file. This
stub routine can be called by a client program at any time to request a stock quote from the Delayed Stock Quote service. The
interface to the generated stub routine is called a <b>proxy</b>, which is the following function generated by the gSOAP
compiler:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_call_ns1__getQuote(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*URL, <b>char</b>&nbsp;*action, <b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The stub routine of the proxy is saved in <i>soapClient.cpp</i>. The file <i>soapC.cpp</i> contains the <b>serializer</b> and <b>
deserializer</b> routines for the data types used by the stub.

<p>
Note that the parameters of the <i>soap_call_ns1__getQuote</i> proxy are identical to the
<i>ns1__getQuote</i> function prototype with three additional input parameters: <i>soap</i> must be a valid pointer to a gSOAP
runtime environment, <i>URL</i> is the SOAP Web service <b>endpoint URL</b>
passed as a string, and <i>action</i> is a string that denotes the <b>SOAP action</b> required by the Web service.

<p>
The following example C++ client program invokes the proxy to retrieve the latest AOL stock quote from the XMethods Delayed Stock
Quote service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include <tt>"soapH.h"</tt> // obtain the generated proxy <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; // gSOAP runtime environment <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;quote; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // initialize runtime environment (only once) <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ns1__getQuote(&amp;soap, <tt>"http://services.xmethods.net:80/soap"</tt>, <tt>""</tt>, <tt>"AOL"</tt>, quote) == SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "Current AOL Stock Quote = "  &lt;&lt;  quote; <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;// an error occurred <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); // display the SOAP fault message on the stderr stream <br />
soap_end(&amp;soap); // clean up <br />
}
</td></tr></table><br></i>
The XMethods Delayed Stock Quote service endpoint URL is <tt>http://services.xmethods.net/soap</tt> port 80 and the SOAP action required
is <tt>""</tt> (two quotes).  If successful, the proxy returns <i>SOAP_OK</i> and <i>quote</i> contains the latest stock quote.
Otherwise, an error occurred and the SOAP fault is displayed with the <i>soap_print_fault</i> function.

<p>

<p>
When the example client application is invoked, the SOAP request is performed by the proxy routine <i>soap_call_ns1__getQuote</i>, which
generates the following SOAP request message:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /soap HTTP/1.1 <br />
Host: services.xmethods.net <br />
Content-Type: text/xml <br />
Content-Length: 529 <br />
SOAPAction: "" <br />
<br />
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns1="urn:xmethods-delayed-quotes" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;ns1:getQuote&#62; <br />
&lt;symbol&#62;AOL&lt;/symbol&#62; <br />
&lt;/ns1:getQuote&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
The XMethods Delayed Stock Quote service responds with the SOAP response message:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
HTTP/1.1 200 OK <br />
Date: Sat, 25 Aug 2001 19:28:59 GMT <br />
Content-Type: text/xml <br />
Server: Electric/1.0 <br />
Connection: Keep-Alive <br />
Content-Length: 491 <br />
<br />
&lt;?xml version='1.0' encoding='UTF-8'?&#62; <br />
&lt;soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance' <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd='http://www.w3.org/1999/XMLSchema' <br />
&nbsp;&nbsp;&nbsp;xmlns:soapenc='http://schemas.xmlsoap.org/soap/encoding/' <br />
&nbsp;&nbsp;&nbsp;soap:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'&#62; <br />
&lt;soap:Body&#62; <br />
&lt;n:getQuoteResponse xmlns:n='urn:xmethods-delayed-quotes'&#62; <br />
&lt;Result xsi:type='xsd:float'&#62;41.81&lt;/Result&#62; <br />
&lt;/n:getQuoteResponse&#62; <br />
&lt;/soap:Body&#62; <br />
&lt;/soap:Envelope&#62;
</td></tr></table><br></tt>
The server's response is parsed by the stub routine of the proxy of the client. The stub routine further demarshalls the data of <tt>Result</tt>
element of the SOAP response and stores it in the <i>quote</i> parameter of <i>soap_call_ns1__getQuote</i>.

<p>
A client program can invoke a remote method at any time and multiple times if necessary. Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
<b>struct</b>&nbsp;soap soap; <br />
<b>float</b>&nbsp;quotes[3]; char *myportfolio[] = {<tt>"IBM"</tt>, <tt>"AOL"</tt>, <tt>"MSDN"</tt>}; <br />
soap_init(&amp;soap); // need to initialize only once <br />
<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 0; i  &lt;  3; i++) <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ns1__getQuote(&amp;soap, <tt>"http://services.xmethods.net:80/soap"</tt>, <tt>""</tt>, myportfolio[i], quotes[i]) != SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
<b>if</b>&nbsp;(soap.error) // an error occurred <br />
&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
soap_end(&amp;soap); // clean up all deserialized data <br />
...
</td></tr></table><br></i>
This client composes an array of stock quotes by calling the <i>ns1__getQuote</i> proxy for each symbol in a portfolio array.

<p>
This example demonstrated how easy it is to build a SOAP client with gSOAP once the details of a Web service are available 
in the form of a WSDL document.

<p>
		      <h4><a name="tth_sEc5.1.2">
5.1.2</a>&nbsp;&nbsp;<font color="#0000FF">Namespace Considerations</font></h4><a name="sec:namespace">
</a>

<p>
The declaration of the <i>ns1__getQuote</i> function prototype (discussed in the previous section) uses the namespace prefix
<i>ns1__</i> of the remote method namespace, which is distinghuished by a <b>pair of underscores</b> in the function name to
separate the namespace prefix from the remote method name.  The purpose of a namespace prefix is to associate a remote
method name with a service in order to prevent naming conflicts, e.g.&nbsp;to distinguish identical remote method names used
by different services.

<p>
Note that the XML response of the XMethods Delayed Stock Quote service example uses the <b>namespace prefix</b> <tt>n</tt> which is
associated with the <b>namespace URI</b> <tt>urn:xmethods-delayed-quotes</tt> through the <tt>xmlns:n="urn:xmethods-delayed-quotes</tt>
binding.  The use of namespace prefixes and namespace URIs is also required to enable SOAP applications to validate the content of
a client's request and vice versa.  The namespace URI in the service response is verified by the stub routine by using the
information supplied in a <b>namespace mapping table</b> that is required to be part of the client program.  The table is accessed
at run time to resolve namespace bindings, both by the generated stub's data structure serializer for encoding the client request
and by the generated stub's data structure deserializer to decode and validate the service response. The namespace mapping table
should not be part of the header file input to the gSOAP stub and skeleton compiler.

<p>
The namespace mapping table for the Delayed Stock Quote client is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{<font color="#FF0000">"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"</font>}, // MUST be first <br />
&nbsp;&nbsp;&nbsp;{<font color="#0000FF">"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"</font>}, // MUST be second <br />
&nbsp;&nbsp;&nbsp;{<font color="#FF00FF">"xsi",      "http://www.w3.org/2001/XMLSchema-instance"</font>}, // MUST be third <br />
&nbsp;&nbsp;&nbsp;{<font color="#00FFFF">"xsd",      "http://www.w3.org/2001/XMLSchema"</font>}, // 2001 XML schema <br />
&nbsp;&nbsp;&nbsp;{<font color="#00FF00">"ns1",      "urn:xmethods-delayed-quotes"</font>}, // given by the service description <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} // end of table <br />
};
</td></tr></table><br></i> 
The first four namespace entries in the table consist of the standard namespaces used by the SOAP 1.1 protocol. In fact, the
namespace mapping table is explicitly declared to enable a programmer to specify the SOAP encoding style and to allow the
inclusion of namespace-prefix with namespace-name bindings to comply to the namespace requirements of a specific SOAP service. For
example, the namespace prefix <tt>ns1</tt>, which is bound to <tt>urn:xmethods-delayed-quotes</tt> by the namespace mapping table shown
above, is used by the generated stub routine to encode the <i>getQuote</i> request. This is performed automatically by the gSOAP
compiler by using the <i>ns1</i> prefix of the <i>ns1__getQuote</i> method name specified in the <i>getQuote.h</i> header file. In
general, if a function name of a remote method, <i><b>struct</b></i> name, <i><b>class</b></i> name, <i><b>enum</b></i> name, or field name of a
<i><b>struct</b></i> or <i><b>class</b></i> has a pair of underscores, the name has a namespace prefix that must be defined in the namespace
mapping table.

<p>
The namespace mapping table will be output as part of the SOAP Envelope by the stub routine. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope xmlns:<font color="#FF0000">SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#0000FF">SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#FF00FF">xsi="http://www.w3.org/1999/XMLSchema-instance"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#00FFFF">xsd="http://www.w3.org/1999/XMLSchema"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#00FF00">ns1="urn:xmethods-delayed-quotes"</font> <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle=<font color="#0000FF">"http://schemas.xmlsoap.org/soap/encoding/"</font>&#62; <br />
...
</td></tr></table><br></tt>
The namespace bindings will be used by a SOAP service to validate the SOAP request.

<p>
		      <h4><a name="tth_sEc5.1.3">
5.1.3</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example2">
</a>

<p>
The incorporation of namespace prefixes into C++ identifier names is necessary to distinguish remote methods that
share the same name but are implemented in different Web services. Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "getQuote.h": <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result); <br />
<b>int</b>&nbsp;ns2__getQuote(<b>char</b>&nbsp;*ticker, <b>char</b>&nbsp;*&amp;quote);
</td></tr></table><br></i>
The namespace prefix is separated from the remote method names by a pair of underscores (<i>__</i>) by convention.

<p>
This example enables a client program to connect to a (hypothetical) Stock Quote service with remote methods that can only be
distinghuished by their namespaces. Consequently, two different namespace prefixes have been used as part of the remote method
names.

<p>
The namespace prefix convention can also be applied to <i><b>class</b></i> declarations that contain SOAP compound values
that share the same name but have different namespaces that refer to different XML schemas. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;<font color="#FF0000">e__Address</font> // an electronic address <br />
{ <br />
&nbsp;&nbsp;&nbsp;char *email; <br />
&nbsp;&nbsp;&nbsp;char *url; <br />
}; <br />
<b>class</b>&nbsp;<font color="#0000FF">s__Address</font> // a street address <br />
{ <br />
&nbsp;&nbsp;&nbsp;char *street; <br />
&nbsp;&nbsp;&nbsp;int number; <br />
&nbsp;&nbsp;&nbsp;char *city; <br />
};
</td></tr></table><br></i>
The namespace prefix is separated from the data type names by a pair of underscores (<i>__</i>) by convention.

<p>
An instance of <i><font color="#FF0000">e__Address</font></i> is encoded by the generated serializer for this type as an Address element with namespace prefix <i><font color="#FF0000">e</font></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font color="#FF0000">e:Address</font> xsi:type="<font color="#FF0000">e:Address</font>"&#62; <br />
&lt;email xsi:type="string"&#62;me@home&lt;/email&#62; <br />
&lt;url xsi:type="string"&#62;www.me.com&lt;/url&#62; <br />
&lt;/<font color="#FF0000">e:Address</font>&#62;
</td></tr></table><br></tt>
While an instance of <i><font color="#0000FF">s__Address</font></i> is encoded by the generated serializer for this type as an Address element with namespace prefix <i><font color="#0000FF">s</font></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font color="#0000FF">s:Address</font> xsi:type="<font color="#0000FF">s:Address</font>"&#62; <br />
&lt;street xsi:type="string"&#62;Technology Drive&lt;/street&#62; <br />
&lt;number xsi:type="int"&#62;5&lt;/number&#62; <br />
&lt;city xsi:type="string"&#62;Softcity&lt;/city&#62; <br />
&lt;/<font color="#0000FF">s:Address</font>&#62;
</td></tr></table><br></tt>
The namespace mapping table of the client program must have entries for <i><font color="#FF0000">e</font></i> and <i><font color="#0000FF">s</font></i> that refer to the XML schemas of the data types:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;{"<font color="#FF0000">e</font>", "http://www.me.com/schemas/electronic-address"}, <br />
&nbsp;&nbsp;&nbsp;{"<font color="#0000FF">s</font>", "http://www.me.com/schemas/street-address"}, <br />
...
</td></tr></table><br></i> 
This table is required to be part of the client application to allow access by the serializers and deserializers of the data types at run time.

<p>
		      <h4><a name="tth_sEc5.1.4">
5.1.4</a>&nbsp;&nbsp;<font color="#0000FF">Some SOAP Encoding Considerations</font></h4><a name="sec:encoding">
</a>

<p>
Many SOAP services require the explicit use of XML schema types in the SOAP payload. The default encoding, which is also adopted
by the gSOAP stub and skeleton compiler, assumes SOAP encoding. This can be easily changed by using <i><b>typedef</b></i> definitions in
the header file input to the gSOAP compiler. The type name defined by a <i><b>typedef</b></i> definition corresponds to an XML schema
type and may include an optional namespace prefix. For example, the following <i><b>typedef</b></i> declarations, when part of the header
file input to the gSOAP compiler, defines various built-in XML schema types implemented as primitive C/C++ types:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of header file: <br />
... <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; // encode xsd__string value as the <span class="roman"><tt>xsd:string</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI; // encode xsd__anyURI value as the <span class="roman"><tt>xsd:anyURI</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; // encode xsd__float value as the <span class="roman"><tt>xsd:float</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int; // encode xsd__int value as the <span class="roman"><tt>xsd:int</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;xsd__boolean; // encode xsd__boolean value as the <span class="roman"><tt>xsd:boolean</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__positiveInteger; // encode xsd__positiveInteger value as the <span class="roman"><tt>xsd:positiveInteger</tt></span>  schema type<br />
...
</td></tr></table><br></i>
This simple mechanism informs the gSOAP compiler to generate serializers and deserializers that explicitly encode and decode the
primitive C++ types as built-in primitive XML schema types when the <i>typedef</i>ed type is used in the parameter signature of a
remote method (or when used nested within structs, classes, and arrays).  At the same time, the use of <i><b>typedef</b></i> 
does not force any recoding of a C++ client or Web service application as the internal C++ types used by the application
are not required to be changed (but still have to be primitive C++ types, see Section&nbsp;<a href="#sec:primclass">8.2.2</a> for alternative class
implementations of primitive XML schema types which allows for the marshalling of polymorphic primitive SOAP types).

<p>
		      <h4><a name="tth_sEc5.1.5">
5.1.5</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example3">
</a>

<p>
Reconsider the <i>getQuote</i> example, now rewritten with explicit XML schema types to illustrate the effect:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*<font color="#FF0000">xsd__string</font>; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;<font color="#0000FF">xsd__float</font>; <br />
<b>int</b>&nbsp;<font color="#00FF00">ns1__getQuote</font>(<font color="#FF0000">xsd__string</font> <font color="#FF00FF">symbol</font>, <font color="#0000FF">xsd__float</font> &amp;<font color="#00FFFF">Result</font>);
</td></tr></table><br></i>
This header file is compiled by the gSOAP stub and skeleton compiler and the compiler generates source code for the function
<i>soap_call_ns1__getQuote</i>, which is identical to the ``old'' proxy:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_call_ns1__getQuote(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*URL, <b>char</b>&nbsp;*action, <b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The client application does not need to be rewritten and can still call the proxy using the ``old'' parameter signature. In contrast to
the previous implementation of the stub however, the encoding and decoding of the data types by the stub has been changed to
explicitly use the schema types.

<p>
For example, when the client application calls the proxy, the proxy produces a SOAP request with <tt>xsd:string</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;<font color="#00FF00">ns1:getQuote</font>&#62;&lt;<font color="#FF00FF">symbol</font> xsi:type="<font color="#FF0000">xsd:string</font>"&#62;AOL&lt;/<font color="#FF00FF">symbol</font>&#62; <br />
&lt;/<font color="#00FF00">ns1:getQuote</font>&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
...
</td></tr></table><br></tt>
The service response is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;soap:Body&#62; <br />
&lt;<font color="#00FF00">n:getQuote</font>Response xmlns:n='urn:xmethods-delayed-quotes'&#62; <br />
&lt;<font color="#00FFFF">Result</font> xsi:type='<font color="#0000FF">xsd:float</font>'&#62;41.81&lt;/<font color="#00FFFF">Result</font>&#62; <br />
&lt;/<font color="#00FF00">n:getQuote</font>Response&#62; <br />
&lt;/soap:Body&#62; <br />
...
</td></tr></table><br></tt>
The validation of this service response by the stub routine takes place by matching the namespace URIs that are bound to the
<tt>xsd</tt> namespace prefix. The stub also expects the <tt>getQuoteResponse</tt> element to be associated with namespace URI
<tt>urn:xmethods-delayed-quotes</tt> through the binding of the namespace prefix <tt>ns1</tt> in the namespace mapping table. The
service response uses namespace prefix <tt>n</tt> for the <tt>getQuoteResponse</tt> element. This namespace prefix is bound to the same
namespace URI <tt>urn:xmethods-delayed-quotes</tt> and therefore the service response is assumed to be valid.  The response is
rejected and a SOAP fault is generated if the namespace URIs do not match.

<p>
		      <h4><a name="tth_sEc5.1.6">
5.1.6</a>&nbsp;&nbsp;<font color="#0000FF">How to Change the Response Element Name</font></h4><a name="sec:response">
</a>

<p>
There is no explicit standard convention for the response element name in SOAP, although it is recommended that the response
element name is the method name ending with ``<tt>Response</tt>''. For example, the response element of <tt>getQuote</tt> is
<tt>getQuoteResponse</tt>.

<p>
The response element name can be specified explicitly using a <i><b>struct</b></i> or <i><b>class</b></i> declaration in the header file. The
<i><b>struct</b></i> or <i><b>class</b></i> name represents the SOAP response element name used by the service. Consequently, the output
parameter of the remote method must be declared as a field of the <i><b>struct</b></i> or <i><b>class</b></i>.  The use of a <i><b>struct</b></i> or a
<i><b>class</b></i> for the service response is fully SOAP 1.1 compliant. In fact, the absence of a <i><b>struct</b></i> or <i><b>class</b></i>
indicates to the gSOAP compiler to automatically generate a <i>struct</i> for the response which is internally used by a stub.

<p>
		      <h4><a name="tth_sEc5.1.7">
5.1.7</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example4">
</a>

<p>
Reconsider the <i>getQuote</i> remote method specification which can be rewritten with an explicit declaration of a SOAP response
element as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*<font color="#FF0000">xsd__string</font>; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;<font color="#0000FF">xsd__float</font>; <br />
<b>struct</b>&nbsp;<font color="#FFFF00">ns1__getQuoteResponse</font> {<font color="#0000FF">xsd__float</font> <font color="#00FFFF">Result</font>;}; <br />
<b>int</b>&nbsp;<font color="#00FF00">ns1__getQuote</font>(<font color="#FF0000">xsd__string</font> <font color="#FF00FF">symbol</font>, <b>struct</b>&nbsp;<font color="#FFFF00">ns1__getQuoteResponse</font> &amp;r);
</td></tr></table><br></i>
The SOAP request is the same as before:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;<font color="#00FF00">ns1:getQuote</font>&#62;&lt;<font color="#FF00FF">symbol</font> xsi:type="<font color="#FF0000">xsd:string</font>"&#62;AOL&lt;/<font color="#FF00FF">symbol</font>&#62; <br />
&lt;/<font color="#00FF00">ns1:getQuote</font>&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
...
</td></tr></table><br></tt>
The difference is that the service response is required to match the specified <i>getQuoteResponse</i> name and its namespace URI:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;soap:Body&#62; <br />
&lt;<font color="#FFFF00">n:getQuoteResponse</font> xmlns:n='urn:xmethods-delayed-quotes'&#62; <br />
&lt;<font color="#00FFFF">Result</font> xsi:type='<font color="#0000FF">xsd:float</font>'&#62;41.81&lt;/<font color="#00FFFF">Result</font>&#62; <br />
&lt;/<font color="#FFFF00">n:getQuoteResponse</font>&#62; <br />
&lt;/soap:Body&#62; <br />
...
</td></tr></table><br></tt>
This use of a <i><b>struct</b></i> or <i><b>class</b></i> enables the adaptation of the default SOAP response element name and/or namespace URI when required.

<p>
Note that the <i><b>struct</b></i> (or <i><b>class</b></i>) declaration may appear within the function prototype declaration. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*<font color="#FF0000">xsd__string</font>; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;<font color="#0000FF">xsd__float</font>; <br />
<b>int</b>&nbsp;<font color="#00FF00">ns1__getQuote</font>(<font color="#FF0000">xsd__string</font> <font color="#FF00FF">symbol</font>, <b>struct</b>&nbsp;<font color="#FFFF00">ns1__getQuoteResponse</font> {<font color="#0000FF">xsd__float</font> <font color="#00FFFF">Result</font>;} &amp;r);
</td></tr></table><br></i>
This example combines the declaration of the response element of the remote method with the function prototype of the remote method.

<p>
		      <h4><a name="tth_sEc5.1.8">
5.1.8</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Multiple Output Parameters</font></h4><a name="sec:multiple">
</a>

<p>
The gSOAP stub and skeleton compiler uses the convention that the <b>single output parameter</b> of a remote method is the <b>
last parameter</b> of the function prototype declaration in a header file. All other parameters are considered input parameters of the remote method. To specify a remote method
with <b>multiple output parameters</b>, a <i><b>struct</b></i> or <i><b>class</b></i> must be declared for the remote method response, see
also&nbsp;<a href="#sec:response">5.1.6</a>.  The fields of the <i><b>struct</b></i> or <i><b>class</b></i> are the output parameters of the remote method.
Both the order of the input parameters in the function prototype and the order of the output parameters (the fields in the
<i><b>struct</b></i> or <i><b>class</b></i>) is not significant. However, the SOAP 1.1 specification states that input and output parameters may be
treated as having anonymous parameter names which requires a particular ordering, see Section&nbsp;<a href="#sec:anonymous">5.1.12</a>.

<p>
		      <h4><a name="tth_sEc5.1.9">
5.1.9</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example5">
</a>

<p>
As an example, consider a hypothetical remote method <i>getNames</i> with a single input parameter <i><font color="#FF00FF">SSN</font></i> 
and two output parameters <i><font color="#FF0000">first</font></i> and <i><font color="#0000FF">last</font></i>. This can be specified as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "getNames.h": <br />
<b>int</b>&nbsp;<font color="#00FF00">ns3__getNames</font>(<b>char</b>&nbsp;*<font color="#FF00FF">SSN</font>, <b>struct</b>&nbsp;<font color="#FFFF00">ns3__getNamesResponse</font> {<b>char</b>&nbsp;*<font color="#FF0000">first</font>; <b>char</b>&nbsp;*<font color="#0000FF">last</font>;} &amp;r);
</td></tr></table><br></i>
The gSOAP stub and skeleton compiler takes this header file as input and generates source code for the function <i>soap_call_ns3__getNames</i>. When invoked by a client application, the proxy produces the SOAP request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope ... xmlns:ns3="urn:names" ...&#62; <br />
... <br />
&lt;<font color="#00FF00">ns3:getNames</font>&#62; <br />
&lt;<font color="#FF00FF">SSN</font>&#62;999 99 9999&lt;/<font color="#FF00FF">SSN</font>&#62; <br />
&lt;/<font color="#00FF00">ns3:getNames</font>&#62; <br />
...
</td></tr></table><br></tt>
The response by a SOAP service could be:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;<font color="#FFFF00">m:getNamesResponse</font> xmlns:m="urn:names"&#62; <br />
&lt;<font color="#FF0000">first</font>&#62;John&lt;/<font color="#FF0000">first</font>&#62; <br />
&lt;<font color="#0000FF">last</font>&#62;Doe&lt;/<font color="#0000FF">last</font>&#62; <br />
&lt;/<font color="#FFFF00">m:getNamesResponse</font>&#62; <br />
...
</td></tr></table><br></tt>
where <tt><font color="#FF0000">first</font></tt> and <tt><font color="#0000FF">last</font></tt> are the output parameters of the <i>getNames</i> remote method of the service.

<p>
As another example, consider a remote method <i>copy</i> with an input parameter and an output parameter with identical
parameter names (this is not prohibited by the SOAP 1.1 protocol). This can be specified as well using a response <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contente of file "copy.h": <br />
<b>int</b>&nbsp;<font color="#00FF00">X_rox__copy_name</font>(<b>char</b>&nbsp;*<font color="#FF00FF">name</font>, <b>struct</b>&nbsp;<font color="#FFFF00">X_rox__copy_nameResponse</font> {<b>char</b>&nbsp;*<font color="#FF0000">name</font>;} &amp;r);
</td></tr></table><br></i>
The use of a <i><b>struct</b></i> or <i><b>class</b></i> for the remote method response enables the declaration of remote methods that have
parameters that are passed both as input and output parameters.

<p>
The gSOAP compiler takes the <i>copy.h</i> header file as input and generates the <i>soap_call_X_rox__copy_name</i> proxy. When invoked by a client application, the proxy produces the SOAP request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope ... xmlns:X-rox="urn:copy" ...&#62; <br />
... <br />
&lt;<font color="#00FF00">X-rox:copy-name</font>&#62; <br />
&lt;<font color="#FF00FF">name</font>&#62;SOAP&lt;/<font color="#FF00FF">name</font>&#62; <br />
&lt;/<font color="#00FF00">X-rox:copy-name</font>&#62; <br />
...
</td></tr></table><br></tt>
The response by a SOAP copy service could be something like:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;<font color="#FFFF00">m:copy-nameResponse</font> xmlns:m="urn:copy"&#62; <br />
&lt;<font color="#FF0000">name</font>&#62;SOAP&lt;/<font color="#FF0000">name</font>&#62; <br />
&lt;/<font color="#FFFF00">m:copy-nameResponse</font>&#62; <br />
...
</td></tr></table><br></tt>
The name will be parsed and decoded by the proxy and returned in the <i>name</i> field of the <i><b>struct</b>&nbsp;X_rox__copy_nameResponse &amp;r</i> parameter.

<p>
		      <h4><a name="tth_sEc5.1.10">
5.1.10</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Output Parameters With Complex Data Types</font></h4><a name="sec:compound">
</a>

<p>
If the output parameter of a remote method is a complex data type such as a <i><b>struct</b></i> or <i><b>class</b></i> it is necessary to
specify the response element of the remote method as a <i><b>struct</b></i> or <i><b>class</b></i> <b>at all times</b>.
Otherwise, the output parameter will
be considered the response element (!), because of the response element specification convention used by gSOAP,
as discussed in&nbsp;<a href="#sec:response">5.1.6</a>.

<p>
		      <h4><a name="tth_sEc5.1.11">
5.1.11</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example6">
</a>

<p>
This is is best illustrated with an example. The Flighttracker service by ObjectSpace provides real time flight information for
flights in the air. It requires an airline code and flight number as parameters, see
<a href="http://xmethods.com/detail.html?id=86"><tt>http://xmethods.com/detail.html?id=86</tt></a> for details. The remote method name is <i>getFlightInfo</i> and
the method has two string parameters: the airline code and flight number, both of which must be encoded as <tt>xsd:string</tt> types.
The method returns a <i>getFlightResponse</i> response element with a <i>return</i> output parameter that is of complex type
<i>FlightInfo</i>. The type <i>FlightInfo</i> is represented by a <i><b>class</b></i> in the header file, whose field names correspond to
the <i>FlightInfo</i> accessors:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "flight.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>class</b>&nbsp;ns2__FlightInfo <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__string airline; <br />
&nbsp;&nbsp;&nbsp;xsd__string flightNumber; <br />
&nbsp;&nbsp;&nbsp;xsd__string altitude; <br />
&nbsp;&nbsp;&nbsp;xsd__string currentLocation; <br />
&nbsp;&nbsp;&nbsp;xsd__string equipment; <br />
&nbsp;&nbsp;&nbsp;xsd__string speed; <br />
}; <br />
<b>struct</b>&nbsp;ns1__getFlightInfoResponse {ns2__FlightInfo return_;}; <br />
<b>int</b>&nbsp;ns1__getFlightInfo(xsd__string param1, xsd__string param2, <b>struct</b>&nbsp;ns1__getFlightInfoResponse &amp;r);
</td></tr></table><br></i>
The response element <i>ns1__getFlightInfoResponse</i> is explicitly declared and it has one field: <i>return_</i> of type
<i>ns2__FlightInfo</i>.  Note that <i>return_</i> has a trailing underscore to avoid a name clash with the <i><b>return</b></i> keyword,
see Section&nbsp;<a href="#sec:idtrans">7.3</a> for details on the translation of C++ identifiers to XML element names.

<p>
The SOAP C++ stub and skeleton compiler generates the <i>soap_call_ns1__getFlightInfo</i> proxy. Here is an example fragment of a client application that uses this proxy to request flight information:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); <br />
... <br />
soap_call_ns1__getFlightInfo(&amp;soap, <tt>"testvger.objectspace.com/soap/servlet/rpcrouter"</tt>, <br />
&nbsp;&nbsp;&nbsp;<tt>"urn:galdemo:flighttracker"</tt>, <tt>"UAL"</tt>, <tt>"184"</tt>, r); <br />
... <br />
struct Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1", "urn:galdemo:flighttracker"}, <br />
&nbsp;&nbsp;&nbsp;{"ns2", "http://galdemo.flighttracker.com"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
When invoked by a client application, the proxy produces the SOAP request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /soap/servlet/rpcrouter HTTP/1.1 <br />
Host: testvger.objectspace.com <br />
Content-Type: text/xml <br />
Content-Length: 634 <br />
SOAPAction: "urn:galdemo:flighttracker" <br />
<br />
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns1="urn:galdemo:flighttracker" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns2="http://galdemo.flighttracker.com" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;ns1:getFlightInfo xsi:type="ns1:getFlightInfo"&#62; <br />
&lt;param1 xsi:type="xsd:string"&#62;UAL&lt;/param1&#62; <br />
&lt;param2 xsi:type="xsd:string"&#62;184&lt;/param2&#62; <br />
&lt;/ns1:getFlightInfo&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
The Flighttracker service responds with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
HTTP/1.1 200 ok <br />
Date: Thu, 30 Aug 2001 00:34:17 GMT <br />
Server: IBM_HTTP_Server/1.3.12.3 Apache/1.3.12 (Win32) <br />
Set-Cookie: sesessionid=2GFVTOGC30D0LGRGU2L4HFA;Path=/ <br />
Cache-Control: no-cache="set-cookie,set-cookie2" <br />
Expires: Thu, 01 Dec 1994 16:00:00 GMT <br />
Content-Length: 861 <br />
Content-Type: text/xml; charset=utf-8 <br />
Content-Language: en <br />
<br />
&lt;?xml version='1.0' encoding='UTF-8'?&#62; <br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema"&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;ns1:getFlightInfoResponse xmlns:ns1="urn:galdemo:flighttracker" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;return xmlns:ns2="http://galdemo.flighttracker.com" xsi:type="ns2:FlightInfo"&#62; <br />
&lt;equipment xsi:type="xsd:string"&#62;A320&lt;/equipment&#62; <br />
&lt;airline xsi:type="xsd:string"&#62;UAL&lt;/airline&#62; <br />
&lt;currentLocation xsi:type="xsd:string"&#62;188 mi W of Lincoln, NE&lt;/currentLocation&#62; <br />
&lt;altitude xsi:type="xsd:string"&#62;37000&lt;/altitude&#62; <br />
&lt;speed xsi:type="xsd:string"&#62;497&lt;/speed&#62; <br />
&lt;flightNumber xsi:type="xsd:string"&#62;184&lt;/flightNumber&#62; <br />
&lt;/return&#62; <br />
&lt;/ns1:getFlightInfoResponse&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
The proxy returns the service response in variable <i>r</i> of type <i><b>struct</b>&nbsp;ns1__getFlightInfoResponse</i> and this information can be displayed by the client application with the following code fragment:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
cout  &lt;&lt;  r.return_.equipment  &lt;&lt;  " flight "  &lt;&lt;  r.return_.airline  &lt;&lt;  r.return_.flightNumber <br />
&nbsp;&nbsp;&nbsp; &lt;&lt;  " traveling "  &lt;&lt;  r.return_.speed  &lt;&lt;  " mph "  &lt;&lt;  " at "  &lt;&lt;  r.return_.altitude <br />
&nbsp;&nbsp;&nbsp; &lt;&lt;  " ft, is located "  &lt;&lt;  r.return_.currentLocation &lt;&lt; endl;
</td></tr></table><br></i>
This code displays the service response as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<tt>A320 flight UAL184 traveling 497 mph at 37000 ft, is located 188 mi W of Lincoln, NE</tt>
</td></tr></table><br></span>
Note: the flight tracker service is no longer available since 9/11/2001.

<p>
		      <h4><a name="tth_sEc5.1.12">
5.1.12</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Anonymous Parameter Names</font></h4><a name="sec:anonymous">
</a>

<p>
The SOAP 1.1 protocol allows parameter names to be anonymous.  That is, the name(s) of the output
parameters of a remote method are not strictly required to match a client's view of the parameters names.  Also, the
input parameter names of a remote method are not striclty required to match a service's view of the parameter names.  Although
this convention is likely to be deprecated in SOAP 1.2, the gSOAP compiler can generate stub and skeleton
routines that support anonymous parameters.  To make parameter names anonymous on the receiving side (client or service),
the parameter names should start with an underscore (<i>_</i>) in the function prototype in the header file.

<p>
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>int</b>&nbsp;ns1__getQuote(xsd__string symbol, &amp;_return);
</td></tr></table><br></i>
Or, alternatively with a response <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>struct</b>&nbsp;ns1__getQuoteResponse {xsd__float _return;}; <br />
<b>int</b>&nbsp;ns1__getQuote(xsd__string symbol, <b>struct</b>&nbsp;ns1__getQuoteResponse &amp;r);
</td></tr></table><br></i>
In this example, <i>_return</i> is an anonymous output parameter.
As a consequence, the service response to a request made by a client created with gSOAP using this header file specification
may include any name for the output parameter in the SOAP payload.
The input parameters may also be anonymous. This affects the implementation of Web services in gSOAP
and the matching of parameter names by the service.

<p>
<font color="#FF0000"><b>Caution</b></font>: when anonymous parameter names are used, the order of the parameters in the function prototype of a remote method is
significant.

<p>
		      <h4><a name="tth_sEc5.1.13">
5.1.13</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify a Method with No Input Parameters</font></h4>

<p>
To specify a remote method that has no input parameters, just provide a function prototype with one parameter which is the output
parameter.  However, some C/C++ compilers (notably Visual C++<sup><span class="roman">TM</span></sup>) will not compile and complain about an empty
<i><b>struct</b></i>.  This <i><b>struct</b></i> is generated by gSOAP to contain the SOAP request message.  To fix this, provide one input
parameter of type <i><b>void</b>*</i> (gSOAP can not serialize <i>void*</i> data).  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns3__SOAPService <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;ID; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*owner; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*description; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*homepageURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*endpoint; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAPAction; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodNamespaceURI; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serviceStatus; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodName; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*dateCreated; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*downloadURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*wsdlURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*instructions; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*contactEmail; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serverImplementation; <br />
}; <br />
<b>struct</b>&nbsp;ArrayOfSOAPService {<b>struct</b>&nbsp;ns3__SOAPService *__ptr; <b>int</b>&nbsp;__size;}; <br />
<b>int</b>&nbsp;ns__getAllSOAPServices(<b>void</b>&nbsp;*_, <b>struct</b>&nbsp;ArrayOfSOAPService &amp;_return);
</td></tr></table><br></i>
The <i>ns__getAllSOAPServices</i> method has one <i><b>void</b>*</i> input parameter which is ignored by the serializer to produce the
request message.
To call the proxy, use <i>NULL</i> as the actual input parameter value.

<p>
Most C/C++ compilers allow empty <i><b>struct</b></i>s and therefore the <i><b>void</b>*</i> parameter is not required.

<p>
	     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Web Services</font></h3>

<p>
The gSOAP stub and skeleton compiler generates <b>skeleton</b> routines in C++ source form for each of the remote methods specified
as function prototypes in the header file processed by the gSOAP compiler.  The skeleton routines can be readily used to implement
the remote methods in a new SOAP Web service. The compound data types used by the input and output parameters of SOAP remote
methods must be declared in the header file, such as structs, classes, arrays, and pointer-based data structures (graphs) that are
used as the data types of the parameters of a remote method. The gSOAP compiler automatically generates serializers and
deserializers for the data types to enable the generated skeleton routines to encode and decode the contents of the parameters of
the remote methods.  The gSOAP compiler also generates a remote method request dispatcher routine that will serve requests by
calling the appropriate skeleton when the SOAP service application is installed as a CGI application on a Web server.

<p>
		      <h4><a name="tth_sEc5.2.1">
5.2.1</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example7">
</a>

<p>
The following example specifies three remote methods to be implemented by a new SOAP Web service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "calc.h": <br />
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>int</b>&nbsp;ns__add(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sub(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sqrt(xsd__double a, xsd__double &amp;result); <br />
</td></tr></table><br></i>
The <i>add</i> and <i>sub</i> methods are intended to add and subtract two double floating point numbers stored in input parameters
<i>a</i> and <i>b</i> and should return the result of the operation in the <i>result</i> output parameter. The <i>qsrt</i> method is
intended to take the square root of input parameter <i>a</i> and to return the result in the output parameter <i>result</i>.
The <i>xsd__double</i> type is recognized by the gSOAP compiler as the <tt>xsd:double</tt> XML schema data type.
The use of <i><b>typedef</b></i> is a convenient way to associate primitive C types with primitive XML schema data types.

<p>
To generate the skeleton routines, the gSOAP compiler is invoked from the command line with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 calc.h</i>
</td></tr></table><br></span>
The compiler generates the skeleton routines for the <i>add</i>, <i>sub</i>, and <i>sqrt</i> remote methods specified in the
<i>calc.h</i> header file. The skeleton routines are respectively, <i>soap_serve_ns__add</i>, <i>soap_serve_ns__sub</i>, and
<i>soap_serve_ns__sqrt</i> and saved in the file <i>soapServer.cpp</i>. The generated file <i>soapC.cpp</i> contains serializers
and deserializers for the skeleton. The compiler also generates a service dispatcher: the <i>soap_serve</i> function handles
client requests on the standard input stream and dispatches the remote method requests to the appropriate skeletons to serve the
requests. The skeleton in turn calls the remote method implementation function. The function prototype of the remote method
implementation function is specified in the header file that is input to the gSOAP compiler.

<p>
Here is an example Calculator service application that uses the generated <i>soap_serve</i> routine to handle client requests:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "calc.cpp": <br />
#include "soapH.h" <br />
#include  &lt; math.h &gt;  // for sqrt() <br />
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); // use the remote method request dispatcher <br />
} <br />
// Implementation of the "add" remote method: <br />
<b>int</b>&nbsp;ns__add(<b>struct</b>&nbsp;soap *soap, <b>double</b>&nbsp;a, <b>double</b>&nbsp;b, <b>double</b>&nbsp;&amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;result = a + b; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
// Implementation of the "sub" remote method: <br />
<b>int</b>&nbsp;ns__sub(<b>struct</b>&nbsp;soap *soap, <b>double</b>&nbsp;a, <b>double</b>&nbsp;b, <b>double</b>&nbsp;&amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;result = a - b; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
// Implementation of the "sqrt" remote method: <br />
<b>int</b>&nbsp;ns__sqrt(<b>struct</b>&nbsp;soap *soap, <b>double</b>&nbsp;a, <b>double</b>&nbsp;&amp;result); <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(a  &gt; = 0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = sqrt(a); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_fault(soap); // allocate space for fault (if necessary) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>faultstring = "Square root of negative number"; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>detail = "I can only take the square root of a non-negative number"; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_FAULT; <br />
&nbsp;&nbsp;&nbsp;} <br />
} <br />
// As always, a namespace mapping table is needed: <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns",       "urn:simple-calc"}, // bind "ns" namespace prefix <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
Note that the remote methods have an extra input parameter which is a pointer to the gSOAP runtime environment.
The implementation of the remote methods MUST return a SOAP error code. The code <i>SOAP_OK</i> denotes success, while
<i>SOAP_FAULT</i> denotes an exception with details that can be defined by the user. The exception description can be assigned to
the <i>soap</i><tt>-&gt;</tt><i>fault</i><tt>-&gt;</tt><i>faultstring</i> string and details can be assigned to the
<i>soap</i><tt>-&gt;</tt><i>fault</i><tt>-&gt;</tt><i>detail</i> string. The
<i>soap_fault</i> function will allocate a fault struct. The fault exception will be passed on to the client of this service.

<p>
This service application can be readily installed as a CGI application. The service description would be:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td>Endpoint URL: </td><td>the URL of the CGI application </td></tr>
<tr><td>SOAP action: </td><td>"" (2 quotes) </td></tr>
<tr><td>Remote method namespace: </td><td><tt>urn:simple-calc</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>add</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameters: </td><td><tt>a</tt> of type <tt>xsd:double</tt> and <tt>b</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>result</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>sub</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameters: </td><td><tt>a</tt> of type <tt>xsd:double</tt> and <tt>b</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>result</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>sqrt</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameter: </td><td><tt>a</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>result</tt> of type <tt>xsd:double</tt> or a SOAP Fault
</td></tr></table>

</td></tr></table><br></span>
The <i>soapcpp2</i> compile generates a WSDL file for this service, see Section&nbsp;<a href="#sec:wsdl">5.2.5</a>.

<p>
Unless the CGI application inspects and checks the environment variable <i>SOAPAction</i> which contains the SOAP action request by
a client, the SOAP action is ignored by the CGI application.  SOAP actions are specific to the SOAP protocol and provide a means
for routing requests and for security reasons (e.g.&nbsp;firewall software can inspect SOAP action headers to grant or deny the
SOAP request. Note that this requires the SOAP service to check the SOAP action header as well to match it with the remote method.)

<p>
The header file input to the gSOAP compiler does not need to be modified to generate client stubs for accessing this
service.  Client applications can be developed by using the same header file as for which the service application
was developed.  For example, the <i>soap_call_ns__add</i> proxy is available from the <i>soapClient.cpp</i> file after invoking
the gSOAP compiler on the <i>calc.h</i> header file. As a result, client and service applications can be developed without
the need to know the details of the SOAP encoding used.

<p>
		      <h4><a name="tth_sEc5.2.2">
5.2.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Create a Stand-Alone Service</font></h4>

<p>
The deployment of a Web service as a CGI application is an easy means to provide your service on the Internet.
Services can also run as stand-alone services on intranets where client-service interactions are not blocked by firewalls.

<p>
To create a stand-alone service, only the <i>main</i> routine of the service needs to be modified.  Instead of just calling the
<i>soap_serve</i> routine, the <i>main</i> routine is changed into:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; // master and slave sockets <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, <tt>"machine.cs.fsu.edu"</tt>, 18083, 100); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful: master socket = %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 1; ; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"%d: accepted connection from IP = %d.%d.%d.%d socket = %d"</tt>, i, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(soap.ip &lt;&lt; 24)&amp;0xFF, (soap.ip &lt;&lt; 16)&amp;0xFF, (soap.ip &lt;&lt; 8)&amp;0xFF, soap.ip&amp;0xFF, s); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap);	// process RPC skeletons <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"request served\n"</tt>); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_destroy(&amp;soap);	// clean up class instances <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap);	// clean up everything and close socket <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_done(&amp;soap); // close master socket <br />
}
</td></tr></table><br></i>
The functions used are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="301"><font color="#FF0000"><b>Function</b></font> </td><td width="301"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td width="301"><i>soap_init(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Initializes gSOAP runtime environment (required once) </td></tr>
<tr><td width="301"><i>soap_bind(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*host, <b>int</b>&nbsp;port, <b>int</b>&nbsp;backlog)</i> </td><td width="301">Returns master socket (backlog = max.&nbsp;queue
size for requests). When <i>host==NULL</i>: host is the machine on which the service runs </td></tr>
<tr><td width="301"><i>soap_accept(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Returns slave socket </td></tr>
<tr><td width="301"><i>soap_end(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Clean up deserialized data (except class instances) and temporary data </td></tr>
<tr><td width="301"><i>soap_free(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Clean up temporary data only </td></tr>
<tr><td width="301"><i>soap_destroy(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Clean up deserialized class instances </td></tr>
<tr><td width="301"><i>soap_done(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Close master socket </td></tr></table>

</td></tr></table><br></span>
The <i>host</i> name in <i>soap_bind</i> may be NULL to indicate that the current host should be used.

<p>
The <i>soap.accept_timeout</i> attribute of the gSOAP run-time environment specifies the timeout value for a non-blocking
<i>soap_accept(&amp;soap)</i> call. See Section&nbsp;<a href="#sec:timeout">12.10</a> for more details on timeout management.

<p>
See Section&nbsp;<a href="#sec:memory">6.7</a> for more details on memory management.

<p>
A client application connects to this stand-alone service with the endpoint
<i>machine.cs.fsu.edu:18083</i>.
A client may use the <i>http://</i> prefix. When absent, no HTTP header is send and no HTTP-based information will be communicated
to the service.

<p>
		      <h4><a name="tth_sEc5.2.3">
5.2.3</a>&nbsp;&nbsp;<font color="#0000FF">How to Create a Multi-Threaded Stand-Alone Service</font></h4><a name="sec:mt">
</a>

<p>
Multi-threading a Web Service is essential when the response times for handling requests by the service are (potentially) long.
In case of long response times, the latencies introduced by the unrelated requests may become prohibitive for a successful
deployment of a stand-alone service.

<p>
gSOAP 2.0 is thread safe and allows the implementation of multi-threaded stand-alone services.
Multiple threads can be used to handle requests.

<p>
Here is an example of a multi-threaded Web Service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; pthread.h &gt;  <br />
#define BACKLOG (100)	// Max. request backlog <br />
#define MAX_THR (8)	// Max. threads to serve requests <br />
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc  &lt;  3) // no args: assume this is a CGI application <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); // serve request, one thread, CGI style <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // cleanup <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap_thr[MAX_THR]; // each thread needs a runtime environment <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t tid[MAX_THR]; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*host = argv[1]; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;port = atoi(argv[2]); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s, i; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, host, port, BACKLOG); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(i = 0; i  &lt;  MAX_THR; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_thr[i] = NULL; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(;;) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(i = 0; i  &lt;  MAX_THR; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n"</tt>, i, s, (soap.ip &gt;&gt; 24)&amp;0xFF,
(soap.ip &gt;&gt; 16)&amp;0xFF, (soap.ip &gt;&gt; 8)&amp;0xFF, soap.ip&amp;0xFF); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap_thr[i]) // first time around <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_thr[i] = soap_new(); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap_thr[i]) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); // could not allocate <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b>\	// recycle soap environment <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(tid[i], NULL); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, "Thread <tt>%</tt>d completed<tt>\</tt>n", i); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(soap_thr[i]); // deallocate data of old thread <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_thr[i]<tt>-&gt;</tt>socket = s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid[i], NULL, (<b>void</b>*(*)(<b>void</b>*))soap_serve, (<b>void</b>*)soap_thr[i]); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
}
</td></tr></table><br></i>
The example illustrates the use of threads to improve the quality of service by handling new requests in separate threads.
Each thread needs a separate runtime environment. The example above requires threads to synchronize at some point, so runaway
processes can be halted (not shown in the code). The next example detaches threads. No attempt is made to synchronize threads.
Runaway threads will consume resources.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; pthread.h &gt;  <br />
#define BACKLOG (100)	// Max. request backlog <br />
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc  &lt;  3) // no args: assume this is a CGI application <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); // serve request, one thread, CGI style <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // cleanup <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;*process_request(<b>void</b>*); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *tsoap; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*host = argv[1]; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;port = atoi(argv[2]); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, host, port, BACKLOG); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(;;) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n"</tt>, i, s, (soap.ip &gt;&gt; 24)&amp;0xFF,
(soap.ip &gt;&gt; 16)&amp;0xFF, (soap.ip &gt;&gt; 8)&amp;0xFF, soap.ip&amp;0xFF); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap = soap_new(); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!tsoap) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap<tt>-&gt;</tt>socket = s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, (<b>void</b>*(*)(<b>void</b>*))process_request, (<b>void</b>*)tsoap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>void</b>&nbsp;*process_request(<b>void</b>&nbsp;*soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;pthread_detach(pthread_self()); <br />
&nbsp;&nbsp;&nbsp;soap_serve((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_end((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;free(soap); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
}
</td></tr></table><br></i>
For clean termination of the server, the master socket can be closed and callbacks removed with <i>soap_done(<b>struct</b>&nbsp;soap *soap)</i>.

<p>
		      <h4><a name="tth_sEc5.2.4">
5.2.4</a>&nbsp;&nbsp;<font color="#0000FF">Some Web Service Implementation Issues</font></h4>

<p>
The same client header file specification issues apply to the specification and implementation of a SOAP Web service. Refer to

<ul><p>
<li> <a href="#sec:namespace">5.1.2</a> for namespace considerations.</li>
<p>
<li> <a href="#sec:encoding">5.1.4</a> for an explanation on how to change the encoding of the primitive types.</li>
<p>
<li> <a href="#sec:response">5.1.6</a> for a discussion on how the response element format can be controlled.</li>
<p>
<li> <a href="#sec:multiple">5.1.8</a> for details on how to pass multiple output parameters from a remote method.</li>
<p>
<li> <a href="#sec:compound">5.1.10</a> for passing complex data types as output parameters.</li>
<p>
<li> <a href="#sec:anonymous">5.1.12</a> for anonymizing the input and output parameter names.</li>
</ul>

<p>
		      <h4><a name="tth_sEc5.2.5">
5.2.5</a>&nbsp;&nbsp;<font color="#0000FF">How to Generate WSDL Service Descriptions</font></h4><a name="sec:wsdl">
</a>

<p>
The gSOAP stub and skeleton compiler <i>soapcpp2</i> generates WSDL (Web Service Description Language) service descriptions and XML schema files
when processing a header file.  The compiler produces one WSDL file for a set of remote methods.  The names of the function
prototypes of the remote methods must use the same namespace prefix and the namespace prefix is used to name the WSDL file.  If
multiple namespace prefixes are used to define remote methods, multiple WSDL files will be created and each file describes the set
of remote methods belonging to a namespace prefix.

<p>
To publish the WSDL service description, the <tt>%{}%</tt>-patterns that appear in the generated WSDL file have to be filled in with the
following information:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Replace</b></font> </td><td><font color="#FF0000"><b>With</b></font>  </td></tr>
<tr><td>%{Service}% </td><td>the file name of the CGI service application (without a file name extension) </td></tr>
<tr><td>%{URL}% </td><td>the endpoint URL of the service (without the CGI file name) </td></tr>
<tr><td>%{URI}% </td><td>the namespace URI of the service (can be the same as the URL) </td></tr></table>

</td></tr></table><br></span>
This information can also be provided in the header file which will then be automatically incorporated in the WSDL file, see
advanced features Section&nbsp;<a href="#sec:directives">12.2</a>.

<p>
In addition to the generation of the <tt>ns.wsdl</tt> file, a file with a namespace mapping table is generated by the gSOAP
compiler. An example mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
struct Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", \"http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema", \"http://www.w3.org/*/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "%{URI}%"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
After replacing the <i>%{}%</i> patterns in the namespace mapping table file, this file can be incorporated in the
client/service application, see Section&nbsp;<a href="#sec:nstable">7.4</a> for details on namespace mapping tables.

<p>
To deploy a Web service, copy the compiled CGI service application to the designated CGI directory of your Web server.
Make sure the file permissions are set right (<tt>chmod 755 calc.cgi</tt> for Unix/Linux).
You can then publish the WSDL file on the Web.

<p>
The gSOAP compiler also generates XML schema files for all C/C++
complex types (e.g.&nbsp;<i><b>struct</b></i>s and <i><b>class</b></i>es) when declared with a namespace prefix.
These files are named <tt>ns.xsd</tt>, where <tt>ns</tt> is the namespace prefix used in the declaration of the complex type.
The XML schema files do not have to be published as the WSDL file already contains the appropriate XML schema types.

<p>
		      <h4><a name="tth_sEc5.2.6">
5.2.6</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example8">
</a>

<p>
For example, suppose the following methods are defined in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>int</b>&nbsp;ns__add(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sub(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sqrt(xsd__double a, xsd__double &amp;result); <br />
</td></tr></table><br></i>
Then, one WSDL file will be created with the file name <tt>ns.wsdl</tt> that describes all three remote methods:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;definitions name="%{Service}%" <br />
&nbsp;&nbsp;&nbsp;xmlns="http://schemas.xmlsoap.org/wsdl/" <br />
&nbsp;&nbsp;&nbsp;targetNamespace="%{URL}%/%{Service}%.wsdl" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP="http://schemas.xmlsoap.org/wsdl/soap/" <br />
&nbsp;&nbsp;&nbsp;xmlns:WSDL="http://schemas.xmlsoap.org/wsdl/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2000/10/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:tns="%{URL}%/%{Service}%.wsdl" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="%{URL}%/ns.xsd"&#62; <br />
&lt;types&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;schema <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns="http://www.w3.org/2000/10/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targetNamespace="%{URL}%/ns.xsd" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;complexType name="addResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="result" type="double" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;anyAttribute namespace="##other"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;complexType name="subResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="result" type="double" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;anyAttribute namespace="##other"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;complexType name="sqrtResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="result" type="double" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;anyAttribute namespace="##other"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/schema&#62; <br />
&lt;/types&#62; <br />
&lt;message name="addRequest"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="a" type="xsd:double"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="b" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="addResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="result" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="subRequest"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="a" type="xsd:double"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="b" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="subResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="result" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="sqrtRequest"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="a" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="sqrtResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="result" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;portType name="%{Service}%PortType"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="add"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input message="tns:addRequest"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output message="tns:addResponse"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sub"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input message="tns:subRequest"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output message="tns:subResponse"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sqrt"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input message="tns:sqrtRequest"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output message="tns:sqrtResponse"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&lt;/portType&#62; <br />
&lt;binding name="%{Service}%Binding" type="tns:%{Service}%PortType"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="add"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:operation soapAction="%{URI}%#add"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="%{URI}%" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="%{URI}%" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/output&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sub"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:operation soapAction="%{URI}%#sub"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="%{URI}%" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="%{URI}%" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/output&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sqrt"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:operation soapAction="%{URI}%#sqrt"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="%{URI}%" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="%{URI}%" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/output&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&lt;/binding&#62; <br />
&lt;service name="%{Service}%"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;port name="%{Service}%Port" binding="tns:%{Service}%Binding"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:address location="%{URL}%/%{Service}%.cgi"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/port&#62; <br />
&lt;/service&#62; <br />
&lt;/definitions&#62;
</td></tr></table><br></tt>
The service name of the calculator service could be <tt>calc</tt> (so the file name of the CGI service application
is <tt>calc.cgi</tt>), the URL could be <tt>http://www.mycalc.com</tt>, and the
namespace URI could be <tt>http://www.mycalc.com</tt> (the URI must be unique, if possible, and the URL uniquelly identifies an organization).
According to this, the following modifications to the generated WSDL file have to be made:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Replace</b></font> </td><td><font color="#FF0000"><b>With</b></font>  </td></tr>
<tr><td>%{Service}% </td><td><tt>calc</tt> </td></tr>
<tr><td>%{URL}% </td><td><tt>http://www.mycalc.com</tt> </td></tr>
<tr><td>%{URI}% </td><td><tt>http://www.mycalc.com</tt> </td></tr></table>

</td></tr></table><br></span>

<p>
		      <h4><a name="tth_sEc5.2.7">
5.2.7</a>&nbsp;&nbsp;<font color="#0000FF">How to Import WSDL Service Descriptions</font></h4><a name="sec:wsdlin">
</a>

<p>
The creation of SOAP Web Service clients from a WSDL service description is a two-step process.

<p>
First, execute <i>java wsdlcpp <u><span class="roman">file</span></u>.wsdl</i> which generates the a header file <i><u><span class="roman">file</span></u>.h</i>
and a C-source file <i><u><span class="roman">file</span></u>.c</i> with an example client program template.
Modify the client program template to your needs.

<p>
Second, the header file <i><u><span class="roman">file</span></u>.h</i> is to be processed by the gSOAP compiler by executing <i>soapcpp2 <u><span class="roman">file</span></u>.h</i>.
This creates the C-source files to build a client application, see&nbsp;<a href="#sec:client">5.1</a>.

<p>
The following limitations are specific to the WSDL importer tool. The
limitations are not general limitations of the gSOAP toolkit and the gSOAP
stub and skeleton compiler. Future releases of the WSDL import tool will
address these limitations.

<ul><p>
<li> No <tt>&lt;import&#62;</tt> (WSDL must be self-contained)</li>
<p>
<li> No support for SOAP Header and Fault messages
   If Header processing is required, this will need to be added by hand to
   the generated header file.</li>
<p>
<li> To ensure compatibility to C, the current WSDL importer generates <i><b>struct</b></i>
   declarations. These can be changed into <i><b>class</b></i> declarations in the
   generated header file when necessary.</li>
</ul>

<p>
		      <h4><a name="tth_sEc5.2.8">
5.2.8</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify minOccurs and maxOccurs Schema Attributes</font></h4>

<p>
By default, gSOAP generates WSDL and schemas with <tt>minOccurs=1</tt> and <tt>maxOccurs=1</tt> for non-array types, and
<tt>minOccurs=0</tt> and <tt>maxOccurs=unbounded</tt> for array types.
The <tt>minOccurs</tt> and <tt>maxOccurs</tt> attribute values of fields in <i><b>struct</b></i> and <i><b>class</b></i> types are specified as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">Type</span></u> <u><span class="roman">fieldname</span></u> <font size="+1"><span class="roman">[</span></font><u><span class="roman">minOccurs</span></u><font size="+1"><span class="roman">[</span></font>:<u><span class="roman">maxOccurs</span></u><font size="+1"><span class="roman">]</span></font><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>= value<font size="+1"><span class="roman">]</span></font>
</td></tr></table><br></i>
The minOccurs and maxOccurs values must be integer literals.

<p>
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__MyRecord <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;n; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m 0; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size 0:10; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*item; <br />
}
</td></tr></table><br></i>
gSOAP generates:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;complexType name="MyRecord&#187; <br />
&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="n" type="xsd:int" minOccurs="1" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="m" type="xsd:int" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="item" type="xsd:int" minOccurs="0" maxOccurs="10"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&lt;/complexType&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc5.2.9">
5.2.9</a>&nbsp;&nbsp;<font color="#0000FF">Combining a Client and Service into a Peer Application</font></h4>

<p>
This is a more sophisticated example that combines the functionality of two Web services into one new SOAP Web service.  The
service provides a currency-converted stock quote.  To serve a request, the service in turn requests the stock quote and the
currency-exchange rate from two XMethods services.

<p>
In addition to being a client of two XMethods services, this service application can also be used as a client of itself to test
the implementation.  As a client invoked from the command-line, it will return a currency-converted stock quote by connecting to
a copy of itself installed as a CGI application on the Web to retrieve the quote after which it will print the quote on the terminal.

<p>
The header file input to the gSOAP compiler is given below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "quotex.h": <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result); // XMethods delayed stock quote service remote method <br />
<b>int</b>&nbsp;ns2__getRate(<b>char</b>&nbsp;*country1, <b>char</b>&nbsp;*country2, <b>float</b>&nbsp;&amp;result); // XMethods currency-exchange service remote method <br />
<b>int</b>&nbsp;ns3__getQuote(<b>char</b>&nbsp;*symbol, <b>char</b>&nbsp;*country, <b>float</b>&nbsp;&amp;result); // the new currency-converted stock quote service <br />
</td></tr></table><br></i>
The <i>quotex.cpp</i> client/service application source is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "quotex.cpp": <br />
#include "soapH.h"	// include generated proxy and SOAP support <br />
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;q; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc &lt;= 2) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<b>if</b>&nbsp;(soap_call_ns3__getQuote(&amp;soap, <tt>"http://www.cs.fsu.edu/~engelen/quotex.cgi"</tt>, NULL, argv[1], argv[2], q)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<tt>"\nCompany %s: %f (%s)\n"</tt>, argv[1], q, argv[2]); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>int</b>&nbsp;ns3__getQuote(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*symbol, <b>char</b>&nbsp;*country, <b>float</b>&nbsp;&amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;q, r; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ns1__getQuote(soap, <tt>"http://services.xmethods.net/soap"</tt>, NULL, symbol, q) == 0 &amp;&amp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_call_ns2__getRate(soap, <tt>"http://services.xmethods.net/soap"</tt>, NULL, <tt>"us"</tt>, country, r) == 0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = q*r; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_FAULT;	// pass soap fault messages on to the client of this app <br />
} <br />
/* Since this app is a combined client-server, it is put together with <br />
 * one header file that describes all remote methods. However, as a consequence we <br />
 * have to implement the methods that are not ours. Since these implementations are <br />
 * never called (this code is client-side), we can make them dummies as below. <br />
 */ <br />
<b>int</b>&nbsp;ns1__getQuote(<b>struct</b>soap *soap, <b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result) <br />
{ <b>return</b>&nbsp;SOAP_NO_METHOD; } // dummy: will never be called <br />
<b>int</b>&nbsp;ns2__getRate(<b>struct</b>soap *soap, <b>char</b>&nbsp;*country1, <b>char</b>&nbsp;*country2, <b>float</b>&nbsp;&amp;result) <br />
{ <b>return</b>&nbsp;SOAP_NO_METHOD; } // dummy: will never be called <br />
 <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema",          "http://www.w3.org/*/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1", "urn:xmethods-delayed-quotes"}, <br />
&nbsp;&nbsp;&nbsp;{"ns2", "urn:xmethods-CurrencyExchange"}, <br />
&nbsp;&nbsp;&nbsp;{"ns3", "urn:quotex"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
To compile:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 quotex.h</i> <br />
<i>g++ -o quotex.cgi quotex.cpp soapC.cpp soapClient.cpp soapServer.cpp stdsoap2.cpp -lsocket -lxnet -lnsl -lm</i>
</td></tr></table><br></span>
Note: under Linux you can omit the <tt>-l</tt> libraries.

<p>
The <i>quotex.cgi</i> executable is installed as a CGI application on the Web by copying it in the designated directory specific
to your Web server.
After this, the executable can also serve to test the service.  For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>quotex.cgi AOL uk</i>
</td></tr></table><br></span>
returns the quote of <i>AOL</i> in <i>uk</i> pounds by communicating the request and response quote from the CGI application.
See <a href="http://xmethods.com/detail.html?id=5"><tt>http://xmethods.com/detail.html?id=5</tt></a> for details on the currency abbreviations.

<p>
When combining clients and service functionalities, it is required to use one header file input to the compiler.
As a consequence, however, stubs and skeletons are available for <b>all</b> remote methods, while the client part will only
use the stubs and the service part will use the skeletons.  Thus, dummy implementations of the unused remote methods
need to be given which are never called.

<p>
Three WSDL files are created by gSOAP: <tt>ns1.wsdl</tt>, <tt>ns2.wsdl</tt>, and <tt>ns3.wsdl</tt>. Only the <tt>ns3.wsdl</tt> file is
required to be published as it contains the description of the combined service, while the others are generated as a side-effect
(and in case you want to develop these separate services).

<p>
	     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;<font color="#0000FF">How to Use gSOAP for One-Way SOAP Messaging</font></h3>

<p>
The default gSOAP client-server interaction is synchonous: the client waits for the server to respond to the request.
gSOAP also supports ``one-way'' SOAP messaging.
SOAP messaging routines are declared as function prototypes, just like remote methods for SOAP RPC.  However, the output parameter is a
<i><b>void</b></i> type to indicate the absence of a return value.

<p>
For example, the following header file specifies a event message for SOAP messaging:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__event(<b>int</b>&nbsp;eventNo, <b>void</b>&nbsp;dummy);
</td></tr></table><br></i>
The gSOAP stub and skeleton compiler generates the following functions in <i>soapClient.cpp</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_send_ns__event(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;URL, <b>const</b>&nbsp;<b>char</b>&nbsp;action, <b>int</b>&nbsp;event); <br />
<b>int</b>&nbsp;soap_recv_ns__event(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;ns__event *dummy); <br />
</td></tr></table><br></i>
The <i>soap_send_ns__event</i> function transmits the message to the destination URL by opening a socket and sending the SOAP encoded
message. The socket will remain
open after the send and has to be closed with <i>soap_closesock()</i>.  The open socket connection can also be used to obtain a service
response, e.g. with a <i>soap_recv</i> function call.

<p>
The <i>soap_recv_ns__event</i> function waits for a SOAP message on the currently open socket (<i>soap.socket</i>) and fills the
<i><b>struct</b>&nbsp;ns__event</i> with the <i>ns__event</i> parameters (e.g. <i><b>int</b>&nbsp;eventNo</i>).
The <i><b>struct</b>&nbsp;ns__event</i> is automatically created by gSOAP and is a mirror image of the <i>ns__event</i> parameters:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__event <br />
{ <b>int</b>&nbsp;eventNo; <br />
}
</td></tr></table><br></i>
The gSOAP generated <i>soapServer.cpp</i> code includes a skeleton routine to accept the message.
(The skeleton routine does not respond with a SOAP response message.)
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_serve_ns__event(<b>struct</b>&nbsp;soap *soap);
</td></tr></table><br></i>
The skeleton routine calls the user-implemented <i>ns__event(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;eventNo)</i> routine (note tha absence of the void
parameter!).

<p>
As usual, the skeleton will be automatically called by the remote method request dispatcher that handles both the remote method
requests (RPCs) and messages:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
main() <br />
{ soap_serve(soap_new()); <br />
} <br />
<b>int</b>&nbsp;ns__event(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;eventNo) <br />
{ <br />
&nbsp;&nbsp;&nbsp;... // handle event <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;<font color="#0000FF">How to Separately Use the SOAP Serializers and Deserializers</font></h3>

<p>
The gSOAP stub and skeleton compiler generates serializers and deserializers for all user-defined data structures that are
specified in the header file input to the compiler. The serializers and deserializers can be found in the generated
<i>soapC.cpp</i> file. These serializers and deserializers can be used separately by an application without the need to build a
full client or service application.  This is useful for applications that need to save or export their data in XML or need to
import data in XML format that is possibly saved by other applications.

<p>
The following attributres can be set to control the destination and source for serialization and deserialization:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Variable</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap.socket</i> </td><td>socket file descriptor for input and output or -1 </td></tr>
<tr><td><i>soap.sendfd</i> </td><td>if <i>soap_socket</i> &lt; 0, file descriptor for send operations </td></tr>
<tr><td><i>soap.sendfd</i> </td><td>if <i>soap_socket</i> &lt; 0, file descriptor for receive operations </td></tr>
<tr><td><i>soap.buffering</i> </td><td>when not zero, a send buffer is used </td></tr></table>

</td></tr></table><br></span>
The following initializing and finalizing functions can be used:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i><b>void</b>&nbsp;soap_begin_send(<b>struct</b>&nbsp;soap*)</i>	</td><td>use buffered socket sends when <i>soap.socket</i> <font face="symbol"></font
> 0 </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_end_send(<b>struct</b>&nbsp;soap*)</i> 	</td><td>flush the buffer </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_begin_recv(<b>struct</b>&nbsp;soap*)</i>	</td><td>if an HTTP header is present, parse it first </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_end_recv(<b>struct</b>&nbsp;soap*)</i> 	</td><td>perform a id/href consistancy check on deserialized data </td></tr></table>

</td></tr></table><br></span>

<p>
		      <h4><a name="tth_sEc5.4.1">
5.4.1</a>&nbsp;&nbsp;<font color="#0000FF">Serializing a Data Type</font></h4><a name="sec:serialize">
</a>

<p>
To serialize a data type, two functions need to be called to process the data. The first function (<i>soap_serialize</i>) analyzes
pointers and determines if multi-references are required to encode the data and if the data contains cycles. The second function
(<i>soap_put</i>) generates the SOAP encoding output for that data type.

<p>
The function names are specific to a data type. For example, <i>soap_serialize_float(&amp;soap, &amp;d)</i> is called to serialize an
<i><b>float</b></i> value and <i>soap_put_float(&amp;soap, &amp;d, "number", NULL)</i> is called to output the floating point value in SOAP tagged
with the name <tt>&lt;number&#62;</tt>.  To initialize data, the <i>soap_default</i> function of a data type can be used.  For example,
<i>soap_default_float(&amp;soap, &amp;d)</i> initializes the float to 0.0.  The <i>soap_default</i> functions are useful to initialize complex
data types such as arrays, <i><b>struct</b></i>s, and <i><b>class</b></i> instances.  Note that the <i>soap_default</i> functions do not need
the gSOAP runtime environment as a first parameter.

<p>
The following table lists the type naming conventions used:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Type Name</b></font> </td></tr>
<tr><td><i><b>char</b>*</i> </td><td><i>string</i> </td></tr>
<tr><td><i>wchar_t*</i> </td><td><i>wstring</i> </td></tr>
<tr><td><i><b>char</b></i> </td><td><i>byte</i> </td></tr>
<tr><td><i><b>bool</b></i> </td><td><i>bool</i> </td></tr>
<tr><td><i><b>double</b></i> </td><td><i>double</i> </td></tr>
<tr><td><i><b>int</b></i> </td><td><i>int</i> </td></tr>
<tr><td><i><b>float</b></i> </td><td><i>float</i> </td></tr>
<tr><td><i><b>long</b></i> </td><td><i>long</i> </td></tr>
<tr><td><i>LONG64</i> </td><td><i>LONG64</i> (Win32) </td></tr>
<tr><td><i><b>long</b>&nbsp;<b>long</b></i> </td><td><i>LONG64</i> (Unix/Linux) </td></tr>
<tr><td><i><b>short</b></i> </td><td><i>short</i> </td></tr>
<tr><td><i>time_t</i> </td><td><i>time</i> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>char</b></i> </td><td><i>unsignedByte</i> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>int</b></i> </td><td><i>unsignedInt</i> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b></i> </td><td><i>unsignedLong</i> </td></tr>
<tr><td><i>ULONG64</i> </td><td><i>unsignedLONG64</i> (Win32)</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> </td><td><i>unsignedLONG64</i> (Unix/Linux) </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>short</b></i> </td><td><i>unsignedShort</i> </td></tr>
<tr><td><i><u><span class="roman">T</span></u><span class="roman">[</span><u><span class="roman">N</span></u><span class="roman">]</span></i> </td><td><i>Array<u><span class="roman">N</span></u>Of<u><span class="roman">Type</span></u></i> where <u>Type</u> is the type name of <u>T</u> </td></tr>
<tr><td><i><u><span class="roman">T</span></u>*</i> </td><td><i>PointerTo<u><span class="roman">Type</span></u></i> where <u>Type</u> is the type name of <u>T</u> </td></tr>
<tr><td><i><b>struct</b>&nbsp;Name</i> </td><td><i>Name</i> </td></tr>
<tr><td><i><b>class</b>&nbsp;Name</i> </td><td><i>Name</i> </td></tr>
<tr><td><i><b>enum</b>&nbsp;Name</i> </td><td><i>Name</i> </td></tr></table>

</td></tr></table><br></span>
Consider for example the following declaration of <i>p</i> as a pointer to a <i><b>struct</b>&nbsp;ns__Person</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__Person { <b>char</b>&nbsp;*name; } *p;
</td></tr></table><br></i>
To serialize <i>p</i>, its address is passed to the function <i>soap_serialize_PointerTons__Person</i> generated for this type by
the gSOAP compiler:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_serialize_PointerTons__Person(&amp;soap, &amp;p);
</td></tr></table><br></i>
The <b>address of</b> <i>p</i> is passed, so the serializer can determine whether <i>p</i> was already serialized and to discover
cycles in graph data structures.
To generate the output, the address of <i>p</i> is passed to the function <i>soap_put_PointerTons__Person</i> together with the
name of an XML element and an optional type string (to omit a type, use <i>NULL</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_put_PointerTons__Person(&amp;soap, &amp;p, "ns:element-name", "ns:type-name");
</td></tr></table><br></i>
This produces:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:element-name xmlns:SOAP-ENV="..." xmlns:SOAP-ENC="..." xmlns:ns="..." <br />
&nbsp;&nbsp;&nbsp;... xsi:type="ns:type-name"&#62; <br />
&lt;name xsi:type="xsd:string"&#62;...&lt;/name&#62; <br />
&lt;/ns:element-name&#62;
</td></tr></table><br></tt>
The serializer is initialized with the <i>soap_begin</i> function. All temporary data structures and data structures deserialized
on the heap are destroyed with the <i>soap_end()</i> function.  The <i>soap_free()</i> function can be used to remove the
temporary data only and keep the deserialized data on the heap.  Temporary data structures are only created if the encoded data
uses pointers. Each pointer in the encoded data has an internal hash table entry to determine all multi-reference parts and cyclic
parts of the complete data structure.

<p>
If more than one data structure is to be serialized and parts of those data structures are shared through pointers, then the
<i>soap_serialize</i> functions MUST to be called first before any of the <i>soap_put</i> functions. This is necessary to ensure
that multi-reference data shared by the data structures is encoded as multi-reference.

<p>
For example, to encode the contents of two variables <i>var1</i> and <i>var2</i> the serializers are called before the output routines:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">T1</span></u> var1; <br />
<u><span class="roman">T2</span></u> var2; <br />
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); // initialize at least once <br />
soap_begin(&amp;soap); // start new serialization phase <br />
soap.enable_embedding = 1; // do not use independent elements <br />
soap_serialize_<u><span class="roman">Type1</span></u>(&amp;soap, &amp;var1); <br />
soap_serialize_<u><span class="roman">Type2</span></u>(&amp;soap, &amp;var2); <br />
... <br />
<font size="+1"><span class="roman">[</span></font>soap.socket = a_socket_file_descriptor;<font size="+1"><span class="roman">]</span></font> <br />
<font size="+1"><span class="roman">[</span></font>soap.sendfd = an_output_file_descriptor;<font size="+1"><span class="roman">]</span></font> <br />
<font size="+1"><span class="roman">[</span></font>soap_begin_send(&amp;soap);<font size="+1"><span class="roman">]</span></font> // use buffered socket output <br />
soap_put_<u><span class="roman">Type1</span></u>(&amp;soap, &amp;var1, "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name1", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1"); <br />
soap_put_<u><span class="roman">Type2</span></u>(&amp;soap, &amp;var2, "<font size="+1"><span class="roman">[</span></font>namespace-prefic:<font size="+1"><span class="roman">]</span></font>element-name2", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name2"); <br />
... <br />
<font size="+1"><span class="roman">[</span></font>soap_end_send(&amp;soap);<font size="+1"><span class="roman">]</span></font> // flush buffered socket output <br />
soap_end(&amp;soap); // remove temporary data structures <br />
...
</td></tr></table><br></i>
where <u>Type1</u> is the type name of <u>T1</u> and <u>Type2</u> is the type name of <u>T2</u> (see table
above).  The strings <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1</i> and <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name2</i> describe the schema types
of the elements.  Use <i>NULL</i> to omit this type information.  The output stream is set by the assignment to
<i>soap.sendfd</i>.

<p>
For serializing class instances, method invocations MUST be used instead of function calls, for example
<i>var.soap_serialize(&amp;soap)</i> and <i>var.soap_put(&amp;soap, "elt", "type")</i>.  This ensures that the proper serializers are used for
serializing instances of derived classes.

<p>
In principle, encoding MAY take place without calling the <i>soap_serialize</i> functions. However, as the following example
demonstrates the resulting encoding is not SOAP 1.1 compliant.  However, the messages can still be used with gSOAP to save and
restore data.

<p>
Consider the following <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "tricky.h": <br />
<b>struct</b>&nbsp;Tricky<br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*p; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;n; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*q; <br />
};
</td></tr></table><br></i>
The following fragment initializes the pointer fields <i>p</i> and <i>q</i> to the value of field <i>n</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
<b>struct</b>&nbsp;Tricky X; <br />
X.n = 1; <br />
X.p = &amp;X.n; <br />
X.q = &amp;X.n; <br />
soap_init(&amp;soap); <br />
soap_begin(&amp;soap); <br />
soap_serialize_Tricky(&amp;soap, &amp;X); <br />
soap_put_Tricky(&amp;soap, &amp;X, <tt>"Tricky"</tt>, NULL); <br />
soap_end(&amp;soap); // Clean up temporary data used by the serializer
</td></tr></table><br></i>
The resulting output is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;Tricky xsi:type="Tricky"&#62; <br />
&lt;p href="#2"/&#62;
&lt;n xsi:type="int"&#62;1&lt;/n&#62;
&lt;q href="#2"/&#62;
&lt;r xsi:type="int"&#62;2&lt;/r&#62;
&lt;/Tricky&#62;
&lt;id id="2" xsi:type="int"&#62;1&lt;/id&#62;
</td></tr></table><br></tt>
which uses an independent element at the end to represent the multi-referenced integer.

<p>
To preserve the exact structure of the data, use the setting <i>soap.enable_embedding=1</i> (see Section&nbsp;<a href="#sec:flags">6.6</a>)
to serialize multi-referenced data
embedded in the structure which assures the preservation of structure but is not SOAP 1.1 compliant.
For example, the resulting output is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;Tricky xsi:type="Tricky"&#62; <br />
&lt;p href="#2"/&#62;
&lt;n id="2" xsi:type="int"&#62;1&lt;/n&#62;
&lt;q href="#2"/&#62;
&lt;/Tricky&#62;
</td></tr></table><br></tt>
In this case, the XML is self-contained and multi-referenced data is accurately serialized.
The gSOAP generated deserializer for this data type will be able to accurately reconstruct the data from the XML (on the heap).

<p>
		      <h4><a name="tth_sEc5.4.2">
5.4.2</a>&nbsp;&nbsp;<font color="#0000FF">Deserializing a Data Type</font></h4><a name="sec:deserialize">
</a>

<p>
To deserialize a data type, its <i>soap_get</i> function is used. The outline of a program that deserializes two variables <i>var1</i> and <i>var2</i> is for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">T1</span></u> var1; <br />
<u><span class="roman">T2</span></u> var2; <br />
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); // initialize at least once <br />
soap_begin(&amp;soap); // begin new decoding phase <br />
<font size="+1"><span class="roman">[</span></font>soap.recvfd = an_input_stream;<font size="+1"><span class="roman">]</span></font> <br />
<font size="+1"><span class="roman">[</span></font>soap_begin_recv(&amp;soap);<font size="+1"><span class="roman">]</span></font> // if HTTP header is present, parse it <br />
soap_get_<u><span class="roman">Type1</span></u>(&amp;soap, &amp;var1, "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name1", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1"); <br />
soap_get_<u><span class="roman">Type2</span></u>(&amp;soap, &amp;var2, "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name2", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1"); <br />
... <br />
<font size="+1"><span class="roman">[</span></font>soap_end_recv(&amp;soap);<font size="+1"><span class="roman">]</span></font> // check consistancy of id/hrefs <br />
soap_end(&amp;soap); // remove temporary data, including the decoded data on the heap
</td></tr></table><br></i>
The strings <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1</i> and <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name2</i> are the schema types of the
elements and should match the <tt>xsi:type</tt> attribute of the receiving message. To omit the match, use <i>NULL</i> as the type.
For class instances, method invocation can be used instead of a function call if the object is already instantiated, i.e.
<i>var.soap_get(&amp;soap, "...", "...")</i>.

<p>
The <i>soap_begin</i> call resets the deserializers. The <i>soap_end</i> call removes the temporary data structures <b>
and</b> the decoded data that was placed on the heap. Temporary data is created only if the SOAP content includes <tt>id</tt> and
<tt>href</tt> attributes. An internal hash table is used by the deserializer to bound the <tt>id</tt> with the <tt>href</tt> names to
reconstruct the shape of the data structure.

<p>
To remove temporary data while retaining the deserilzed data on the heap, the function <i>soap_free</i> should be called instead
of <i>soap_end</i>.

<p>
		      <h4><a name="tth_sEc5.4.3">
5.4.3</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example9">
</a>

<p>
As an example, consider the following data type declarations:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "person.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__Name; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;xsd__unsignedInt; <br />
<b>enum</b>&nbsp;ns__Gender {male, female}; <br />
<b>class</b>&nbsp;ns__Address <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__string street; <br />
&nbsp;&nbsp;&nbsp;xsd__unsignedInt number; <br />
&nbsp;&nbsp;&nbsp;xsd__string city; <br />
}; <br />
<b>class</b>&nbsp;ns__Person <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__Name name; <br />
&nbsp;&nbsp;&nbsp;<b>enum</b>&nbsp;ns__Gender gender; <br />
&nbsp;&nbsp;&nbsp;ns__Address address; <br />
&nbsp;&nbsp;&nbsp;ns__Person *mother; <br />
&nbsp;&nbsp;&nbsp;ns__Person *father; <br />
};
</td></tr></table><br></i>
The following program uses these data types to store a person named "John" living at Dowling st. 10 in Londen. He has a mother
"Mary" and a father "Stuart". After initialization, the class instance for "John" is serialized and encoded in SOAP to the
standard output stream:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "person.cpp": <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ns__Person mother, father, john; <br />
&nbsp;&nbsp;&nbsp;soap.enable_embedding = 1; // see&nbsp;<a href="#sec:flags">6.6</a> <br />
&nbsp;&nbsp;&nbsp;mother.name = <tt>"Mary"</tt>; <br />
&nbsp;&nbsp;&nbsp;mother.gender = female; <br />
&nbsp;&nbsp;&nbsp;mother.address.street = <tt>"Dowling st."</tt>; <br />
&nbsp;&nbsp;&nbsp;mother.address.number = 10; <br />
&nbsp;&nbsp;&nbsp;mother.address.city = <tt>"London"</tt>; <br />
&nbsp;&nbsp;&nbsp;mother.mother = NULL; <br />
&nbsp;&nbsp;&nbsp;mother.father = NULL; <br />
&nbsp;&nbsp;&nbsp;father.name = <tt>"Stuart"</tt>; <br />
&nbsp;&nbsp;&nbsp;father.gender = male; <br />
&nbsp;&nbsp;&nbsp;father.address.street = <tt>"Main st."</tt>; <br />
&nbsp;&nbsp;&nbsp;father.address.number = 5; <br />
&nbsp;&nbsp;&nbsp;father.address.city = <tt>"London"</tt>; <br />
&nbsp;&nbsp;&nbsp;father.mother = NULL; <br />
&nbsp;&nbsp;&nbsp;father.father = NULL; <br />
&nbsp;&nbsp;&nbsp;john.name = <tt>"John"</tt>; <br />
&nbsp;&nbsp;&nbsp;john.gender = male; <br />
&nbsp;&nbsp;&nbsp;john.address = mother.address; <br />
&nbsp;&nbsp;&nbsp;john.mother = &amp;mother; <br />
&nbsp;&nbsp;&nbsp;john.father = &amp;father; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;john.soap_serialize(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;john.soap_put(&amp;soap, <tt>"johnnie"</tt>, NULL); <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "urn:person"}, // Namespace URI of the ``Person'' data type <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
The header file is processed and the application compiled on Linux/Unix with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 person.h</i> <br />
<i>g++ -o person person.cpp soapC.cpp stdsoap2.cpp -lsocket -lxnet -lnsl -lm</i>
</td></tr></table><br></span>
(Depending on your system configuration, the libraries <i>libsocket.a</i>,
<i>libxnet.a</i>, <i>libnsl.a</i>
are required. Compiling on Linux typically does not require the inclusion of those
libraries.)

<p>
Running the <i>person</i> application results in the SOAP output:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;johnnie xsi:type="ns:Person" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="urn:person" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;name xsi:type="xsd:Name"&#62;John&lt;/name&#62; <br />
&lt;gender xsi:type="ns:Gender"&#62;male&lt;/gender&#62; <br />
&lt;address xsi:type="ns:Address"&#62; <br />
&lt;street id="3" xsi:type="xsd:string"&#62;Dowling st.&lt;/street&#62; <br />
&lt;number xsi:type="unsignedInt"&#62;10&lt;/number&#62; <br />
&lt;city id="4" xsi:type="xsd:string"&#62;London&lt;/city&#62; <br />
&lt;/address&#62; <br />
&lt;mother xsi:type="ns:Person"&#62; <br />
&lt;name xsi:type="xsd:Name"&#62;Mary&lt;/name&#62; <br />
&lt;gender xsi:type="ns:Gender"&#62;female&lt;/gender&#62; <br />
&lt;address xsi:type="ns:Address"&#62; <br />
&lt;street href="#3"/&#62; <br />
&lt;number xsi:type="unsignedInt"&#62;5&lt;/number&#62; <br />
&lt;city href="#4"/&#62; <br />
&lt;/address&#62; <br />
&lt;/mother&#62; <br />
&lt;father xsi:type="ns:Person"&#62; <br />
&lt;name xsi:type="xsd:Name"&#62;Stuart&lt;/name&#62; <br />
&lt;gender xsi:type="ns:Gender"&#62;male&lt;/gender&#62; <br />
&lt;address xsi:type="ns:Address"&#62; <br />
&lt;street xsi:type="xsd:string"&#62;Main st.&lt;/street&#62; <br />
&lt;number xsi:type="unsignedInt"&#62;13&lt;/number&#62; <br />
&lt;city href="#4"/&#62; <br />
&lt;/address&#62; <br />
&lt;/father&#62; <br />
&lt;/johnnie&#62;
</td></tr></table><br></tt>
The following program fragment decodes this content and reconstructs the orignal data structure on the heap:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ns__Person *mother, *father, *john = NULL; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_get_ns__Person(&amp;soap, john, "johnnie", NULL); <br />
&nbsp;&nbsp;&nbsp;mother = john<tt>-&gt;</tt>mother; <br />
&nbsp;&nbsp;&nbsp;father = john<tt>-&gt;</tt>father; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_free(&amp;soap); // Clean up temporary data but keep deserialized data <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "urn:person"}, // Namespace URI of the ``Person'' data type <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
It is REQUIRED to either pass <i>NULL</i> to the <i>soap_get</i> routine, or a valid pointer to a data structure that can
hold the decoded content. The following example explicitly passes <i>NULL</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
&nbsp;&nbsp;&nbsp;john = soap_get_ns__Person(&amp;soap, NULL, "johnnie", NULL); <br />
</td></tr></table><br></i>
Note: the second <i>NULL</i> parameter indicates that the schema type attribute of the receiving message can be ignored.
The deserializer stores the SOAP contents on the heap, and returns the address. The allocated storage is released with the
<i>soap_end</i> call, which removes all temporary and deserialized data from the heap, or with the <i>soap_free</i> call, which removes all
temporary data only.

<p>
Alternatively, the SOAP content can be decoded within an existing allocated data structure.
The following program fragment decodes the SOAP content in a <i><b>struct</b>&nbsp;ns__Person</i> allocated on the stack:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
main() <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ns__Person *mother, *father, john; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_default_ns__Person(&amp;soap, &amp;john); <br />
&nbsp;&nbsp;&nbsp;soap_get_ns__Person(&amp;soap, &amp;john, "johnnie", NULL); <br />
&nbsp;&nbsp;&nbsp;mother = john<tt>-&gt;</tt>mother; <br />
&nbsp;&nbsp;&nbsp;father = john<tt>-&gt;</tt>father; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_free(&amp;soap); <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
&nbsp;&nbsp;&nbsp;...
</td></tr></table><br></i>
Note the use of <i>soap_default_ns__Person</i>. This routine is generated by the gSOAP stub and skeleton compiler and assigns default
values to the fields of <i>john</i>.

<p>
		      <h4><a name="tth_sEc5.4.4">
5.4.4</a>&nbsp;&nbsp;<font color="#0000FF">Default Values for Deserializing Omitted Data</font></h4>

<p>
The gSOAP compiler generates <i>soap_default</i> functions for all data types.  The default values of the primitive types can be
easily changed by defining any of the following macros in the <i>stdsoap2.h</i> file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define SOAP_DEFAULT_bool <br />
#define SOAP_DEFAULT_byte <br />
#define SOAP_DEFAULT_double <br />
#define SOAP_DEFAULT_float <br />
#define SOAP_DEFAULT_int <br />
#define SOAP_DEFAULT_long <br />
#define SOAP_DEFAULT_LONG64 <br />
#define SOAP_DEFAULT_short <br />
#define SOAP_DEFAULT_string <br />
#define SOAP_DEFAULT_time <br />
#define SOAP_DEFAULT_unsignedByte <br />
#define SOAP_DEFAULT_unsignedInt <br />
#define SOAP_DEFAULT_unsignedLong <br />
#define SOAP_DEFAULT_unsignedLONG64 <br />
#define SOAP_DEFAULT_unsignedShort <br />
#define SOAP_DEFAULT_wstring
</td></tr></table><br></i>
Instead of adding these to <i>stdsoap2.h</i>, you can also compile with option <i>-DWITH_USERDEFS_H</i> and include your
definitions in file <i>userdefs.h</i>.
The absence of a data value in a receiving SOAP message will result in the assignment of a default value to a primitive type upon
deserialization.

<p>
Default values can also be assigned to individual <i><b>struct</b></i> and <i><b>class</b></i> fields of primitive type. For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;MyRecord <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name = &#220;nknown"; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;value = 9999; <br />
&nbsp;&nbsp;&nbsp;<b>enum</b>&nbsp;Status { active, passive } status = passive; <br />
}
</td></tr></table><br></i>
These default values are implicitly assigned to the fields when data values are absent in a receiving SOAP message.

<p>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;<font color="#0000FF">Using the gSOAP Stub and Skeleton Compiler</font></h2>

<p>
The gSOAP stub and skeleton compiler is invoked from the command line and optionally takes the name of a header file as an
argument or, when the file name is absent, parses the standard input:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 <font size="+1"><span class="roman">[</span></font>aheaderfile.h<font size="+1"><span class="roman">]</span></font></i>
</td></tr></table><br></span>
where <i>aheaderfile.h</i> is a standard C++ header file. The compiler acts as a preprocessor and produces C++ source files that
can be used to build SOAP client and Web service applications in C++. The files generated by the compiler are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>File Name</b></font> </td><td width="501"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soapH.h</i> </td><td width="501">Main header file to be included by all client and service sources </td></tr>
<tr><td><i>soapC.cpp</i> </td><td width="501">Serializers and deserializers for the specified data structures </td></tr>
<tr><td><i>soapClient.cpp</i> </td><td width="501">Client stub routines and proxies for all remote methods </td></tr>
<tr><td><i>soapServer.cpp</i> </td><td width="501">Service skeleton routines </td></tr>
<tr><td><i>soapStub.h</i> </td><td width="501">A modified header file produced from the compiler input header file </td></tr>
<tr><td><i>.xsd</i> </td><td width="501">An <i>ns.xsd</i> file is generated with an XML schema for each namespace prefix <i>ns</i> used by a data structure in the header
file input to the compiler, see Section&nbsp;<a href="#sec:wsdl">5.2.5</a> </td></tr>
<tr><td><i>.wsdl</i> </td><td width="501">A <i>ns.wsdl</i> file is generated with an WSDL description for each namespace prefix <i>ns</i> used by a remote method in the
header file input to the compiler, see Section&nbsp;<a href="#sec:wsdl">5.2.5</a> </td></tr>
<tr><td><i>.nsmap</i> </td><td width="501">A <i>ns.nsmap</i> file is generated for each namespace prefix <i>ns</i> used by a remote method in the
header file input to the compiler, see Section&nbsp;<a href="#sec:wsdl">5.2.5</a>.  The file contains a namespace mapping table that can be used in the client/service sources </td></tr></table>

</td></tr></table><br></span>
Both client and service applications are developed from a header file that specifies the remote methods. If client and
service applications are developed with the same header file, the applications are guaranteed to be compatible because the stub and skeleton routines use
the same serializers and deserializers ot encode and decode the parameters. Note that when client and service applications are developed together, an application developer does
not need to know the details of the internal SOAP encoding used by the client and service.

<p>
The following files are part of the gSOAP package and are required to build client and service applications:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>File Name</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>stdsoap2.h</i> </td><td>Header file of <i>stdsoap2.cpp</i> runtime library </td></tr>
<tr><td><i>stdsoap2.c</i> </td><td>Runtime C library with XML parser and run-time support routines </td></tr>
<tr><td><i>stdsoap2.cpp</i> </td><td>Runtime C++ library identical to <i>stdsoap2.c</i> </td></tr></table>

</td></tr></table><br></span>

<p>
	     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;<font color="#0000FF">Compiler Options</font></h3>

<p>
The compiler supports the following options:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Option</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>-h</i>	</td><td>Print a brief usage message </td></tr>
<tr><td><i>-c</i>	</td><td>Save files using extension <i>.c</i> instead of <i>.cpp</i> </td></tr>
<tr><td><i>-m</i>	</td><td>Generate code that requires array/binary classes to explicitly free malloced array </td></tr>
<tr><td><i>-d  &lt; path &gt; </i>	</td><td>Save sources in directory specified by <i> &lt; path &gt; </i> </td></tr>
<tr><td><i>-p  &lt; name &gt; </i>	</td><td>Save sources with file name prefix <i> &lt; name &gt; </i> instead of ``<i>soap</i>'' </td></tr></table>

</td></tr></table><br></span>
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 -cd '../projects' -pmy file.h</i>
</td></tr></table><br></span>
Saves the sources:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>../projects/myH.h</i> <br />
<i>../projects/myC.c</i> <br />
<i>../projects/myClient.c</i> <br />
<i>../projects/myServer.c</i> <br />
<i>../projects/myStub.h</i> <br />
</td></tr></table><br></span>
MS Windows users can use the usual ``<i>/</i>'' for options, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 /cd '..\projects' /pmy file.h</i>
</td></tr></table><br></span>

<p>
	     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;<font color="#0000FF">Compiling a SOAP C++ Client</font></h3>

<p>
After invoking the gSOAP stub and skeleton compiler on a header file description of a service, the client application can be compiled on a Linux machine as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp</i>
</td></tr></table><br></span>
Or on a Unix machine:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lm</i>
</td></tr></table><br></span>
(Depending on your system configuration, the libraries <i>libsocket.a</i>,
<i>libxnet.a</i>, <i>libnsl.a</i> or dynamic <i>*.so</i> versions of those libraries are required.)

<p>
The <i>myclient.cpp</i> file must include <i>soapH.h</i> and must define a global namespace mapping table. A typical client program layout with namespace mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "myclient.cpp" <br />
#include "soapH.h"; <br />
... <br />
// A remote method invocation: <br />
&nbsp;&nbsp;&nbsp;soap_call_some_remote_method(...); <br />
... <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1",      "urn:my-remote-method"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
}; <br />
...
</td></tr></table><br></i>
A mapping table is generated by the gSOAP compiler that can be used in the source, see Section&nbsp;<a href="#sec:wsdl">5.2.5</a>.

<p>
	     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;<font color="#0000FF">Compiling a SOAP C++ Web Service</font></h3>

<p>
After invoking the gSOAP stub and skeleton compiler on a header file description of the service, the server application can be compiled on a Linux machine as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myserver myserver.cpp stdsoap2.cpp soapC.cpp soapServer.cpp</i>
</td></tr></table><br></span>
Or on a Unix machine:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myserver myserver.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lsocket -lxnet -lm</i>
</td></tr></table><br></span>
(Depending on your system configuration, the libraries <i>libsocket.a</i>,
<i>libxnet.a</i>, <i>libnsl.a</i> or dynamic <i>*.so</i> versions of those libraries are required.)

<p>
The <i>myserver.cpp</i> file must include <i>soapH.h</i> and must define a global namespace mapping table. A typical service program layout with namespace mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "myserver.cpp" <br />
#include "soapH.h"; <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
} <br />
... <br />
// Implementations of the remote methods as C++ functions <br />
... <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1",      "urn:my-remote-method"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
}; <br />
...
</td></tr></table><br></i>
When the serive application is compiled as a CGI application, the <i>soap_serve</i> function acts as a service dispatcher. It listens to standard input and
invokes the method via a skeleton routine to serve a SOAP client request. After the request is served, the response is encoded in
SOAP and send to standard output. The method must be implemented in the server application and the type signature of the method
must be identical to the remote method specified in the header file. That is, the function prototype in the header file must be a
valid prototype of the method implemented as a C++ function.

<p>
	     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;<font color="#0000FF">Using gSOAP for Creating Web Services and Clients in C</font></h3>

<p>
The gSOAP compiler can be used to create C (instead of C++) Web services and clients. The gSOAP stub and skeleton compiler
<i>soapcpp2</i> generates <i>.cpp</i> files by default. However, these files only use C syntax and data types <b>if</b> the header
file input to <i>soapcpp2</i> uses C syntax and data types. Therefore, a C compiler can be used to compile the <i>.cpp</i> files
(e.g. by renaming the extensions to <i>.c</i>) to create C Web service and client executables.
For example, with symbolic links on Unix/Linux:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>ln -s soapC.cpp soapC.c</i> <br />
<i>ln -s soapClient.cpp soapClient.c</i> <br />
<i>ln -s soapServer.cpp soapServer.c</i> <br />
<i>soapcpp2 quote.h</i> <br />
<i>gcc quote.c stdsoap2.c soapC.c soapClient.c</i>
</td></tr></table><br></span>

<p>
	     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;<font color="#0000FF">Limitations of gSOAP</font></h3><a name="sec:limitations">
</a>

<p>
gSOAP is fully SOAP 1.1 (and partly SOAP 1.2) compliant and supports all SOAP 1.1 RPC features.

<p>
From the perspective of the C/C++ language, a few C++ language features are not supported by gSOAP and these features cannot be used in the specification of SOAP remote methods.

<p>
The following C++ language constructs cannot be used by the header file input to the SOAP C++ stub and skeleton compiler:

<dl compact="compact">
 <dt><b>Templates</b></dt>
	<dd> The SOAP C++ stub and skeleton compiler is a preprocessor and cannot predict the template intantations used by the main program, nor can it generate templated code.</dd>
 <dt><b>Multiple inheritance</b></dt>
	<dd> Single class inheritance is supported. Multiple inheritance cannot be supported due to limitations of the SOAP protocol.</dd>
 <dt><b>Abstract methods</b></dt>
	<dd> A class must be instantiatable to allow decoding of instances of the class.</dd>
 <dt><b>Pragmas</b></dt>
	<dd> All pragmas such as <i>#include</i> and <i>#define</i> are not supported. All pragmas are ignored by the compiler.
A traditional C++
preprocessor can be used for the interpretation of pragmas. For example, Unix and Linux users can use ``<tt>cpp -B</tt>''
to expand the header file, e.g. <tt>cpp -B myfile.h | soapcpp2</tt>.</dd>
 <dt><b>C and C++ programming statements</b></dt>
	<dd> All class methods of a class should be declared within the class declaration in the header file, but the methods should not be implemented in code. All class method implementations must be defined within another C++ source file and linked to the application.</dd>
</dl>
In addition, the following data types cannot be used in the header file
(they can, however be used as a class method return type and as class method parameter types of a class declared in the header file):

<dl compact="compact">
 <dt><b><i><b>union</b></i> types</b></dt>
	<dd> Because the run-time value of a <i><b>union</b></i> data type cannot be determined by the compiler, the data type cannot be encoded. An alternative is to use a <i><b>struct</b></i> with a pointer type for each field. Because <i>NULL</i> pointers are not encoded, the resulting encoding will appear as a union type if only one pointer field is valid (i.e.&nbsp;non-<i>NULL</i>) at the time that the data type is encoded.</dd>
 <dt><b><i><b>void</b></i> and <i><b>void</b>*</i> types</b></dt>
	<dd> The <i><b>void</b></i> data type cannot be encoded. The <i><b>void</b>*</i> data type is typically used to point to some object or to some array of some type of objects at run-time. The compiler cannot determine the type of data pointed to and the size of the array pointed to.</dd>
 <dt><b>Pointers to sequences of elements in memory</b></dt>
	<dd> Any pointer, except for C strings which are pointers to a sequence of
characters, are treated by the compiler as if the pointer points to <b>only one element in memory</b> at run-time. Consequently,
the encoding and decoding routines will ignore any subsequent elements that follow the first in memory. For the same reason,
arrays of undetermined length, e.g.&nbsp;<i><b>float</b>&nbsp;a[]</i> cannot be used. gSOAP supports dynamic arrays using a special type convention,
see Section&nbsp;<a href="#sec:dynarray">8.8</a>.</dd>
 <dt><b>Uninitialized pointers</b></dt>
	<dd> Obviously, all pointers that are part of a data structure must be valid or <i>NULL</i> to enable
serialization of the data structure at run time.</dd>
</dl>
There are a number of programming solutions that can be adopted to circumvent these limitations. Instead of using <i><b>void</b>*</i>, a program
can in some cases be modified to use a pointer to a known type. If the pointer is intended to point to different types of objects, a generic
base class can be declared and the pointer is declared to point to the base class. All the other types are declared to be derived
classes of this base class. For pointers that point to a sequence of elements in memory dynamic arrays should be used instead,
see <a href="#sec:dynarray">8.8</a>.

<p>
	     <h3><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;<font color="#0000FF">gSOAP Serialization Options and Flags</font></h3><a name="sec:flags">
</a>

<p>
The gSOAP runtime environment flag variables can be set (i.e.&nbsp;<i>1</i>, where default is <i>0</i> which means off) to control the SOAP XML
serialization of data with gSOAP.
Although gSOAP is fully SOAP 1.1 compliant, some SOAP implementations may have trouble accepting
multi-reference data and implicit null data so these flags can be used to put gSOAP in ``safe mode''.  In addition, the embedding of multi-reference data is a feature that is likely to be adopted
in future SOAP specifications which gSOAP already supports (turned off by default).
The flags are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Flag</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap.disable_href</i> </td><td>Do not serialize multi-reference data, but copy data in SOAP payload </td></tr>
<tr><td><i>soap.enable_embedding</i> </td><td>Embed multi-reference data instead of encoding independent elements </td></tr>
<tr><td><i>soap.enable_null</i> </td><td>Always output null pointers with XML <tt>xsi:nil="true"</tt> attribute </td></tr>
<tr><td></td><td>Fault when <tt>xsi:nil="true"</tt> attribute is received for a non-pointer </td></tr>
<tr><td></td><td>data type (normally default value)</td></tr>
<tr><td><i>soap.enable_utf_string</i> </td><td>Store and emit UTF8/16 encoded strings (<i><b>char</b>*</i>) without translation </td></tr>
<tr><td><i>soap.disable_request_count</i> </td><td>Do not include HTTP Content-Length in service request </td></tr>
<tr><td><i>soap.disable_response_count</i> </td><td>Do not include HTTP Content-Length in service response (use this option </td></tr>
<tr><td></td><td>for CGI applications as the Web server determines Content-Length) </td></tr>
<tr><td><i>soap.enable_array_overflow</i> </td><td>Do not fault when receiving excess elements that do not fit in a fixed-size array </td></tr></table>

</td></tr></table><br></span>
The flags can also be selectively turned on/off when multiple Web services are accessed by a client.
The flags control the serialization only.  Deserialization can handle all different serialization formats automatically.

<p>
<font color="#FF0000"><b>Caution</b></font>: Disabling hrefs (multi-reference data output) can be used to improve interoperability with SOAP implementations that
are not fully SOAP 1.1 compliant.  However, disabling hrefs will crash the serializer for cyclic data structures.

<p>
	     <h3><a name="tth_sEc6.7">
6.7</a>&nbsp;&nbsp;<font color="#0000FF">Memory Management</font></h3><a name="sec:memory">
</a>

<p>
Understanding gSOAP's run-time memory management is important to optimize client and service applications by eliminating
memory leaks and/or dangling references.

<p>
There are two forms of dynamic (heap) allocations made by gSOAP's runtime for serialization and deserialization of data.
Temporary data is created by the runtime such as hash tables to keep pointer reference information for serialization and hash
tables to keep XML id/href information for multi-reference object deserialization.  Deserialized data is created upon receiving
SOAP messages.  This data is stored on the heap and involves calls to the <i>malloc</i> library function and <i><b>new</b></i> to create
class instances.  All such allocations are tracked by gSOAP's runtime by linked lists for later deallocation.  The linked list for
<i>malloc</i> allocations uses some extra space in each <i>malloc</i>ed block to form a chain of pointers through the <i>malloc</i>ed
blocks.  A separate <i>malloc</i>ed linked list is used to keep track of class instance allocations.

<p>
gSOAP does not enforce a deallocation policy and the user can adopt a deallocation policy that works best for a particular
application.  As a consequence, deserialized data is never deallocated by the gSOAP runtime unless the user explicitly forces
deallocation by calling deallocation functions.

<p>
The deallocation functions are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function Call</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_end(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Remove temporary data and deserialized data except class instances </td></tr>
<tr><td><i>soap_free(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Remove temporary data only </td></tr>
<tr><td><i>soap_destroy(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Remove all dynamically allocated class instances </td></tr>
<tr><td></td><td>Need to be called before <i>soap_end()</i> </td></tr>
<tr><td><i>soap_dealloc(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*p)</i> </td><td>Remove data/object at <i>p</i>. When <i>p==NULL</i>: remove all dynamically </td></tr>
<tr><td></td><td>allocated (deserialized) data except class instances </td></tr>
<tr><td><i>soap_unlink(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*p)</i> </td><td>Unlink data/object at <i>p</i> from gSOAP's deallocation chain </td></tr>
<tr><td></td><td>so gSOAP won't deallocate it </td></tr>
<tr><td><i>soap_done(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Reset: close (master/slave) sockets and remove callbacks (Section&nbsp;<a href="#sec:callback">12.6</a> </td></tr></table>

</td></tr></table><br></span>
Temporary data (i.e.&nbsp;the hash tables) are automatically removed with a call to the <i>soap_free</i> function when the next call to a stub or skeleton routine is made.
Deallocation of non-class based data is straightforward: <i>soap_end</i> removes all dynamically allocated deserialized data (data
allocated with <i>soap_malloc</i>.
That is, when the client/service application does not use any class instances that are (de)marshalled, but uses structs,
arrays, etc., then calling the <i>soap_end</i> function is safe to remove all deserialized data.  The function can be
called after processing the deserialized data of a remote method call or after a number of remote method calls have been made.
The function is also typically called after <i>soap_serve</i>, when the service finished sending the response to a client and the
deserialized client request data can be removed.

<p>
There are three situations to consider for memory deallocation policies for class instances:

<ol type="1"><p>
<li> the program code deletes the class
instances and the class destructors in turn SHOULD delete and free any dynamically allocated data (deep deallocation) without
calling the <i>soap_end</i> and <i>soap_destroy</i> functions,</li>
<p>
<li> or the class
destructors SHOULD NOT deallocate any data and the <i>soap_end</i> and <i>soap_destroy</i> functions can be called to remove
the data.</li>
<p>
<li> or the class
destructors SHOULD mark their own deallocation and mark the deallocation of any other data deallocated by it's destructors
by calling the <i>soap_unlink</i> function. This allows
<i>soap_destroy</i> and <i>soap_end</i> to remove the remaining instances and data without causing duplicate deallocations.</li>
</ol>
With the <i>-m</i> option of <i>soapcpp2</i> enabled, there is one exception which requires explicit deallocation of <i>malloc</i>ed data in
the destructors of classes for array binary types:

<ul><p>
<li> A dynamic array class with non-class elements SHOULD delete the contents of the array it points to as part of its destructor's operations (this includes classes for <i>hexBinary</i> and
<i>base64Binary</i> schema types.</li>
</ul>
It is adviced to use pointers to class instances that are used within other structs and classes to avoid the creation of temporary
class instances. The problem with temporary class instances is that the destructor of the temporary may affect data used by
other instances through the sharing of data parts accessed with pointers.
A dynamic array of class instances is similar: temporaries may be created to fill the array upon deserialization. To avoid
problems, use dynamic arrays of pointers to class instances. This also enables the exchange of polymorphic arrays when the
elements are instances of classes in an inheritance hierarchy.
To summarize, it is adviced to pass class data types by pointer to a remote method. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;X { ... }; <br />
ns__remoteMethod(X *in, ...);
</td></tr></table><br></i>
Response elements that are class data types can be passed by reference, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;X { ... }; <br />
<b>class</b>&nbsp;ns__remoteMethodResponse { ... }; <br />
ns__remoteMethod(X *in, ns__remoteMethodResponse &amp;out);
</td></tr></table><br></i>
But dynamic arrays declared as class data types should use a pointer to a valid object that will be overwritten, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int; <br />
<b>class</b>&nbsp;X { ... }; <br />
<b>class</b>&nbsp;ArrayOfint { xsd__int *__ptr; <b>int</b>&nbsp;__size; }; <br />
ns__remoteMethod(X *in, ArrayOfint *out);
</td></tr></table><br></i>
Or a reference to a valid or <i>NULL</i> pointer, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int; <br />
<b>class</b>&nbsp;X { ... }; <br />
<b>class</b>&nbsp;ArrayOfint { xsd__int *__ptr; <b>int</b>&nbsp;__size; }; <br />
ns__remoteMethod(X *in, ArrayOfint *&amp;out);
</td></tr></table><br></i>
The gSOAP memory allocation functions can be used in client and/or service code to allocate temporary data that will be
automatically deallocated.
These functions are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function Call</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i><b>void</b>&nbsp;*soap_malloc(<b>struct</b>&nbsp;soap *soap, size_t n)</i> </td><td>return pointer to <i>n</i> bytes </td></tr>
<tr><td><i><u><span class="roman">Class</span></u> *soap_new_<u><span class="roman">Class</span></u>(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;n)</i> </td><td>instantiate <i>n</i> <u><span class="roman">CLass</span></u> objects </td></tr></table>

</td></tr></table><br></span>
The <i>soap_new_X</i> functions are generated by the gSOAP compiler for every class <i>X</i> in the header file.
Parameter <i>n</i> MUST be <i>-1</i> to instantiate a single object or  <font face="symbol"></font
> 0 to instantiate an array of <i>n</i> objects.

<p>
Space allocated with <i>soap_malloc</i> will be released with the <i>soap_end</i> and <i>soap_dealloc</i> functions.
The objects instantiated with <i>soap_new_X</i> are removed with <i>soap_destroy</i>.
For example, the following service uses temporary data in the remote method implementation:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
An example remote method that allocates a temporary string is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__itoa(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;i, <b>char</b>&nbsp;**a) <br />
{ <br />
&nbsp;&nbsp;&nbsp;*a = (char*)soap_malloc(soap, 11); <br />
&nbsp;&nbsp;&nbsp;sprintf(*a, "%d", i); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>
This temporary allocation can also be used to allocate strings for the SOAP Fault data structure. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__mymethod(...) <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(exception) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_fault(soap); // allocate Fault data <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>faultstring = (<b>char</b>*)soap_malloc(soap, 1024); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>faultstring, ...); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_FAULT; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
When a class has a <i><b>struct</b>&nbsp;soap *</i> field, this field will be set to point to the current gSOAP run-time environment by
gSOAP's deserializers.
This simplifies memory management for class instances.
The <i><b>struct</b>&nbsp;soap*</i> pointer is implicitly set by the gSOAP deserializer for
the class or explicitly by calling the <i>soap_new_X</i> function for class <i>X</i>.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;Sample <br />
{ <b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; // reference to gSOAP's run-time <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;Sample(); <br />
&nbsp;&nbsp;&nbsp;~Sample(); <br />
};
</td></tr></table><br></i>
The constructor and destructor for class <i>Sample</i> are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
Sample::Sample() <br />
{ this<tt>-&gt;</tt>soap = NULL; <br />
} <br />
Sample::~Sample() <br />
{ soap_unlink(this<tt>-&gt;</tt>soap, this); <br />
}
</td></tr></table><br></i>
The <i>soap_unlink()</i> call removes the object from gSOAP's deallocation chain.
In that way, <i>soap_destroy</i> can be safely called to remove all class instances.
The following code illustrates the explicit creation of a <i>Sample</i> object and cleanup:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap *soap = soap_new(); // new gSOAP runtime <br />
Sample *obj = soap_new_Sample(soap, -1); // new Sample object with obj<tt>-&gt;</tt>soap set to runtime <br />
... <br />
<b>delete</b>&nbsp;obj; // also calls soap_unlink to remove obj from the deallocation chain <br />
soap_destroy(soap); // deallocate all (other) class instances <br />
soap_end(soap); // clean up
</td></tr></table><br></i>
Here is another example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;ns__myClass <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; // set by soap_new_ns__myClass() <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;setName(<b>const</b>&nbsp;<b>char</b>&nbsp;*s); <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
Calls to <i>soap_new_ns__myClass(soap, n)</i> will set the <i>soap</i> field in the class instance to the current gSOAP
environment. Because the deserializers invoke the <i>soap_new</i> functions, the <i>soap</i> field of the <i>ns__myClass</i>
instances are set as well.
This mechanism is convenient when Web Service methods need to return objects that are instantiated in the methods.
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__myMethod(<b>struct</b>&nbsp;soap *soap, ...) <br />
{ <br />
&nbsp;&nbsp;&nbsp;ns__myClass *p = soap_new_ns__myClass(soap, -1); <br />
&nbsp;&nbsp;&nbsp;p-&#62;setName("SOAP"); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
<b>void</b>&nbsp;ns__myClass::ns__setName(<b>const</b>&nbsp;<b>char</b>&nbsp;*s) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = (<b>char</b>*)soap_malloc(soap, strlen(s)+1); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = (<b>char</b>*)malloc(strlen(s)+1); <br />
&nbsp;&nbsp;&nbsp;strcpy(name, s); <br />
} <br />
ns__myClass::ns__myClass() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap = NULL; <br />
&nbsp;&nbsp;&nbsp;name = NULL; <br />
} <br />
ns__myClass::~ns__myClass() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap &amp;&amp; name) free(name); <br />
&nbsp;&nbsp;&nbsp;soap_unlink(soap, this); <br />
} 
</td></tr></table><br></i>
Calling <i>soap_destroy</i> right after <i>soap_serve</i> in the Web Service will destroy all dynamically allocated
class instances.

<p>
	     <h3><a name="tth_sEc6.8">
6.8</a>&nbsp;&nbsp;<font color="#0000FF">Debugging</font></h3>

<p>
To activate message logging for debugging, un-comment the <i>#define DEBUG</i> pragma in <i>stdsoap2.h</i>. Compile the client and/or
server applications as described above (or simply use <i>g++ -DDEBUG ...</i> to compile with debugging activated). When the client and server applications run, they will log their activity in three
separate files:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>File</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>SENT.log</i> </td><td>The SOAP content transmitted by the application </td></tr>
<tr><td><i>RECV.log</i> </td><td>The SOAP content received by the application </td></tr>
<tr><td><i>TEST.log</i> </td><td>A log containing various activities performed by the application </td></tr></table>

</td></tr></table><br></span>
<font color="#FF0000"><b>Caution</b></font>: The client and server applications may run slow due to the logging activity.

<p>
<font color="#FF0000"><b>Caution</b></font>: When installing a CGI application on the Web with debugging activated, the log files may sometimes not be created due to file
access permission restrictions imposed on CGI applications. To get around this, create empty log files with universal write
permissions. Be careful about the security implication of this.

<p>
You can test a service CGI application without deploying it on the Web.
To do this, create a client application for the service and activate message logging by this client.
Remove any old <i>SENT.log</i> file and run the client (which connects to the Web service or to another dummy, but valid address)
and copy the <i>SENT.log</i> file to another file, e.g. <i>SENT.tst</i>.
Then redirect the <i>SENT.tst</i> file to the service CGI application.  For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>myservice.cgi</i>  &lt;  <i>SENT.tst</i>
</td></tr></table><br></span>
This should display the service response on the terminal.

<p>
The file names of the log files and the logging activity can be controlled at the application level. This allows the creation of
separate log files by separate services, clients, and threads.
For example, the following service logs all SOAP messages (but no debug messages) in separate directories:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
... <br />
soap_set_recv_logfile(&amp;soap, "logs/recv/service12.log"); // append all messages received in /logs/recv/service12.log <br />
soap_set_sent_logfile(&amp;soap, "logs/sent/service12.log"); // append all messages sent in /logs/sent/service12.log <br />
soap_set_test_logfile(&amp;soap, NULL); // no file name: do not save debug messages <br />
... <br />
soap_serve(&amp;soap); <br />
...
</td></tr></table><br></i>
Likewise, messages can be logged for individual client-side remote method calls.

<p>
	     <h3><a name="tth_sEc6.9">
6.9</a>&nbsp;&nbsp;<font color="#0000FF">Libraries</font></h3>

<p>

<ul><p>
<li> The socket library is essential and requires the inclusion of the appropriate libraries with the compile command for Sun
Solaris systems:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl -lm</i>
</td></tr></table><br></span>
These library loading options are not required with Linux.</li>
<p>
<li> The gSOAP runtime uses the math library for the <tt>NaN</tt>, <tt>INF</tt>, and <tt>-INF</tt> floating point representations.  The library
is not strictly necessary and the <i>&lt;math.h&#62;</i> header file import can be commented out from the <i>stdsoap2.h</i> header file.
Then, the application can be linked without the <i>-lm</i> math library under Sun Solaris:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</i>
</td></tr></table><br></span></li>
</ul>

<p>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;<font color="#0000FF">The gSOAP Remote Method Specification Format</font></h2>

<p>
A SOAP remote method is specified as a C/C++ function prototype in a header file. The function is REQUIRED to return <i><b>int</b></i>,
which is used to represent a SOAP error code, see Section&nbsp;<a href="#sec:errcodes">7.2</a>. Multiple remote methods MAY be declared together in one header file.

<p>
The general form of a SOAP remote method specification is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<font size="+1"><span class="roman">[</span></font><b>int</b><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<font size="+1"><span class="roman">[</span></font>inparam1, inparam2, ...,<font size="+1"><span class="roman">]</span></font> outparam);
</td></tr></table><br></i>
where

<dl compact="compact">
 <dt><b><span class="roman"><i>namespace_prefix__</i></b></dt>
	<dd> is the optional namespace prefix of the method (see identifier translation rules&nbsp;<a href="#sec:idtrans">7.3</a>)</span></dd>
 <dt><b><span class="roman"><i>method_name</i></b></dt>
	<dd>	 it the remote method name (see identifier translation rules&nbsp;<a href="#sec:idtrans">7.3</a>)</span></dd>
 <dt><b><span class="roman"><i>inparam</i></b></dt>
	<dd>		 is the declaration of an input parameter of the remote method</span></dd>
 <dt><b><span class="roman"><i>outparam</i></b></dt>
	<dd>	 is the declaration of the output parameter of the remote method</span></dd>
</dl>
This simple form can only pass a single, non-<i><b>struct</b></i> and non-<i><b>class</b></i> type output parameter. See&nbsp;<a href="#sec:param">7.1</a> for
passing multiple output parameters. The name of the declared function <i>namespace_prefix__method_name</i> must be unique and
cannot match the name of a <i><b>struct</b></i>, <i><b>class</b></i>, or <i><b>enum</b></i> declared in the same header file.

<p>
The method request is encoded in SOAP as an XML element and the namespace prefix, method name, and input parameters are encoded using the format:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method_name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method_name&#62; <br />
&lt;inparam-name1 xsi:type="..."&#62;...&lt;/inparam-name1&#62; <br />
&lt;inparam-name2 xsi:type="..."&#62;...&lt;/inparam-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method_name&#62;
</td></tr></table><br></tt>
where the <tt>inparam-name</tt> accessors are the element-name representations of the <i>inparam</i> parameter name declarations, see
Section&nbsp;<a href="#sec:idtrans">7.3</a>. (The optional parts are shown enclosed in <font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The XML response by the Web service is of the form:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-nameResponse xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-nameResponse&#62; <br />
&lt;outparam-name xsi:type="..."&#62;...&lt;/outparam-name&#62; <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-nameResponse&#62;
</td></tr></table><br></tt>
where the <tt>outparam-name</tt> accessor is the element-name representation of the <i>outparam</i> parameter name declaration, see
Section&nbsp;<a href="#sec:idtrans">7.3</a>. By convention, the response element name is the method name ending in <tt>Response</tt>.
See&nbsp;<a href="#sec:param">7.1</a> on how to change the declaration if the service response element name is different.

<p>
The gSOAP stub and skeleton compiler generates a stub routine and a proxy for the remote method. This proxy is of the form:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_call_<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*URL, <b>char</b>&nbsp;*action, <font size="+1"><span class="roman">[</span></font>inparam1, inparam2, ...,<font size="+1"><span class="roman">]</span></font> outparam);
</td></tr></table><br></i>
This proxy can be called by a client application to perform the remote method call.

<p>
The gSOAP stub and skeleton compiler generates a skeleton routine for the remote method. The skeleton function is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_serve_<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<b>struct</b>&nbsp;soap *soap);
</td></tr></table><br></i>
The skeleton routine, when called by a service application, will attempt to serve a request on the standard input. If no request
is present or if the request does not match the method name, <i>SOAP_NO_METHOD</i> is returned.  The skeleton routines are
automatically called by the generated <i>soap_serve</i> routine that handles all requests.

<p>
	     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;<font color="#0000FF">Remote Method Parameter Passing</font></h3><a name="sec:param">
</a>

<p>
The input parameters of a remote method MUST be passed by value.  Input parameters cannot be passed by reference with the <i>&amp;</i>
reference operator, but an input parameter value MAY be passed using a pointer to the data.  Passing a pointer to the data is
prefered when the size of the data of the parameter is large.  Also, to pass instances of (derived) classes, pointers to the
instance need to be used to avoid passing the instance by value which requires a temporary and prohibits passing derived class
instances.  When two input parameter values are identical, passing them using a pointer has the advantage that the value will be
encoded only once as multi-reference (hence, the parameters are aliases).  When input parameters are passed using a pointer, the
data pointed to will not be modified by the remote method and returned to the caller.

<p>
The output parameter MUST be passed by reference using <i>&amp;</i> or by using a pointer. Arrays are passed by reference by default
and do not require the use of the reference operator <i>&amp;</i>.

<p>
The input and output parameter types have certain limitations, see Section&nbsp;<a href="#sec:limitations">6.5</a>

<p>
If the output parameter is a <i><b>struct</b></i> or <i><b>class</b></i> type, it is considered a SOAP remote method response element instead of
a simple output parameter value. That is, the name of the <i><b>struct</b></i> or <i><b>class</b></i> is the name of the response element and
the <i><b>struct</b></i> or <i><b>class</b></i> fields are the output parameters of the remote method, see also&nbsp;<a href="#sec:response">5.1.6</a>. Hence, if
the output parameter has to be a <i><b>struct</b></i> or <i><b>class</b></i>, a response <i><b>struct</b></i> or <i><b>class</b></i> MUST be declared as well.
In addition, if a remote method returns multiple output parameters, a response <i><b>struct</b></i> or <i><b>class</b></i> MUST be declared. By
convention, the response element is the remote method name ending with ``<tt>Response</tt>''.

<p>
The general form of a response element declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>response_element_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;outparam1; <br />
&nbsp;&nbsp;&nbsp;outparam2; <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
where

<dl compact="compact">
 <dt><b><span class="roman"><i>namespace_prefix__</i></b></dt>
	<dd> is the optional namespace prefix of the response element (see identifier translation rules&nbsp;<a href="#sec:idtrans">7.3</a>)</span></dd>
 <dt><b><span class="roman"><i>response_element_name</i></b></dt>
	<dd>	 it the name of the response element (see identifier translation rules&nbsp;<a href="#sec:idtrans">7.3</a>)</span></dd>
 <dt><b><span class="roman"><i>outparam</i></b></dt>
	<dd>	 is the declaration of an output parameter of the remote method</span></dd>
</dl>
The general form of a remote method specification with a response element declaration for (multiple) output parameters is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<font size="+1"><span class="roman">[</span></font><b>int</b><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<font size="+1"><span class="roman">[</span></font>inparam1, inparam2, ...,<font size="+1"><span class="roman">]</span></font> <b>struct</b>&nbsp;<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>response_element_name {outparam1<font size="+1"><span class="roman">[</span></font>, outparam2, ...<font size="+1"><span class="roman">]</span></font>} &amp;anyparam);
</td></tr></table><br></i>
The choice of name for <i>anyparam</i> has no effect on the SOAP encoding and decoding and is only used as a place holder for the
response.

<p>
The method request is encoded in SOAP as an independent element and the namespace prefix, method name, and input parameters are encoded using the format:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-name&#62; <br />
&lt;inparam-name1 xsi:type="..."&#62;...&lt;/inparam-name1&#62; <br />
&lt;inparam-name2 xsi:type="..."&#62;...&lt;/inparam-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-name&#62;
</td></tr></table><br></tt>
where the <tt>inparam-name</tt> accessors are the element-name representations of the <i>inparam</i> parameter name declarations, see
Section&nbsp;<a href="#sec:idtrans">7.3</a>. (The optional parts resulting from the specification are shown enclosed in <font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The method response is expected to be of the form:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>response-element-name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>response-element-name&#62; <br />
&lt;outparam-name1 xsi:type="..."&#62;...&lt;/outparam-name1&#62; <br />
&lt;outparam-name2 xsi:type="..."&#62;...&lt;/outparam-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>response-element-name&#62;
</td></tr></table><br></tt>
where the <tt>outparam-name</tt> accessors are the element-name representations of the <i>outparam</i> parameter name declarations,
see Section&nbsp;<a href="#sec:idtrans">7.3</a>. (The optional parts resulting from the specification are shown enclosed in <font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The input and/or output parameters can be made anonymous, which allows the deserialization of requests/responses with different
parameter names as is endorsed by the SOAP 1.1 specification, see Section&nbsp;<a href="#sec:anonymous">5.1.12</a>.

<p>
	     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;<font color="#0000FF">Stub and Skeleton Routine Error Codes</font></h3><a name="sec:errcodes">
</a>

<p>
The error codes returned by the stub and skeleton routines are listed below.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td align="right"><font color="#FF0000"><b>#</b></font> </td><td><font color="#FF0000"><b>Code</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td align="right">0 </td><td><i>SOAP_OK</i> </td><td>No error </td></tr>
<tr><td align="right">1 </td><td><i>SOAP_CLI_FAULT</i>* </td><td>The service raised a client fault exception </td></tr>
<tr><td align="right">2 </td><td><i>SOAP_SVR_FAULT</i>* </td><td>The service raised a server fault exception </td></tr>
<tr><td align="right">3 </td><td><i>SOAP_TAG_MISMATCH</i> </td><td>An XML element didn't correspond to anything expected </td></tr>
<tr><td align="right">4 </td><td><i>SOAP_TYPE_MISMATCH</i> </td><td>An XML schema type mismatch </td></tr>
<tr><td align="right">5 </td><td><i>SOAP_SYNTAX_ERROR</i> </td><td>An XML syntax error occurred on the input </td></tr>
<tr><td align="right">6 </td><td><i>SOAP_NO_TAG</i> </td><td>Begin of an element expected, but not found </td></tr>
<tr><td align="right">7 </td><td><i>SOAP_IOB</i> </td><td>Array index out of bounds </td></tr>
<tr><td align="right">8 </td><td><i>SOAP_MUSTUNDERSTAND</i>* </td><td>An element needs to be ignored that need to be understood </td></tr>
<tr><td align="right">9 </td><td><i>SOAP_NAMESPACE</i> </td><td>Namespace name mismatch (validation error) </td></tr>
<tr><td align="right">10 </td><td><i>SOAP_OBJ_MISMATCH</i> </td><td>Mismatch in the size and/or shape of an object </td></tr>
<tr><td align="right">11 </td><td><i>SOAP_FATAL_ERROR</i> </td><td>Internal error </td></tr>
<tr><td align="right">12 </td><td><i>SOAP_FAULT</i> </td><td>An exception raised by the service </td></tr>
<tr><td align="right">13 </td><td><i>SOAP_NO_METHOD</i> </td><td>Skeleton error: the skeleton cannot serve the method </td></tr>
<tr><td align="right">14 </td><td><i>SOAP_EOM</i> </td><td>Out of memory </td></tr>
<tr><td align="right">15 </td><td><i>SOAP_NULL</i> </td><td>An element was null, while it is not supposed to be null </td></tr>
<tr><td align="right">16 </td><td><i>SOAP_MULTI_ID</i> </td><td>Multiple occurrences of the same element ID on the input </td></tr>
<tr><td align="right">17 </td><td><i>SOAP_MISSING_ID</i> </td><td>Element ID missing for an HREF on the input </td></tr>
<tr><td align="right">18 </td><td><i>SOAP_HREF</i> </td><td>Reference to object is incompatible with the object refered to </td></tr>
<tr><td align="right">19 </td><td><i>SOAP_TCP_ERROR</i> </td><td>A TCP connection error occured </td></tr>
<tr><td align="right">20 </td><td><i>SOAP_HTTP_ERROR</i> </td><td>An HTTP error occured </td></tr>
<tr><td align="right">21 </td><td><i>SOAP_SSL_ERROR</i> </td><td>An SSL error occured </td></tr>
<tr><td align="right">22 </td><td><i>SOAP_DIME_ERROR</i> </td><td>DIME parsing error </td></tr>
<tr><td align="right">23 </td><td><i>SOAP_EOD</i> </td><td>End of DIME </td></tr>
<tr><td align="right">24 </td><td><i>SOAP_VERSIONMISMATCH</i>* </td><td>SOAP version mismatch or no SOAP message </td></tr>
<tr><td align="right">25 </td><td><i>SOAP_DIME_VERSIONMISMATCH</i>* </td><td>DIME version mismatch </td></tr>
<tr><td align="right">-1 </td><td><i>SOAP_EOF</i> </td><td>Unexpected end of file or no input </td></tr></table>

</td></tr></table><br></span>
The error codes that are returned by a stub routine (proxy) upon receiving a SOAP Fault from the server are marked (*).
The remaining error codes are generated by the proxy itself as a result of problems with a SOAP payload.
The error code is <i>SOAP_OK</i> when the remote method call
was successful (the <i>SOAP_OK</i> predefined constant is guaranteed to be <i>0</i>).  The error code is also stored in
<i>soap.error</i>, where <i>soap</i> is a variable that contains the current runtime environment. The function
<i>soap_print_fault(<b>struct</b>&nbsp;soap *soap, FILE *fd)</i> can be called to display an error message on
<i>fd</i> where current value of the <i>soap.error</i> variable is used by the function to display the error.  The function
<i>soap_print_fault_location(<b>struct</b>&nbsp;soap *soap, FILE *fd)</i> prints the location of the error if the error is a result from parsing XML.

<p>
A remote method implemented in a SOAP service MUST return an error code as the function's return value. <i>SOAP_OK</i> denotes
success and <i>SOAP_FAULT</i> denotes an exception. The exception details can be assigned to the strings
<i>soap.fault</i><tt>-&gt;</tt><i>faultstring</i> and <i>soap.fault</i><tt>-&gt;</tt><i>detail</i>, where <i>soap</i> is a variable that contains the current runtime
environment, see Section&nbsp;<a href="#sec:fault">9</a>.

<p>
	     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;<font color="#0000FF">C++ Identifier Name to XML Element Name Translation</font></h3><a name="sec:idtrans">
</a>

<p>
One of the secrets behind the power and flexibility of gSOAP's encoding and decoding of remote method names, class names, type
identifiers, and struct or class fields is the ability to specify namespace prefixes with these names that are used to denote
their encoding style. More specifically, a C/C++ identifier name of the form
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>element_name
</td></tr></table><br></i>
will be encoded in XML as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name ...&#62;
</td></tr></table><br></tt>
The <b>underscore pair</b> (<i>__</i>) separates the namespace prefix from the element name.
Each namespace prefix has a namespace URI specified by a
namespace mapping table&nbsp;<a href="#sec:nstable">7.4</a>, see also Section&nbsp;<a href="#sec:namespace">5.1.2</a>.
The namespace URI is a unique identification that can be associated with the remote methods and data types.
The namespace URI disambiguates potentially identical remote method names and data type names used by disparate
organizations.

<p>
XML element names are NCNames (restricted strings) that MAY contain <b>hypens</b>, <b>dots</b>, and <b>underscores</b>.  The special characters in the XML element names of remote methods, structs, classes, typedefs, and fields can be controlled using the following
conventions:
A <b>single underscore</b> in a namespace prefix or identifier name is replaced by a hyphen (<tt>-</tt>) in the XML element name.
For example, the identifier name <i>SOAP_ENC__ur_type</i> is represented in XML as <tt>SOAP-ENC:ur-type</tt>.
The sequence <i>_DOT_</i> is replaced by a dot (<tt>.</tt>),
and the sequence <i>_USCORE_</i> is replaced by an underscore (<tt>_</tt>)
in the corresponding XML element name.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;n_s__biz_DOT_com <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*n_s__biz_USCORE_name; <br />
};
</td></tr></table><br></i>
is encoded in XML as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;n-s:biz.com xsi:type="n-s:biz.com"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;n-s:biz_name xsi:type="string"&#62;Bizybiz&lt;/n-s:biz_name&#62; <br />
&lt;/n-s:biz.com&#62;
</td></tr></table><br></tt>
Trailing underscores of an identifier name are not translated into the XML representation. This is useful when an identifier name
clashes with a C++ keyword. For example, <tt>return</tt> is often used as an accessor name in a SOAP response element.  The
<tt>return</tt> element can be specified as <i>return_</i> in the C++ source code. Note that XML should be treated as case sensitive,
so the use of e.g. <i>Return</i> may not always work to avoid a name clash with the <i><b>return</b></i> keyword.  The use of trailing
underscores also allows for defining <i><b>struct</b></i>s and <i><b>class</b></i>es with essentially the same XML schema type name, but that
have to be distinghuished as seperate C/C++ types.

<p>
For decoding, the underscores in identifier names act as wildcards. An XML element is parsed and matches the name of an identifier
if the name is identical to the element name (case insensitive) and the underscores in the identifier name are allowed to match
any character in the element name. For example, the identifier name <i>I_want__soap_fun_the_bea___DOT_com</i> matches the
element name <tt>I-want:SOAP4fun@the-beach.com</tt>.

<p>
	     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;<font color="#0000FF">Namespace Mapping Table</font></h3><a name="sec:nstable">
</a>

<p>
A namespace mapping table MUST be defined by clients and service applications. The mapping table is used by the serializers and
deserializers of the stub and skeleton routines to produce a valid SOAP payload and to validate an incoming SOAP payload.
A typical mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, // MUST be first <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, // MUST be second <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, // MUST be third <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, // Required for XML schema types <br />
&nbsp;&nbsp;&nbsp;{"ns1",      "urn:my-service-URI"}, // The namespace URI of the remote methods <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} // end of table <br />
}; <br />
</td></tr></table><br></i>
Each namespace prefix used by a identifier name in the header file specification (see Section&nbsp;<a href="#sec:idtrans">7.3</a>) MUST have a binding to a
namespace URI in the mapping table. The end of the namespace mapping table MUST be indicated by the <i>NULL</i> pair.
The namespace URI matching is case insensitive. A namespace prefix is distinghuished by the occurrence of a pair of underscores
(<i>__</i>) in an identifier.

<p>
An optional namespace pattern MAY be provided with each namespace mapping table entry.
The patterns provide an alternative namespace matching for the validation of decoded SOAP messages.
In this pattern, dashes (<i>-</i>) are single-character wildcards and asterisks (<i>*</i>) are multi-character wildcards.
For example, to decode different versions of XML Schema type with different authoring
dates, four dashes can be used in place of the specific dates in
the namespace mapping table pattern:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name", "ns-name validation pattern"} <br />
... <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance", "http://www.w3.org/<tt>----</tt>/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema", "http://www.w3.org/<tt>----</tt>/XMLSchema"}, <br />
...
</td></tr></table><br></i>
Or alternatively, asterisks can be used as wildcards for multiple characters:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name", "ns-name validation pattern"} <br />
... <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema", "http://www.w3.org/*/XMLSchema"}, <br />
...
</td></tr></table><br></i>
A namespace mapping table is automatically generated together with a WSDL file for each namespace prefix that is used for a remote
method in the header file.
This namespace mapping table has entries for all namespace prefixes.
The namespace URIs need to be filled in. These appear as
<i>%{URI}%</i> in the table.
See Section&nbsp;<a href="#sec:directives">12.2</a> on how to specify the namespace URIs in the header file.

<p>
For decoding elements with namespace prefixes, the namespace URI associated with the namespace prefix (through the <tt>xmlns</tt>
attribute of an XML element) is searched from the
beginning to the end in a namespace mapping table,
and for every row the following tests are performed as part of the validation process:

<ol type="1"><p>
<li> the string in the second column matches the namespace URI (case insensitive)</li>
<p>
<li> the string in the optional third column matches the namespace URI (case insensitive), where <i>-</i> is a one-character wildcard and <i>*</i> is a
   multi-character wildcard</li>
</ol>
When a match is found, the namespace prefix in the first column of the table is considered semantically identical to the namespace prefix used
by the XML element to be decoded, though the prefix names may differ.
A service will respond with the namespace that it received from a client in case it matches a pattern in the third column.

<p>
For example, let's say we have the following structs:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;a__elt { ... }; <br />
<b>struct</b>&nbsp;b__elt { ... }; <br />
<b>struct</b>&nbsp;k__elt { ... }; <br />
</td></tr></table><br></i>
and a namespace mapping table in the program:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name", "ns-name validation pattern"} <br />
... <br />
&nbsp;&nbsp;&nbsp;{"a", "some uri"}, <br />
&nbsp;&nbsp;&nbsp;{"b", "other uri"}, <br />
&nbsp;&nbsp;&nbsp;{"c", "his uri", "* uri"}, <br />
...
</td></tr></table><br></i>
Then, the following XML elements will match the structs:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;n:elt xmlns:n="some URI"&#62; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches the struct name <i>a__elt</i> <br />
... <br />
&lt;m:elt xmlns:m="other URI"&#62; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches the struct name <i>b__elt</i> <br />
... <br />
&lt;k:elt xmlns:k="my URI"&#62; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches the struct name <i>c__elt</i> <br />
... <br />
</td></tr></table><br></tt>
The response of a service to a client request that uses the namespaces listed above,
will include <tt>my URI</tt> for the name space of element <tt>k</tt>.

<p>
It is possible to use a number of different namespace tables and select the one that is appropriate.
For example, an application might contact many different Web services all using different namespace URIs.
If all the URIs are stored in one table, each remote method invocation will dump the whole namespace
table in the SOAP payload.  There is no technical problem with that, but it can be ugly when the table is large.
To use different namespace tables, declare a pointer to a table and set the pointer to a particular table before remote method
invocation.  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespacesTable1[] = { ... }; <br />
<b>struct</b>&nbsp;Namespace namespacesTable2[] = { ... }; <br />
<b>struct</b>&nbsp;Namespace namespacesTable3[] = { ... }; <br />
<b>struct</b>&nbsp;Namespace *namespaces; <br />
... <br />
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); <br />
soap.namespaces = namespaceTable1; <br />
soap_call_remote_method(&amp;soap, URL, Action, ...); <br />
...
</td></tr></table><br></i> 

<p>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;<font color="#0000FF">gSOAP Serialization and Deserialization Rules</font></h2>

<p>
This section describes the serialization and deserialization of C and C++ data types for SOAP 1.1 and 1.2 compliant encoding and decoding.

<p>
	     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;<font color="#0000FF">Primitive Type Encoding</font></h3>

<p>
The default encoding rules for the primitive C and C++ data types are given in the table below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Schema Type</b></font> </td><td><font color="#FF0000"><b>Example Encoding</b></font> </td></tr>
<tr><td><i><b>bool</b></i> </td><td><tt>boolean</tt> </td><td><tt>&lt;boolean xsi:type="boolean"&#62;...&lt;/boolean&#62;</tt>
</td></tr>
<tr><td><i><b>char</b>*</i> (C string) </td><td><tt>string</tt> </td><td><tt>&lt;string xsi:type="string"&#62;...&lt;/string&#62;</tt>
</td></tr>
<tr><td><i><b>char</b></i> </td><td><tt>byte</tt> </td><td><tt>&lt;byte xsi:type="byte"&#62;...&lt;/byte&#62;</tt>
</td></tr>
<tr><td><i><b>double</b></i> </td><td><tt>double</tt> </td><td><tt>&lt;double xsi:type="double"&#62;...&lt;/double&#62;</tt>
</td></tr>
<tr><td><i><b>float</b></i> </td><td><tt>float</tt> </td><td><tt>&lt;float xsi:type="float"&#62;...&lt;/float&#62;</tt>
</td></tr>
<tr><td><i><b>int</b></i> </td><td><tt>int</tt> </td><td><tt>&lt;int xsi:type="int"&#62;...&lt;/int&#62;</tt>
</td></tr>
<tr><td><i><b>long</b></i> </td><td><tt>long</tt> </td><td><tt>&lt;long xsi:type="long"&#62;...&lt;/long&#62;</tt>
</td></tr>
<tr><td><i>LONG64</i> </td><td><tt>long</tt> </td><td><tt>&lt;long xsi:type="long"&#62;...&lt;/long&#62;</tt>
</td></tr>
<tr><td><i><b>long</b>&nbsp;<b>long</b></i> </td><td><tt>long</tt> </td><td><tt>&lt;long xsi:type="long"&#62;...&lt;/long&#62;</tt>
</td></tr>
<tr><td><i><b>short</b></i> </td><td><tt>short</tt> </td><td><tt>&lt;short xsi:type="short"&#62;...&lt;/short&#62;</tt>
</td></tr>
<tr><td><i>time_t</i> </td><td><tt>dateTime</tt> </td><td><tt>&lt;dateTime xsi:type="dateTime"&#62;...&lt;/dateTime&#62;</tt>
</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>char</b></i> </td><td><tt>unsignedByte</tt> </td><td><tt>&lt;unsignedByte xsi:type="unsignedByte"&#62;...&lt;/unsignedByte&#62;</tt>
</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>int</b></i> </td><td><tt>unsignedInt</tt> </td><td><tt>&lt;unsignedInt xsi:type="unsignedInt"&#62;...&lt;/unsignedInt&#62;</tt>
</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b></i> </td><td><tt>unsignedLong</tt> </td><td><tt>&lt;unsignedLong xsi:type="unsignedLong"&#62;...&lt;/unsignedLong&#62;</tt>
</td></tr>
<tr><td><i>ULONG64</i> </td><td><tt>unsignedLong</tt> </td><td><tt>&lt;unsignedLong xsi:type="unsignedLong"&#62;...&lt;/unsignedLong&#62;</tt>
</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> </td><td><tt>unsignedLong</tt> </td><td><tt>&lt;unsignedLong xsi:type="unsignedLong"&#62;...&lt;/unsignedLong&#62;</tt>
</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>short</b></i> </td><td><tt>unsignedShort</tt> </td><td><tt>&lt;unsignedShort xsi:type="unsignedShort"&#62;...&lt;/unsignedShort&#62;</tt>
</td></tr>
<tr><td><i>wchar_t*</i> </td><td><tt>string</tt> </td><td><tt>&lt;string xsi:type="string"&#62;...&lt;/string&#62;</tt>
</td></tr></table>

</td></tr></table><br></span>
Objects of type <i><b>void</b></i> and <i><b>void</b>*</i> cannot be encoded.

<p>
		     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Encode and Decode Primitive Types as Built-In XML Schema Types</font></h3><a name="sec:primitive">
</a>

<p>
By default, encoding of the primitive types will take place as per SOAP encoding style.  The encoding can be changed to any XML
schema type with an optional namespace prefix by using a <i><b>typedef</b></i> in the header file input to the gSOAP stub and skeleton
compiler. The
declaration enables the implementation of built-in XML schema types such as <tt>positiveInteger</tt>, <tt>xsd:anyURI</tt>, and
<tt>xsd:date</tt> for which no built-in data structures in C and C++ exist but which can be represented using standard data
structures such as strings, integers, and floats.

<p>
The <i><b>typedef</b></i> declaration is frequently used for convenience in C. A <i><b>typedef</b></i> declares a type name for a (complex) type
expression. The type name can then be used in other declarations in place of the more complex type expression, which often
improves the readability of the program code.

<p>
The gSOAP compiler interprets <i><b>typedef</b></i> declarations the same way as a regular C compiler interprets them, i.e.&nbsp;as types in
declarations. In addition however, the gSOAP compiler will also use the type name in the encoding of the data in SOAP.
The <i><b>typedef</b></i> name will appear as the XML element name of an independent element and as the value of the <tt>xsi:type</tt>
attribute in the SOAP payload.

<p>
Many built-in primitive and derived XML schema types such as <tt>xsd:anyURI</tt>, <tt>positiveInteger</tt>, and <tt>decimal</tt> can be
stored by standard primitive data structures in C++ as well such as strings, integers, floats, and doubles. To serialize strings,
integers, floats, and doubles as built-in primitive and derived XML schema types. To this end, a <i><b>typedef</b></i> declaration can be
used to declare an XML Schema type.

<p>
For example, the declaration
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;positiveInteger;
</td></tr></table><br></i>
creates a named type <i>positiveInteger</i> which is represented by <i><b>unsigned</b>&nbsp;<b>int</b></i> in C++. For example, the encoding of a
<i>positiveInteger</i> value <i>3</i> is
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;positiveInteger xsi:type="positiveInteger"&#62;3&lt;/positiveInteger&#62;
</td></tr></table><br></tt>
The built-in XML schema datatype hierarchy from the XML Schema Part 2 documentation <a href="http://www.w3.org/TR/xmlschema-2"><tt>http://www.w3.org/TR/xmlschema-2</tt></a> is depicted below.

<p>
<a name="tth_fIg1">
</a> 
<center><img src="http://www.w3.org/TR/xmlschema-2/type-hierarchy.gif"/>
</center>

<center>Figure 1: Built-in Datatype Hierarchy</center>

<p>
The built-in primitive and derived numerical XML Schema types are listed below together with their recommended <i><b>typedef</b></i>
declarations. Note that the SOAP encoding schemas for primitive types are derived from the built-in XML schema types, so
<i>SOAP_ENC__</i> can be used as a namespace prefix instead of <i>xsd__</i>.

<dl compact="compact">
 <dt><b><tt>xsd:anyURI</tt></b></dt>
	<dd>
Represents a Uniform Resource Identifier Reference (URI).
Each URI scheme imposes specialized syntax rules for URIs in that scheme, including restrictions
on the syntax of allowed fragement identifiers.
It is recommended to use strings to store <tt>xsd:anyURI</tt> XML schema types. The recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:base64Binary</tt></b></dt>
	<dd>
Represents Base64-encoded arbitrary binary data.
For using the <tt>xsd:base64Binary</tt> XML schema type, the use of the base64Binary representation of a dynamic array is <b>strongly</b> recommended,
see Section&nbsp;<a href="#sec:base64binary">8.9</a>. However, the
type can also be declared as a string and the encoding will be string-based:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__base64Binary;
</td></tr></table><br></i>
With this approach, it is solely the responsibility of the application to make sure the string content is according to the Base64 Content-Transfer-Encoding defined in Section 6.8 of RFC 2045.</dd>
 <dt><b><tt>xsd:boolean</tt></b></dt>
	<dd>
For declaring an <tt>xsd:boolean</tt> XML schema type, the use of a bool is <b>strongly</b> recommended.
If a pure C compiler is used that does not support the <i>bool</i> type, see Section&nbsp;<a href="#sec:boolean">8.3.5</a>.
The corresponding type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;xsd__boolean;
</td></tr></table><br></i>
Type <i>xsd__boolean</i> declares a Boolean (0 or 1), which is encoded as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:boolean xsi:type="xsd:boolean"&#62;...&lt;/xsd:boolean&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:byte</tt></b></dt>
	<dd>
Represents a byte (-128...127). The corresponding type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;xsd__byte;
</td></tr></table><br></i>
Type <i>xsd__byte</i> declares a byte which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:byte xsi:type="xsd:byte"&#62;...&lt;/xsd:byte&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:dateTime</tt></b></dt>
	<dd>
Represents a date and time. The lexical representation is according to the ISO 8601 extended format CCYY-MM-DDThh:mm:ss where "CC"
represents the century, "YY" the year, "MM" the month and "DD" the day, preceded by an optional leading "-" sign to indicate a
negative number. If the sign is omitted, "+" is assumed. The letter "T" is the date/time separator and "hh", "mm", "ss" represent
hour, minute and second respectively.
It is recommended to use the <i>time_t</i> type to store <tt>xsd:dateTime</tt> XML schema types and the type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;time_t xsd__dateTime;
</td></tr></table><br></i>
However, note that calendar times  before  the year 1902  or after
the year 2037 cannot be represented. Upon receiving a date below this range,
the <i>time_t</i> value will be set to -2147483648, and upon receiving a date above this range,
the <i>time_t</i> value will be set to 2147483647.

<p>
Strings (<i><b>char</b>*</i>) can be used to store <tt>xsd:dateTime</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__dateTime;
</td></tr></table><br></i>
In this case, it is up to the application to read and set the dateTime representation.</dd>
 <dt><b><tt>xsd:date</tt></b></dt>
	<dd>
Represents a date.
The lexical representation for date is the reduced (right truncated) lexical representation for dateTime: CCYY-MM-DD.
It is recommended to use strings (<i><b>char</b>*</i>) to store <tt>xsd:date</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__date;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:decimal</tt></b></dt>
	<dd>
Represents arbitrary precision decimal numbers.
It is recommended to use the <b>double</b> type to store <tt>xsd:decimal</tt> XML schema types and the type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__decimal;
</td></tr></table><br></i>
Type <i>xsd__decimal</i> declares a double floating point number which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:double xsi:type="xsd:decimal"&#62;...&lt;/xsd:double&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:double</tt></b></dt>
	<dd>
Corresponds to the IEEE double-precision 64-bit floating point type. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double;
</td></tr></table><br></i>
Type <i>xsd__double</i> declares a double floating point number which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:double xsi:type="xsd:double"&#62;...&lt;/xsd:double&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:duration</tt></b></dt>
	<dd>
Represents a duration of time.
The lexical representation for duration is the ISO 8601 extended format PnYn MnDTnH nMnS, where nY represents
the number of years, nM the number of months, nD the number of days, T is the date/time separator, nH the number of
hours, nM the number of minutes and nS the number of seconds. The number of seconds can include decimal digits to
arbitrary precision.
It is recommended to use strings (<i><b>char</b>*</i>) to store <tt>xsd:duration</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__duration;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:float</tt></b></dt>
	<dd>
Corresponds to the IEEE single-precision 32-bit floating point type. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float;
</td></tr></table><br></i>
Type <i>xsd__float</i> declares a floating point number which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:float xsi:type="xsd:float"&#62;...&lt;/xsd:float&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:hexBinary</tt></b></dt>
	<dd>
Represents arbitrary hex-encoded binary data.  It has a lexical representation where each binary octet is encoded as a character
tuple, consisting of two hexadecimal digits ([0-9a-fA-F]) representing the octet code. For example, "0FB7" is a hex encoding for
the 16-bit integer 4023 (whose binary representation is 111110110111.
For using the <tt>xsd:hexBinary</tt> XML schema type, the use of the hexBinary representation of a dynamic array is <b>strongly</b> recommended,
see Section&nbsp;<a href="#sec:hexbinary">8.10</a>. However, the
type can also be declared as a string and the encoding will be string-based:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__hexBinary;
</td></tr></table><br></i>
With this approach, it is solely the responsibility of the application to make sure the string content consists of a sequence of octets.</dd>
 <dt><b><tt>xsd:int</tt></b></dt>
	<dd>
Corresponds to a 32-bit integer in the range -2147483648 to 2147483647.
If the C++ compiler supports 32-bit <i><b>int</b></i> types, the type declaration can use the <i><b>int</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int;
</td></tr></table><br></i>
Otherwise, the C++ compiler supports 16-bit <i><b>int</b></i> types and the type declaration should use the <i><b>long</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int;
</td></tr></table><br></i>
Type <i>xsd__int</i> declares a 32-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:int xsi:type="xsd:int"&#62;...&lt;/xsd:int&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:integer</tt></b></dt>
	<dd>
Corresponds to an unbounded integer.
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__integer;
</td></tr></table><br></i>
Type <i>xsd__integer</i> declares a 64-bit integer which is encoded as an unbounded <tt>xsd:integer</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:integer xsi:type="xsd:integer"&#62;...&lt;/xsd:integer&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:long</tt></b></dt>
	<dd>
Corresponds to a 64-bit integer in the range -9223372036854775808 to 9223372036854775807.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__long;
</td></tr></table><br></i>
Or in Visual C++:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;LONG64 xsd__long;
</td></tr></table><br></i>
Type <i>xsd__long</i> declares a 64-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:long xsi:type="xsd:long"&#62;...&lt;/xsd:long&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:negativeInteger</tt></b></dt>
	<dd>
Corresponds to a negative unbounded integer ( &lt; 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__negativeInteger;
</td></tr></table><br></i>
Type <i>xsd__negativeInteger</i> declares a 64-bit integer which is encoded as a <tt>xsd:negativeInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:negativeInteger xsi:type="xsd:negativeInteger"&#62;...&lt;/xsd:negativeInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:nonNegativeInteger</tt></b></dt>
	<dd>
Corresponds to a non-negative unbounded integer ( &gt; 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__nonNegativeInteger;
</td></tr></table><br></i>
Type <i>xsd__nonNegativeInteger</i> declares a 64-bit unsigned integer which is encoded as a non-negative unbounded <tt>xsd:nonNegativeInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:nonNegativeInteger xsi:type="xsd:nonNegativeInteger"&#62;...&lt;/xsd:nonNegativeInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:nonPositiveInteger</tt></b></dt>
	<dd>
Corresponds to a non-positive unbounded integer ( <font face="symbol"></font
> 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__nonPositiveInteger;
</td></tr></table><br></i>
Type <i>xsd__nonPositiveInteger</i> declares a 64-bit integer which is encoded as a <tt>xsd:nonPositiveInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:nonPositiveInteger xsi:type="xsd:nonPositiveInteger"&#62;...&lt;/xsd:nonPositiveInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:normalizedString</tt></b></dt>
	<dd>
Represents normalized character strings.
Normalized character strings do not contain the carriage return (#xD), line feed (#xA) nor tab (#x9) characters.
It is recommended to use strings to store <tt>xsd:normalizeString</tt> XML schema types.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__normalizedString;
</td></tr></table><br></i>
Type <i>xsd__normalizedString</i> declares a string type which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:normalizedString xsi:type="xsd:normalizedString"&#62;...&lt;/xsd:normalizedString&#62;
</td></tr></table><br></tt>
It is solely the responsibility of the application to make sure the strings do not contain carriage return (#xD), line feed (#xA)
and tab (#x9) characters.</dd>
 <dt><b><tt>xsd:positiveInteger</tt></b></dt>
	<dd>
Corresponds to a positive unbounded integer ( <font face="symbol"></font
> 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__positiveInteger;
</td></tr></table><br></i>
Type <i>xsd__positiveInteger</i> declares a 64-bit unsigned integer which is encoded as a <tt>xsd:positiveInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:positiveInteger xsi:type="xsd:positiveInteger"&#62;...&lt;/xsd:positiveInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:short</tt></b></dt>
	<dd>
Corresponds to a 16-bit integer in the range -323768 to 323767.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>short</b>&nbsp;xsd__short;
</td></tr></table><br></i>
Type <i>xsd__short</i> declares a short 16-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:short xsi:type="xsd:short"&#62;...&lt;/xsd:short&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:string</tt></b></dt>
	<dd>
Represents character strings. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string;
</td></tr></table><br></i>
Type <i>xsd__string</i> declares a string type which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:string xsi:type="xsd:string"&#62;...&lt;/xsd:string&#62;
</td></tr></table><br></tt>
The type declaration for wide character strings is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;wchar_t *xsd__string;
</td></tr></table><br></i>
Both type of strings can be used at the same time, but requires one typedef name to be changed by appending an underscore which is
invisible in XML. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;wchar_t *xsd__string_;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:time</tt></b></dt>
	<dd>
Represents a time.  The lexical representation for time is the left truncated lexical representation for dateTime: hh:mm:ss.sss
with optional following time zone indicator.
It is recommended to use strings (<i><b>char</b>*</i>) to store <tt>xsd:time</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__time;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:token</tt></b></dt>
	<dd>
Represents tokenized strings.
Tokens are strings that do not contain the
line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and that have no internal
sequences of two or more spaces.
It is recommended to use strings to store <tt>xsd:token</tt> XML schema types.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__token;
</td></tr></table><br></i>
Type <i>xsd__token</i> declares a string type which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:token xsi:type="xsd:token"&#62;...&lt;/xsd:token&#62;
</td></tr></table><br></tt>
It is solely the responsibility of the application to make sure the strings do not contain the line feed (#xA) nor tab (#x9)
characters, that have no leading or trailing spaces (#x20) and that have no internal sequences of two or more spaces.</dd>
 <dt><b><tt>xsd:unsignedByte</tt></b></dt>
	<dd>
Corresponds to an 8-bit unsigned integer in the range 0 to 255.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;xsd__unsignedByte;
</td></tr></table><br></i>
Type <i>xsd__unsignedByte</i> declares a unsigned 8-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedByte xsi:type="xsd:unsignedByte"&#62;...&lt;/xsd:unsignedByte&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:unsignedInt</tt></b></dt>
	<dd>
Corresponds to a 32-bit unsigned integer in the range 0 to 4294967295.
If the C++ compiler supports 32-bit <i><b>int</b></i> types, the type declaration can use the <i><b>int</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;xsd__unsignedInt;
</td></tr></table><br></i>
Otherwise, the C++ compiler supports 16-bit <i><b>int</b></i> types and the type declaration should use the <i><b>long</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;xsd__unsignedInt;
</td></tr></table><br></i>
Type <i>xsd__unsignedInt</i> declares an unsigned 32-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedInt xsi:type="xsd:unsignedInt"&#62;...&lt;/xsd:unsignedInt&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:unsignedLong</tt></b></dt>
	<dd>
Corresponds to a 64-bit unsigned integer in the range 0 to 18446744073709551615.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__unsignedLong;
</td></tr></table><br></i>
Or in Visual C++:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;ULONG64 xsd__unsignedLong;
</td></tr></table><br></i>
Type <i>xsd__unsignedLong</i> declares an unsigned 64-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedLong xsi:type="xsd:unsignedLong"&#62;...&lt;/xsd:unsignedLong&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:unsignedShort</tt></b></dt>
	<dd>
Corresponds to a 16-bit unsigned integer in the range 0 to 65535.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>short</b>&nbsp;xsd__unsignedShort;
</td></tr></table><br></i>
Type <i>xsd__unsginedShort</i> declares an unsigned short 16-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedShort xsi:type="xsd:unsignedShort"&#62;...&lt;/xsd:unsignedShort&#62;
</td></tr></table><br></tt></dd>
</dl>
Other XML schema types such as <tt>gYearMonth</tt>, <tt>gYear</tt>, <tt>gMonthDay</tt>, <tt>gDay</tt>, <tt>xsd:gMonth</tt>, <tt>QName</tt>,
<tt>NOTATION</tt>, etc., can be encoded similarly using a <i><b>typedef</b></i> declaration.

<p>
		      <h4><a name="tth_sEc8.2.1">
8.2.1</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Multiple Storage Formats for a Single Primitive XML Schema Type</font></h4>

<p>
Trailing underscores (see Section&nbsp;<a href="#sec:idtrans">7.3</a>) can be used in the type name in a <i><b>typedef</b></i> to enable the declaration of multiple storage
formats for a single XML schema type. For example, one part of a C/C++ application's data structure may use plain strings while
another part may use wide character strings.  To enable this simultaneous use, declare:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;wchar_t *xsd__string_;
</td></tr></table><br></i>
Now, the <i>xsd__string</i> and <i>xsd__string_</i> types will both be encoded and decoded as XML string types and the use of
trailing underscores allows multiple declarations for a single XML schema type.

<p>
		      <h4><a name="tth_sEc8.2.2">
8.2.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Polymorphic Primitive Types</font></h4><a name="sec:primclass">
</a>

<p>
SOAP 1.1 supports polymorphic types, because XML schema types form a hierarchy.
The root of the hierarchy is called <tt>xsd:anyType</tt>.
So, for example, an array of <tt>xsd:anyType</tt> in SOAP may actually contain any mix of element types
that are the derived types of the root type.
The use of polymorphic types is indicated by the WSDL and schema descriptions of a Web service and can therefore be
predicted/expected for each particular case.

<p>
On the one hand, the <i><b>typedef</b></i> construct provides a convenient way to associate C/C++ types with XML schema types and makes
it easy to incorporate these types in a (legacy) C/C++ application.
However, on the other hand the <i><b>typedef</b></i> declarations cannot be used to support polymorphic XML schema types.
Most SOAP clients and services do not use polymorphic types.  In case they do, the primitive polymorphic types can be declared as
a hierarchy of C++ <i><b>class</b></i>es that can be used simultaneously with the <i><b>typedef</b></i> declarations.

<p>
The general form of a primitive type declaration that is derived from a super type is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__type_name: <font size="+1"><span class="roman">[</span></font><b>public</b>&nbsp;xsd__super_type_name<font size="+1"><span class="roman">]</span></font> <br />
{ <b>public</b>: <u><span class="roman">Type</span></u> __item; <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
where <u><span class="roman">Type</span></u> is a primitive C type that may be declared with a <i><b>typedef</b></i> to enforce XML schema encoding as with
the usual <i><b>typedef</b></i> conventions used by the gSOAP compiler.

<p>
For example, the XML schema type hierarchy can be copied to C++ with the following declarations:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__anyType { }; <br />
<b>class</b>&nbsp;xsd__anySimpleType: <b>public</b>&nbsp;xsd__anyType { }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI; <br />
<b>class</b>&nbsp;xsd__anyURI_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__anyURI __item; }; <br />
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;xsd__boolean; <br />
<b>class</b>&nbsp;xsd__boolean_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__boolean __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__date; <br />
<b>class</b>&nbsp;xsd__date_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__date __item; }; <br />
<b>typedef</b>&nbsp;time_t xsd__dateTime; <br />
<b>class</b>&nbsp;xsd__dateTime_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__dateTime __item; }; <br />
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>class</b>&nbsp;xsd__double_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__double __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__duration; <br />
<b>class</b>&nbsp;xsd__duration_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__duration __item; }; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>class</b>&nbsp;xsd__float_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__float __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__time; <br />
<b>class</b>&nbsp;xsd__time_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__time __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__decimal; <br />
<b>class</b>&nbsp;xsd__decimal_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__decimal __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__integer; <br />
<b>class</b>&nbsp;xsd__integer_: <b>public</b>&nbsp;xsd__decimal_ { <b>public</b>: xsd__integer __item; }; <br />
<b>typedef</b>&nbsp;LONG64 xsd__long; <br />
<b>class</b>&nbsp;xsd__long_: <b>public</b>&nbsp;xsd__integer_ { <b>public</b>: xsd__long __item; }; <br />
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int; <br />
<b>class</b>&nbsp;xsd__int_: <b>public</b>&nbsp;xsd__long_ { <b>public</b>: xsd__int __item; }; <br />
<b>typedef</b>&nbsp;<b>short</b>&nbsp;xsd__short; <br />
<b>class</b>&nbsp;xsd__short_: <b>public</b>&nbsp;xsd__int_ { <b>public</b>: xsd__short __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;xsd__byte; <br />
<b>class</b>&nbsp;xsd__byte_: <b>public</b>&nbsp;xsd__short_ { <b>public</b>: xsd__byte __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__nonPositiveInteger; <br />
<b>class</b>&nbsp;xsd__nonPositiveInteger_: <b>public</b>&nbsp;xsd__integer_ { <b>public</b>: xsd__nonPositiveInteger __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__negativeInteger; <br />
<b>class</b>&nbsp;xsd__negativeInteger_: <b>public</b>&nbsp;xsd__nonPositiveInteger_ { <b>public</b>: xsd__negativeInteger __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__nonNegativeInteger; <br />
<b>class</b>&nbsp;xsd__nonNegativeInteger_: <b>public</b>&nbsp;xsd__integer_ { <b>public</b>: xsd__nonNegativeInteger __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__positiveInteger; <br />
<b>class</b>&nbsp;xsd__positiveInteger_: <b>public</b>&nbsp;xsd__nonNegativeInteger_ { <b>public</b>: xsd__positiveInteger __item; }; <br />
<b>typedef</b>&nbsp;ULONG64 xsd__unsignedLong; <br />
<b>class</b>&nbsp;xsd__unsignedLong_: <b>public</b>&nbsp;xsd__nonNegativeInteger_ { <b>public</b>: xsd__unsignedLong __item; }; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;xsd__unsignedInt; <br />
<b>class</b>&nbsp;xsd__unsignedInt_: <b>public</b>&nbsp;xsd__unsginedLong_ { <b>public</b>: xsd__unsignedInt __item; }; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>short</b>&nbsp;xsd__unsignedShort; <br />
<b>class</b>&nbsp;xsd__unsignedShort_: <b>public</b>&nbsp;xsd__unsignedInt_ { <b>public</b>: xsd__unsignedShort __item; }; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;xsd__unsignedByte; <br />
<b>class</b>&nbsp;xsd__unsignedByte_: <b>public</b>&nbsp;xsd__unsignedShort_ { <b>public</b>: xsd__unsignedByte __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>class</b>&nbsp;xsd__string_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__string __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__normalizedString; <br />
<b>class</b>&nbsp;xsd__normalizedString_: <b>public</b>&nbsp;xsd__string_ { <b>public</b>: xsd__normalizedString __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__token; <br />
<b>class</b>&nbsp;xsd__token_: <b>public</b>&nbsp;xsd__normalizedString_ { <b>public</b>: xsd__token __item; }; <br />
</td></tr></table><br></i>
Note the use of the trailing underscores for the <i><b>class</b></i> names to distinhuish the <i><b>typedef</b></i> type names from the
<i><b>class</b></i> names.  Only the most frequently used built-in schema types are shown.
It is also allowed to include the <i>xsd:base64Binray</i> and <i>xsd:hexBinary</i> types in the hierarchy:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: <b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <b>int</b>&nbsp;__size; }; <br />
<b>class</b>&nbsp;xsd__hexBinary: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: <b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <b>int</b>&nbsp;__size; };
</td></tr></table><br></i>
See Sections&nbsp;<a href="#sec:base64binary">8.9</a> and&nbsp;<a href="#sec:hexbinary">8.10</a>.

<p>
Methods are allowed to be added to the classes above, such as constructors and getter/setter methods.

<p>
		      <h4><a name="tth_sEc8.2.3">
8.2.3</a>&nbsp;&nbsp;<font color="#0000FF">XML Schema Type Decoding Rules</font></h4>

<p>
The decoding rules for the primitive C and C++ data types is given in the table below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Allows Decoding of</b></font> </td><td><font color="#FF0000"><b>Precision Lost?</b></font> </td></tr>
<tr><td><i><b>bool</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>boolean</tt> </td><td>no </td></tr>
<tr><td><i><b>char</b>*</i> (C string) </td><td>any type, see&nbsp;<a href="#sec:smart">8.2.5</a> </td><td>no </td></tr>
<tr><td><i>wchar_t *</i> (wide string) </td><td>any type, see&nbsp;<a href="#sec:smart">8.2.5</a> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>double</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>double</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>float</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>decimal</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>integer</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>negativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonPositiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>float</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>float</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>decimal</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>integer</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>negativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonPositiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>long</b>&nbsp;<b>long</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>integer</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>negativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonPositiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr></table>

</td></tr></table><br></span>
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Allows Decoding of</b></font> </td><td><font color="#FF0000"><b>Precision Lost?</b></font> </td></tr>
<tr><td><i><b>long</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>possibly, if <i><b>long</b></i> is 32 bit </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>int</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>short</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>char</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>possibly, if <i><b>long</b></i> is 32 bit </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>int</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>short</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>char</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i>time_t</i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>dateTime</tt> </td><td>no(?) </td></tr>
<tr><td></td></tr></table>

</td></tr></table><br></span>
Due to limitations in representation of certain primitive C++ types, a possible loss of accuracy may occur with the decoding of certain XML schema types as is indicated in the table. The table does not indicate the possible loss of precision of floating point values due to the textual representation of floating point values in SOAP.

<p>
All explicitly declared XML schema encoded primitive types adhere to the same decoding rules. For example, the following declaration:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__nonNegativeInteger;
</td></tr></table><br></i>
enables the encoding and decoding of <tt>xsd:nonNegativeInteger</tt> XML schema types (although decoding takes place with a possible
loss of precision).
The declaration also allows decoding of <tt>xsd:positiveInteger</tt> XML schema types, because of the storage as a <i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> data type.

<p>
		      <h4><a name="tth_sEc8.2.4">
8.2.4</a>&nbsp;&nbsp;<font color="#0000FF">Multi-Reference Strings</font></h4>

<p>
If more than one <i><b>char</b></i> pointer points to the same string, the string is encoded as a multi-reference value.
Consider for example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>char</b>&nbsp;*s = "hello", *t = s;
</td></tr></table><br></i>
The <i>s</i> and <i>t</i> variables are assigned the same string, and when serialized, <i>t</i> refers to the content of <i>s</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;string id="123" xsi:type="string"&#62;hello&lt;/string&#62; <br />
... <br />
&lt;string href="#123"/&#62;
</td></tr></table><br></tt>
The example assumed that <i>s</i> and <i>t</i> are encoded as independent elements.

<p>
Note: the use of <i><b>typedef</b></i> to declare a string type such as <i>xsd__string</i> will not affect the multi-reference string
encoding.  However, strings declared with different <i><b>typedef</b></i>s will never be considered multi-reference even when they point
to the same string.  For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI; <br />
xsd__anyURI *s = "http://www.myservice.com"; <br />
xsd__string *t = s;
</td></tr></table><br></i>
The variables <i>s</i> and <i>t</i> point to the same string, but since they are considered different types their content will not
be shared in the SOAP payload through a multi-referenced string.

<p>
		      <h4><a name="tth_sEc8.2.5">
8.2.5</a>&nbsp;&nbsp;<font color="#0000FF">``Smart String'' Mixed-Content Decoding</font></h4><a name="sec:smart">
</a>

<p>
The implementation of string decoding in gSOAP allows for mixed content decoding. If the SOAP payload contains a complex data type in place of
a string, the complex data type is decoded in the string as plain XML text.

<p>
For example, suppose the <i>getInfo</i> remote method returns some detailed information. The remote method is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of header file "getInfo.h": <br />
getInfo(<b>char</b>&nbsp;*detail);
</td></tr></table><br></i>
The proxy of the remote method is used by a client to request a piece of information and the service responds with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
HTTP/1.1 200 OK <br />
Content-Type: text/xml <br />
Content-Length: nnn <br />
<br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;getInfoResponse&#62; <br />
&lt;detail&#62; <br />
&lt;picture&#62;Mona Lisa by &lt;i&#62;Leonardo da Vinci&lt;/i&#62;&lt;/picture&#62; <br />
&lt;/detail&#62; <br />
&lt;/getInfoResponse&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
As a result of the mixed content decoding, the <i>detail</i> string contains ``<tt>&lt;picture&#62;Mona Lisa by &lt;i&#62;Leonardo da Vinci&lt;/i&#62;&lt;/picture&#62;</tt>''.

<p>
		      <h4><a name="tth_sEc8.2.6">
8.2.6</a>&nbsp;&nbsp;<font color="#0000FF">Changing the Encoding Precision of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></h4>

<p>
The <i>double</i> encoding format is by default set to ``<i>%.18G</i>'' (see a manual on <i>printf</i> text formatting in C),
i.e.&nbsp;at most 18 digits of precision to limit a loss in accuracy.
The <i>float</i> encoding format is by default ``<i>%.9G</i>'', i.e.&nbsp;at most 9 digits of precision.

<p>
The encoding format of a double type can be set by assigning a format string to <i>soap.double_format</i>, where <i>soap</i> is a
variable that contains the
current runtime environment. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); // sets double_format = "%.18G" <br />
soap.double_format = "%e"; // redefine
</td></tr></table><br></i>
which causes all doubles to be encoded in scientific notation.
Likewise, the encoding format of a float type can be set by assigning a format string to the static <i>soap_float_format</i> string variable. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); // sets float_format = "%.9G" <br />
soap.float_format = "%.4f"; // redefine
</td></tr></table><br></i>
which causes all floats to be encoded with four digits precision.

<p>
<font color="#FF0000"><b>Caution</b></font>: The format strings are not automatically reset before or after SOAP communications. An error in the format string may result in the incorrect encoding of floating point values.

<p>
		      <h4><a name="tth_sEc8.2.7">
8.2.7</a>&nbsp;&nbsp;<font color="#0000FF">INF, -INF, and NaN Values of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></h4>

<p>
The gSOAP runtime <i>stdsoap2.cpp</i> and header file <i>stdsoap2.h</i> support the marshalling of IEEE INF, -INF, and NaN
representations.  Under certain circumstances this may break if the hardware and/or C/C++ compiler does not support these
representations.
To remove the representations, remove the inclusion of the <i>&lt;math.h&#62;</i> header file from the <i>stdsoap2.h</i> file.
You can control the representations as well, which are defined by the macros:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define FLT_NAN <br />
#define FLT_PINFTY <br />
#define FLT_NINFTY <br />
#define DBL_NAN <br />
#define DBL_PINFTY <br />
#define DBL_NINFTY
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;<font color="#0000FF">Enumeration Type Encoding and Decoding</font></h3>

<p>
Enumerations are generally useful for the declaration of named integer-valued constants, also called enumeration constants.

<p>
		      <h4><a name="tth_sEc8.3.1">
8.3.1</a>&nbsp;&nbsp;<font color="#0000FF">Symbolic Encoding of Enumeration Constants</font></h4>

<p>
The gSOAP stub and skeleton compiler encodes the constants of enumeration-typed variables in symbolic form using the names of the constants when possible to comply to SOAP's XML schema enumeration encoding style. Consider for example the following enumeration of weekdays:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;weekday {Mon, Tue, Wed, Thu, Fri, Sat, Sun};
</td></tr></table><br></i>
The enumeration-constant <i>Mon</i>, for example, is encoded as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;weekday xsi:type="weekday"&#62;Mon&lt;/weekday&#62;
</td></tr></table><br></tt>
The value of the <tt>xsi:type</tt> attribute is the enumeration-type identifier's name. If the element is independent as in the example above, the element name is the enumeration-type identifier's name.

<p>
The encoding of complex types such as enumerations requires a reference to an XML schema through the use of a namespace prefix. The namespace prefix can be specified as part of the enumeration-type identifier's name, with the usual namespace prefix conventions for identifiers. This can be used to explicitly specify the encoding style. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__weekday {Mon, Tue, Wed, Thu, Fri, Sat, Sun};
</td></tr></table><br></i>
The enumeration-constant <i>Sat</i>, for example, is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns1:weekday xsi:type="ns1:weekday"&#62;Sat&lt;/ns1:weekday&#62;
</td></tr></table><br></tt>
The corresponding XML schema for this enumeration data type would be:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:element name="weekday" type="tns:weekday"/&#62; <br />
&lt;xsd:simpleType name="weekday"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;xsd:restriction base="xsd:string"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Mon"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Tue"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Wed"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Thu"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Fri"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Sat"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Sun"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/xsd:restriction&#62; <br />
&lt;/xsd:simpleType&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc8.3.2">
8.3.2</a>&nbsp;&nbsp;<font color="#0000FF">Literal Encoding of Enumeration Constants</font></h4>

<p>
If the value of an enumeration-typed variable has no corresponding named constant, the value is encoded as a signed integer literal. For example, the following declaration of a <i>workday</i> enumeration type lacks named constants for Saturday and Sunday:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__workday {Mon, Tue, Wed, Thu, Fri};
</td></tr></table><br></i>
If the constant <i>5</i> (Saturday) or <i>6</i> (Sunday) is assigned to a variable of the <i>workday</i> enumeration type, the variable will be encoded with the integer literals <tt>5</tt> and <tt>6</tt>, respectively. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns1:workday xsi:type="ns1:workday"&#62;5&lt;/ns1:workday&#62;
</td></tr></table><br></tt>
Since this is legal in C++ and SOAP allows enumeration constants to be integer literals, this method ensures that non-symbolic
enumeration constants are correctly communicated to another party if the other party accepts literal enumeration constants (as
with the gSOAP stub and skeleton compiler).

<p>
Both symbolic and literal enumeration constants can be decoded.

<p>
To enforce the literal enumeration constant encoding and to get the literal constants in the WSDL file, use the following trick:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__nums { _1 = 1, _2 = 2, _3 = 3 };
</td></tr></table><br></i>
The difference with an enumeration type without a list of values and the enumeration type above is that the enumeration constants
will appear in the WSDL service description.

<p>
		      <h4><a name="tth_sEc8.3.3">
8.3.3</a>&nbsp;&nbsp;<font color="#0000FF">Initialized Enumeration Constants</font></h4>

<p>
The gSOAP compiler supports the initialization of enumeration constants, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__relation {LESS = -1, EQUAL = 0, GREATER = 1};
</td></tr></table><br></i>
The symbolic names <tt>LESS</tt>, <tt>EQUAL</tt>, and <tt>GREATER</tt> will appear in the SOAP payload for the encoding of the <i>ns1__relation</i> enumeration values <i>-1</i>, <i>0</i>, and <i>1</i>, respectively.

<p>
		      <h4><a name="tth_sEc8.3.4">
8.3.4</a>&nbsp;&nbsp;<font color="#0000FF">How to ``Reuse'' Symbolic Enumeration Constants</font></h4>

<p>
A well-known deficiency of C and C++ enumeration types is the lack of support for the reuse of symbolic names by multiple enumerations. That is, the names of all the symbolic constants defined by an enumeration cannot be reused by another enumeration. To force encoding of the same symbolic name by different enumerations, the identifier of the symbolic name can end in an underscore (<i>_</i>) or any number of underscores to distinghuish it from other symbolic names in C++. This guarantees that the SOAP encoding will use the same name, while the symbolic names can be distinghuished in C++. Effectively, the underscores are removed from a symbolic name prior to encoding.

<p>
Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__workday {Mon, Tue, Wed, Thu, Fri}; <br />
<b>enum</b>&nbsp;ns1__weekday {Mon_, Tue_, Wed_, Thu_, Fri_, Sat_, Sun_};
</td></tr></table><br></i>
which will result in the encoding of the constants of <i>enum ns1__weekday</i> without the underscore, for example as <tt>Mon</tt>.

<p>
<font color="#FF0000"><b>Caution</b></font>: The following declaration:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__workday {Mon, Tue, Wed, Thu, Fri}; <br />
<b>enum</b>&nbsp;ns1__weekday {Sat = 5, Sun = 6};
</td></tr></table><br></i>
will not properly encode the <i>weekday</i> enumeration, because it lacks the named constants for <i>workday</i> in its enumeration list.

<p>
		      <h4><a name="tth_sEc8.3.5">
8.3.5</a>&nbsp;&nbsp;<font color="#0000FF">Boolean Enumeration Type Encoding and Decoding for C Compilers</font></h4><a name="sec:boolean">
</a>

<p>
When a pure C compiler is used to create SOAP clients and services, the <i>bool</i> type may not be supported by the compiler and
in that case an enumeration type should be used.  The C enumeration-type encoding adopted by the gSOAP stub and skeleton compiler
can be used to encode boolean values according to the SOAP encoding style. The namespace prefix can be specified with the usual
namespace prefix convention for identifiers to explicitly specify the encoding style. For example, the built-in <tt>boolean</tt> XML
schema type supports the mathematical concept of binary-valued logic. The <tt>boolean</tt> XML schema encoding style can be specified
by using the <tt>xsd</tt> prefix. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;xsd__boolean {false_, true_};
</td></tr></table><br></i>
The value <i>false_</i>, for example, is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:boolean xsi:type="xsd:boolean"&#62;false&lt;/xsd:boolean&#62; <br />
</td></tr></table><br></tt>
Peculiar of the SOAP boolean type encoding is that it only defines the values <tt>0</tt> and <tt>1</tt>, while the built-in XML schema boolean type also defines the <tt>false</tt> and <tt>true</tt> symbolic constants as valid values. The following example declaration of an enumeration type lacks named constants altogether to force encoding of the enumeration values as literal constants:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;SOAP_ENC__boolean {};
</td></tr></table><br></i>
The value <i>0</i>, for example, is encoded with an integer literal:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;SOAP-ENC:boolean xsi:type="SOAP-ENC:boolean"&#62;0&lt;SOAP-ENC:boolean&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc8.3.6">
8.3.6</a>&nbsp;&nbsp;<font color="#0000FF">Bitmask Enumeration Encoding and Decoding</font></h4>

<p>
A bitmask is an enumeration of flags such as declared with C#'s [Flags] <i><b>enum</b></i> annotation.
gSOAP supports bitmask encoding and decoding for interoperability. However, bitmask types are not standardized with SOAP RPC.

<p>
A special syntactic convention is used in the header file input to the gSOAP compiler to indicate the use of bitmasks with an
asterisk:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;* <i>name</i> { <i>enum-constant</i>, <i>enum-constant</i>, ... };
</td></tr></table><br></i>
The gSOAP compiler will encode the enumeration constants as flags, i.e. as a series of powers of 2 starting with 1.
The enumeration constants can be or-ed to form a bitvector (bitmask) which is encoded and decoded as a list of symbolic values
in SOAP.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;* ns__machineStatus { ON, BELT, VALVE, HATCH}; <br />
<b>int</b>&nbsp;ns__getMachineStatus(<b>char</b>&nbsp;*name, <b>char</b>&nbsp;*<b>enum</b>&nbsp;ns__machineStatus result);
</td></tr></table><br></i>
Note that the use of the <i><b>enum</b></i> does not require the asterisk, only the definition.
The gSOAP compiler generates the enumeration:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns__machineStatus { ON=1, BELT=2, VALVE=4, HATCH=8};
</td></tr></table><br></i>
A remote method implementation in a Web service can return:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__getMachineStatus(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*name, <b>enum</b>&nbsp;ns__machineStatus result) <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;*result = BELT | HATCH; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;<font color="#0000FF"><b>struct</b>&nbsp;Encoding and Decoding</font></h3>

<p>
A <i><b>struct</b></i> data type is encoded as a SOAP compound data type such that the <i><b>struct</b></i> name forms the data type's element
name and schema type and the fields of the <i><b>struct</b></i> are the data type's accessors. This encoding is identical to the
<i><b>class</b></i> instance encoding without inheritance and method declarations, see Section&nbsp;<a href="#sec:class">8.5</a> for further details.
However, the encoding and decoding of <i><b>struct</b></i>s is more efficient compared to <i><b>class</b></i> instances due to the lack of
inheritance and the requirement by the marshalling routines to check inheritance properties at run time.

<p>
	     <h3><a name="tth_sEc8.5">
8.5</a>&nbsp;&nbsp;<font color="#0000FF"><b>class</b>&nbsp;Instance Encoding and Decoding</font></h3><a name="sec:class">
</a>

<p>
A <i><b>class</b></i> instance is encoded as a SOAP compound data type such that the <i><b>class</b></i> name forms the data type's element name and schema type and the data member fields are the data type's accessors. Only the data member fields are encoded in the SOAP payload. Class methods are not encoded.

<p>
The general form of a <i><b>class</b></i> declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>class_name1 <font size="+1"><span class="roman">[</span></font>:<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>class_name2<font size="+1"><span class="roman">]</span></font> <br />
{ <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;field1; <br />
&nbsp;&nbsp;&nbsp;field2; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... <br />
}; <br />
</td></tr></table><br></i>
where

<dl compact="compact">
 <dt><b><span class="roman"><i>namespace_prefix__</i></b></dt>
	<dd> is the optional namespace prefix of the compound data type (see identifier translation rules&nbsp;<a href="#sec:idtrans">7.3</a>)</span></dd>
 <dt><b><span class="roman"><i>class_name1</i></b></dt>
	<dd>	 is the element name of the compound data type (see identifier translation rules&nbsp;<a href="#sec:idtrans">7.3</a>).</span></dd>
 <dt><b><span class="roman"><i>class_name2</i></b></dt>
	<dd>	 is an optional base class.</span></dd>
 <dt><b><span class="roman"><i>field</i></b></dt>
	<dd>	 is a field declaration (data member). A field MAY be declared <i><b>static</b></i> and <i><b>const</b></i> and MAY be initialized.</span></dd>
 <dt><b><span class="roman"><i>method</i></b></dt>
	<dd> is a method declaration. A method MAY be declared <i><b>virtual</b></i>, but abstract methods are not allowed. The method parameter declarations are REQUIRED to have parameter identifier names.</span></dd>
 <dt><b><font size="+1"><span class="roman">[</span></font>public:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>private:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>protected:<font size="+1"><span class="roman">]</span></font></b></dt>
	<dd> are OPTIONAL and have no effect on the declaration and MAY therefore be
ommitted. All access permissions are converted to <i><b>public</b></i> by the gSOAP stub and skeleton compiler.</dd>
</dl>
A class name is REQUIRED to be unique and cannot have the same name as a <i><b>struct</b></i>, <i><b>enum</b></i>, or remote method name
specified in the header file input to the gSOAP compiler.
The reason is that remote method requests are encoded similarly to class instances in SOAP and they are in principle undistinghuishable (the method parameters are encoded just as the fields of a <i><b>class</b></i>).

<p>
Only single inheritance is supported by the gSOAP compiler. Multiple inheritance is not supported, because of the limitations of the SOAP protocol.

<p>
If a constructor method is present, there MUST also be a constructor declaration with empty parameter list.

<p>
Templates are not supported by the gSOAP compiler.

<p>
A <i><b>class</b></i> instance is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>class-name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>class-name"&#62; <br />
&lt;basefield-name1 xsi:type="..."&#62;...&lt;/basefield-name1&#62; <br />
&lt;basefield-name2 xsi:type="..."&#62;...&lt;/basefield-name2&#62; <br />
... <br />
&lt;field-name1 xsi:type="..."&#62;...&lt;/field-name1&#62; <br />
&lt;field-name2 xsi:type="..."&#62;...&lt;/field-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>class-name&#62;
</td></tr></table><br></tt>
where the <tt>field-name</tt> accessors have element-name representations of the class fields and the <tt>basefield-name</tt> accessors have element-name representations of the base class fields. (The optional parts resulting from the specification are shown enclosed in <font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The decoding of a class instance allows any ordering of the accessors in the SOAP payload. However, if a base class field name is
identical to a derived class field name because the field is overloaded, the base class field name MUST precede the derived class
field name in the SOAP payload for decoding.  gSOAP guarantees this, but interoperability with other SOAP implementations is
cannot be guaranteed.

<p>
		      <h4><a name="tth_sEc8.5.1">
8.5.1</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4>

<p>
The following example declares a base class <i>ns__Object</i> and a derived class <i>ns__Shape</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "shape.h": <br />
<b>class</b>&nbsp;ns__Object <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
}; <br />
<b>class</b>&nbsp;ns__Shape : <b>public</b>&nbsp;ns__Object <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;sides; <br />
&nbsp;&nbsp;&nbsp;<b>enum</b>&nbsp;ns__Color {Red, Green, Blue} color; <br />
&nbsp;&nbsp;&nbsp;ns__Shape(); <br />
&nbsp;&nbsp;&nbsp;ns__Shape(<b>int</b>&nbsp;sides, <b>enum</b>&nbsp;ns__Green color); <br />
&nbsp;&nbsp;&nbsp;~ns__Shape(); <br />
};
</td></tr></table><br></i>
The implementation of the methods of <i><b>class</b>&nbsp;ns__Shape</i> must not be part of the header file and need to be defined elsewhere.

<p>
An instance of <i><b>class</b>&nbsp;ns__Shape</i> with name Triangle, 3 sides, and color Green is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:Shape xsi:type="ns:Shape"&#62; <br />
&lt;name xsi:type="string"&#62;Triangle&lt;/name&#62; <br />
&lt;sides xsi:type="int"&#62;3&lt;/sides&#62; <br />
&lt;color xsi:type="ns:Color"&#62;Green&lt;/color&#62; <br />
&lt;/ns:shape&#62;
</td></tr></table><br></tt>
The namespace URI of the namespace prefix <tt>ns</tt> must be defined by a namespace mapping table, see Section&nbsp;<a href="#sec:nstable">7.4</a>.

<p>
		      <h4><a name="tth_sEc8.5.2">
8.5.2</a>&nbsp;&nbsp;<font color="#0000FF">Initialized <b>static</b>&nbsp;<b>const</b>&nbsp;Fields</font></h4>

<p>
A data member field of a class declared as <i><b>static</b>&nbsp;<b>const</b></i> is initialized with a constant value at compile time. This field is encoded in the serialization process, but is not decoded in the deserialization process. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "triangle.h": <br />
<b>class</b>&nbsp;ns__Triangle : <b>public</b>&nbsp;ns__Object <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;size; <br />
&nbsp;&nbsp;&nbsp;<b>static</b>&nbsp;<b>const</b>&nbsp;<b>int</b>&nbsp;sides = 3; <br />
};
</td></tr></table><br></i>
An instance of <i><b>class</b>&nbsp;ns__Triangle</i> is encoded in SOAP as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:Triangle xsi:type="ns:Triangle"&#62; <br />
&lt;name xsi:type="string"&#62;Triangle&lt;/name&#62; <br />
&lt;size xsi:type="int"&#62;15&lt;/size&#62; <br />
&lt;sides xsi:type="int"&#62;3&#62;/sides&#62; <br />
&lt;/ns:Triangle&#62;
</td></tr></table><br></tt>
Decoding will ignore the <i>sides</i> field's value.

<p>
<font color="#FF0000"><b>Caution</b></font>: The current gSOAP implementation does not support encoding <i><b>static</b>&nbsp;<b>const</b></i> fields, due to C++ compiler
compatibility differences. This feature may be provided the future.

<p>
		      <h4><a name="tth_sEc8.5.3">
8.5.3</a>&nbsp;&nbsp;<font color="#0000FF">Class Methods</font></h4>

<p>
A <i><b>class</b></i> declaration in the header file input to the gSOAP compiler MAY include method declarations.
The method implementations MUST NOT be part of the header file but are required to be defined in another C++ source that is externally linked with the application. This convention is also used for the constructors and destructors of the <i><b>class</b></i>.

<p>
Dynamic binding is supported, so a method MAY be declared <i><b>virtual</b></i>.

<p>
		      <h4><a name="tth_sEc8.5.4">
8.5.4</a>&nbsp;&nbsp;<font color="#0000FF">Polymorphism, Derived Classes, and Dynamic Binding</font></h4>

<p>
Interoperability between client and service applications developed with gSOAP is established even when clients and/or services use
derived classes instead of the base classes used in the declaration of the remote method parameters.  A client application MAY use
pointers to instances of derived classes for the input parameters of a remote method. If the service was compiled with a
declaration and implementation of the derived class, the remote method base class input parameters are demarshalled and a derived
class instance is created instead of a base class instance. If the service did not include a declaration of the derived class, the
derived class fields are ignored and a base class instance is created. Therefore, interoperability is guaranteed even when the
client sends an instance of a derived classes and when a service returns an instance of a derived class.

<p>
The following example declares Base and Derived classes and a remote method that takes a pointer to a Base class instance and returns a Base class instance:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "derived.h" <br />
<b>class</b>&nbsp;Base <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;Base(); <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>class</b>&nbsp;Derived : <b>public</b>&nbsp;Base <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;num; <br />
&nbsp;&nbsp;&nbsp;Derived(); <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>int</b>&nbsp;method(Base *in, <b>struct</b>&nbsp;methodResponse { Base *out; } &amp;result);
</td></tr></table><br></i>
This header file specification is processed by the gSOAP compiler to produce the stub and skeleton routines which are used to implement a client and service.
The pointer of the remote method is also allowed to point to Derived class instances and these instances will be marshalled as Derived class instances and send to a service, which is in accord to the usual semantics of parameter passing in C++ with dynamic binding.

<p>
The Base and Derived class method implementations are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Method implementations of the Base and Derived classes: <br />
#include "soapH.h" <br />
... <br />
Base::Base() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "created a Base class instance"  &lt;&lt;  endl; <br />
} <br />
Derived::Derived() <br />
{<br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "created a Derived class instance"  &lt;&lt;  endl; <br />
} <br />
Base::print()
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "print(): Base class instance "  &lt;&lt;  name  &lt;&lt;  endl; <br />
} <br />
Derived::print()
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "print(): Derived class instance "  &lt;&lt;  name  &lt;&lt;  " "  &lt;&lt;  num  &lt;&lt;  endl; <br />
}
</td></tr></table><br></i>
Below is an example <i>CLIENT</i> application that creates a Derived class instance that is passed as the input parameter of the remote method:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// CLIENT <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;Derived obj1; <br />
&nbsp;&nbsp;&nbsp;Base *obj2; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;methodResponse r; <br />
&nbsp;&nbsp;&nbsp;obj1.name = "X"; <br />
&nbsp;&nbsp;&nbsp;obj1.num = 3; <br />
&nbsp;&nbsp;&nbsp;soap_call_method(&amp;soap, url, action, &amp;obj1, r); <br />
&nbsp;&nbsp;&nbsp;r.obj2<tt>-&gt;</tt>print(); <br />
} <br />
...
</td></tr></table><br></i>
The following example <i>SERVER1</i> application copies a class instance (Base or Derived class) from the input to the output parameter:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// SERVER1 <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
} <br />
<b>int</b>&nbsp;method(<b>struct</b>&nbsp;soap *soap, Base *obj1, <b>struct</b>&nbsp;methodResponse &amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;obj1<tt>-&gt;</tt>print(); <br />
&nbsp;&nbsp;&nbsp;result.obj2 = obj1; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
...
</td></tr></table><br></i>
The following messages are produced by the <i>CLIENT</i> and <i>SERVER1</i> applications:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
CLIENT: created a Derived class instance <br />
SERVER1: created a Derived class instance <br />
SERVER1: print(): Derived class instance X 3 <br />
CLIENT: created a Derived class instance <br />
CLIENT: print(): Derived class instance X 3
</td></tr></table><br></span>
Which indicates that the derived class kept its identity when it passed through <i>SERVER1</i>. Note that instances are created both by the <i>CLIENT</i> and <i>SERVER1</i> by the demarshalling process.

<p>
Now suppose a service application is developed that only accepts Base class instances. The header file is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "base.h": <br />
<b>class</b>&nbsp;Base <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;Base(); <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>int</b>&nbsp;method(Base *in, Base *out);
</td></tr></table><br></i>
This header file specification is processed by the gSOAP stub and skeleton compiler to produce skeleton routine which is used to implement a service (so the client will still use the derived classes).

<p>
The method implementation of the Base class are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Method implementations of the Base class: <br />
#include "soapH.h" <br />
... <br />
Base::Base()
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "created a Base class instance"  &lt;&lt;  endl; <br />
} <br />
Base::print() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "print(): Base class instance "  &lt;&lt;  name  &lt;&lt;  endl; <br />
} <br />
</td></tr></table><br></i>
And the <i>SERVER2</i> application is that uses the Base class is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// SERVER2 <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
} <br />
<b>int</b>&nbsp;method(<b>struct</b>&nbsp;soap *soap, Base *obj1, <b>struct</b>&nbsp;methodResponse &amp;result)
{ <br />
&nbsp;&nbsp;&nbsp;obj1<tt>-&gt;</tt>print(); <br />
&nbsp;&nbsp;&nbsp;result.obj2 = obj1; <br />
&nbsp;&nbsp;&nbsp;return SOAP_OK; <br />
} <br />
...
</td></tr></table><br></i>
Here are the messages produced by the <i>CLIENT</i> and <i>SERVER2</i> applications:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
CLIENT: created a Derived class instance <br />
SERVER2: created a Base class instance <br />
SERVER2: print(): Base class instance X <br />
CLIENT: created a Base class instance <br />
CLIENT: print(): Base class instance X
</td></tr></table><br></span>
In this example, the object was passed as a Derived class instance to <i>SERVER2</i>. Since <i>SERVER2</i> only implements the Base class, this object is converted to a Base class instance and send back to <i>CLIENT</i>.

<p>
	     <h3><a name="tth_sEc8.6">
8.6</a>&nbsp;&nbsp;<font color="#0000FF">Pointer Encoding and Decoding</font></h3><a name="sec:pointer">
</a>

<p>
The serialization of a pointer to a data type amounts to the serialization of the data type in SOAP and the SOAP encoded
representation of a pointer to the data type is indistinghuishable from the encoded representation of the data type pointed to.

<p>
		      <h4><a name="tth_sEc8.6.1">
8.6.1</a>&nbsp;&nbsp;<font color="#0000FF">Multi-Reference Data</font></h4>

<p>
A data structure pointed to by more than one pointer is serialized as SOAP multi-reference data. This means that
the data will be serialized only once and
identified with a unique <tt>id</tt> attribute. The encoding of the pointers to the shared data is done through the use of
<tt>href</tt> attributes to refer to the multi-reference data (also see Section&nbsp;<a href="#sec:flags">6.6</a> on options to
control the serialization of multi-reference data).
Cyclic C/C++ data structures are encoded with multi-reference SOAP encoding.
Consider for example the following a linked list data structure:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>struct</b>&nbsp;ns__list<br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__string value; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__list *next; <br />
};
</td></tr></table><br></i>
Suppose a cyclic linked list is created. The first node contains the value "<tt>abc</tt>" and points to a node with value
"<tt>def</tt>" which in turn points to the first node. This is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:list id="1" xsi:type="ns:list"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;value xsi:type="xsd:string"&#62;abc&lt;/value&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;next xsi:type="ns:list"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value xsi:type="xsd:string"&#62;def&lt;/value&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;next href="#1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/next&#62; <br />
&lt;/ns:list&#62;
</td></tr></table><br></tt>
In case multi-referenced data is received that ``does not fit in a pointer-based structure'', the data is copied.
For example, the following two <i><b>struct</b></i>s are similar, except that the first uses pointer-based fields while the other uses
non-pointer-based fields:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int; <br />
<b>struct</b>&nbsp;ns__record <br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__int *a; <br />
&nbsp;&nbsp;&nbsp;xsd__int *b; <br />
} P; <br />
<b>struct</b>&nbsp;ns__record<br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__int a; <br />
&nbsp;&nbsp;&nbsp;xsd__int b; <br />
} R; <br />
... <br />
&nbsp;&nbsp;&nbsp;P.a = &amp;n; <br />
&nbsp;&nbsp;&nbsp;P.b = &amp;n; <br />
...
</td></tr></table><br></i>
Since both <i>a</i> and <i>b</i> fields of <i>P</i> point to the same integer, the encoding of <i>P</i> is multi-reference:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:record xsi:type="ns:record"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;a href="#1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;b href="#1"/&#62; <br />
&lt;/ns:record&#62; <br />
&lt;id id="1" xsi:type="xsd:int"&#62;123&lt;/id&#62;
</td></tr></table><br></tt>
Now, the decoding of the content in the <i>R</i> data structure that does not use pointers to integers results in a copy of each
multi-reference integer.  Note that the two <i><b>struct</b></i>s resemble the same XML data type because the trailing underscore will be
ignored in XML encoding and decoding.

<p>
		      <h4><a name="tth_sEc8.6.2">
8.6.2</a>&nbsp;&nbsp;<font color="#0000FF">NULL Pointers and Nil Elements</font></h4>

<p>
A <i>NULL</i> pointer is <b>not</b> serialized, unless the pointer itself is pointed to by another pointer (but see
Section&nbsp;<a href="#sec:flags">6.6</a> to control the serialization of NULLs).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;X <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*p; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;**q; <br />
}
</td></tr></table><br></i>
Suppose pointer <i>q</i> points to pointer <i>p</i> and suppose <i>p=NULL</i>.
In that case the <i>p</i> pointer is serialized as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;... id="123" xsi:nil="true"/&#62;
</td></tr></table><br></tt>
and the serialization of <i>q</i> refers to <tt>href="#123"</tt>.
Note that SOAP 1.1 does not support
pointer to pointer types (!), so this encoding is specific to gSOAP. The pointer to pointer encoding is rarely used in codes
anyway.  More common is a pointer to a data type such as a <i><b>struct</b></i> with pointer fields.

<p>
<font color="#FF0000"><b>Caution</b></font>: When the deserializer encounters an XML element that has a <tt>xsi:nil="true"</tt> attribute but the corresponding C++ data is not a pointer or reference,
the deserializer will terminate with a <i>SOAP_NULL</i> fault when the <i>soap.enable_null</i> flag is set.
The types section of a WSDL description contains information on the ``nilability'' of data.

<p>
	     <h3><a name="tth_sEc8.7">
8.7</a>&nbsp;&nbsp;<font color="#0000FF">Fixed-Size Arrays</font></h3>

<p>
Fixed size arrays are encoded as per SOAP 1.1 one-dimensional array types.  Multi-dimensional fixed size arrays are encoded by
gSOAP as nested one-dimensional arrays in SOAP.
Encoding of fixed size arrays supports partially transmitted and sparse array SOAP formats.

<p>
The decoding of (multi-dimensional) fixed-size arrays supports the SOAP multi-dimensional array format as well as partially transmitted and sparse array formats.

<p>
An example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of header file "fixed.h": <br />
<b>struct</b>&nbsp;Example <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;a[2][3]; <br />
};
</td></tr></table><br></i>
This specifies a fixed-size array part of the <i><b>struct</b>&nbsp;Example</i>. The encoding of array <i>a</i> is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;a xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="float[][2]"&#62; <br />
&lt;SOAP-ENC:Array xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="float[3]" <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;/SOAP-ENC:Array&#62; <br />
&lt;SOAP-ENC:Array xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="float[3]" <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;/SOAP-ENC:Array&#62; <br />
&lt;/a&#62;
</td></tr></table><br></tt>
<font color="#FF0000"><b>Caution</b></font>: Any decoded parts of a (multi-dimensional) array that do not ``fit'' in the fixed size array are ignored by the deserializer.

<p>
	     <h3><a name="tth_sEc8.8">
8.8</a>&nbsp;&nbsp;<font color="#0000FF">Dynamic Arrays</font></h3><a name="sec:dynarray">
</a>

<p>
As the name suggests, dynamic arrays are much more flexible than fixed-size arrays and dynamic arrays are better adaptabe to the
SOAP encoding and decoding rules for arrays.  In addition, a typical C application allocates a dynamic array using <i>malloc</i>,
assigns the location to a pointer variable, and deallocates the array later with <i>free</i>.  A typical C++ application allocates
a dynamic array using <i>new</i>, assigns the location to a pointer variable, and deallocates the array later with <i>delete</i>.
Such dynamic allocations are flexible, but pose a problem for the serialization of data: how does the array serializer know the
length of the array to be serialized given only a pointer to the sequence of elements?  The application stores the size
information somewhere. This information is crucial for the array serializer and has to be made explicitly known to the array
serializer by packaging the pointer and array size information within a <i><b>struct</b></i> or <i><b>class</b></i>.

<p>
		      <h4><a name="tth_sEc8.8.1">
8.8.1</a>&nbsp;&nbsp;<font color="#0000FF">One-Dimensional Dynamic Arrays</font></h4>

<p>
A special form of <i><b>struct</b></i> or <i><b>class</b></i> is used for one-dimensional dynamic arrays
that contains a pointer variable and a field that records the number of elements the pointer points to in memory.

<p>
The general form of the <i><b>struct</b></i> declaration for one-dimensional dynamic arrays is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">[</span></font><b>static</b>&nbsp;<b>const</b><font size="+1"><span class="roman">]</span></font> <b>int</b>&nbsp;__offset <font size="+1"><span class="roman">[</span></font>= ...<font size="+1"><span class="roman">]</span></font>;<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;... // anything that follows here will be ignored <br />
};
</td></tr></table><br></i>
where <i><u><span class="roman">Type</span></u></i> MUST be a type associated with an XML schema or MUST be a primitive type.
If these conditions are not met, a list/vector (de)serialization is used (see Section&nbsp;<a href="#sec:list">8.8.6</a>).
A primitive type can be used with or without a <i><b>typedef</b></i>.
If the array elements are structs or classes, then the <i>struct</i>/<i>class</i> type names should have a namespace prefix for schema
association, or they should be other (nested) dynamic arrays. 

<p>
An alternative to a <i><b>struct</b></i> is to use a <i><b>class</b></i> with optional methods that MUST appear after the <i>__ptr</i> and
<i>__size</i> fields:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">[</span></font><b>static</b>&nbsp;<b>const</b><font size="+1"><span class="roman">]</span></font> <b>int</b>&nbsp;__offset <font size="+1"><span class="roman">[</span></font>= ...<font size="+1"><span class="roman">]</span></font>;<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... // any fields that follow will be ignored <br />
};
</td></tr></table><br></i>
To encode the data type as an array, the name of the <i><b>struct</b></i> or <i><b>class</b></i> SHOULD NOT have a namespace prefix, otherwise
the data type will be encoded and decoded as a SOAP list/vector, see Section&nbsp;<a href="#sec:list">8.8.6</a>.

<p>
The deserializer of a dynamic array can decode partially transmitted and/or SOAP sparse arrays, and even multi-dimensional arrays
which will be collapsed into a one-dimensional array with row-major ordering.

<p>
		      <h4><a name="tth_sEc8.8.2">
8.8.2</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4>

<p>
The following example header file specifies the XMethods Service Listing service <i>getAllSOAPServices</i> remote method and an array of <i>SOAPService</i> data structures:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "listing.h": <br />
<b>class</b>&nbsp;ns3__SOAPService <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;ID; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*owner; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*description; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*homepageURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*endpoint; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAPAction; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodNamespaceURI; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serviceStatus; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodName; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*dateCreated; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*downloadURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*wsdlURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*instructions; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*contactEmail; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serverImplementation; <br />
}; <br />
<b>class</b>&nbsp;ServiceArray <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;ns3__SOAPService *__ptr; // points to array elements <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; // number of elements pointed to <br />
&nbsp;&nbsp;&nbsp;ServiceArray(); <br />
&nbsp;&nbsp;&nbsp;~ServiceArray(); <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>int</b>&nbsp;ns__getAllSOAPServices(ServiceArray &amp;return_);
</td></tr></table><br></i>
An example client application:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h"
... <br />
// ServiceArray class method implementations: <br />
ServiceArray::ServiceArray() <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = NULL; <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
} <br />
ServiceArray::~ServiceArray() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(__ptr) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(__ptr); <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
} <br />
<b>void</b>&nbsp;ServiceArray::print() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 0; i &lt; __size; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  __ptr[i].name  &lt;&lt;  ": "  &lt;&lt;  __ptr[i].homepage  &lt;&lt;  endl; <br />
} <br />
... <br />
// Request a service listing and display results: <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ServiceArray result; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint = "www.xmethods.net:80/soap/servlet/rpcrouter"; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*action = "urn:xmethodsServicesManager#getAllSOAPServices"; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__getAllSOAPServices(&amp;soap, endpoint, action, result); <br />
&nbsp;&nbsp;&nbsp;result.print(); <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>

<p>
		      <h4><a name="tth_sEc8.8.3">
8.8.3</a>&nbsp;&nbsp;<font color="#0000FF">One-Dimensional Dynamic Arrays With Non-Zero Offset</font></h4>

<p>
The declaration of a dynamic array as described in&nbsp;<a href="#sec:dynarray">8.8</a> MAY include an <i><b>int</b>&nbsp;__offset</i> field. When set to an
integer value, the serializer of the dynamic array will use this field as the start index of the array and the SOAP array offset
attribute will be used in the SOAP payload.

<p>
For example, the following header file declares a mathematical <i>Vector</i> class, which is a dynamic array of floating point values with an index that starts at 1:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "vector.h": <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>class</b>&nbsp;Vector <br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__float *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset; <br />
&nbsp;&nbsp;&nbsp;Vector(); <br />
&nbsp;&nbsp;&nbsp;Vector(<b>int</b>&nbsp;n); <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&amp; <b>operator</b>[](<b>int</b>&nbsp;i); <br />
}
</td></tr></table><br></i>
The implementations of the <i>Vector</i> methods are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
Vector::Vector() <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = NULL; <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
&nbsp;&nbsp;&nbsp;__offset = 1; <br />
} <br />
Vector::Vector(<b>int</b>&nbsp;n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = (<b>float</b>*)malloc(n*sizeof(<b>float</b>)); <br />
&nbsp;&nbsp;&nbsp;__size = n; <br />
&nbsp;&nbsp;&nbsp;__offset = 1; <br />
} <br />
Vector::~Vector() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(__ptr) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(__ptr); <br />
} <br />
<b>float</b>&amp; Vector::<b>operator</b>[](<b>int</b>&nbsp;i) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;__ptr[i-__offset]; <br />
}
</td></tr></table><br></i>
An example program fragment that serializes a vector of 3 elements:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
Vector v(3); <br />
v[1] = 1.0; <br />
v[2] = 2.0; <br />
v[3] = 3.0; <br />
soap_begin(&amp;soap); <br />
v.serialize(&amp;soap); <br />
v.put(<tt>"vec"</tt>); <br />
soap_end(&amp;soap);
</td></tr></table><br></i>
The output is a partially transmitted array:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;vec xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="xsd:float[4]" SOAP-ENC:offset="[1]"&#62; <br />
&lt;item xsi:type="xsd:float"&#62;1.0&lt;/item&#62; <br />
&lt;item xsi:type="xsd:float"&#62;2.0&lt;/item&#62; <br />
&lt;item xsi:type="xsd:float"&#62;3.0&lt;/item&#62; <br />
&lt;/vec&#62;
</td></tr></table><br></tt>
Note that the size of the encoded array is necessarily set to 4 and that the encoding omits the non-existent element at index 0.

<p>
The decoding of a dynamic array with an <i>__offset</i> field is more efficient than decoding a dynamic array without an <i>__offset</i> field, because the <i>__offset</i> field will be assigned the value of the <tt>SOAP-ENC:offset</tt> attribute instead of padding the initial part of the array with default values.

<p>
		      <h4><a name="tth_sEc8.8.4">
8.8.4</a>&nbsp;&nbsp;<font color="#0000FF">Nested One-Dimensional Dynamic Arrays</font></h4><a name="sec:nested">
</a>

<p>
One-dimensional dynamic arrays MAY be nested.
For example, using <i><b>class</b>&nbsp;Vector</i> declared in the previous section, <i><b>class</b>&nbsp;Matrix</i> is declared:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "matrix.h": <br />
<b>class</b>&nbsp;Matrix <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;Vector *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset; <br />
&nbsp;&nbsp;&nbsp;Matrix(); <br />
&nbsp;&nbsp;&nbsp;Matrix(<b>int</b>&nbsp;n, <b>int</b>&nbsp;m); <br />
&nbsp;&nbsp;&nbsp;~Matrix(); <br />
&nbsp;&nbsp;&nbsp;Vector&amp; <b>operator</b>[](<b>int</b>&nbsp;i); <br />
}; 
</td></tr></table><br></i>
The Matrix type is essentially an array of pointers to arrays which make up the rows of a matrix.
The encoding of the two-dimensional dynamic array in SOAP will be in nested form.

<p>
		      <h4><a name="tth_sEc8.8.5">
8.8.5</a>&nbsp;&nbsp;<font color="#0000FF">Multi-Dimensional Dynamic Arrays</font></h4>

<p>
The general form of the <i><b>struct</b></i> declaration for K-dimensional (K&#62;1) dynamic arrays is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size[K]; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset[K]; <br />
&nbsp;&nbsp;&nbsp;... // anything that follows here will be ignored <br />
};
</td></tr></table><br></i>
where <i><u><span class="roman">Type</span></u></i> MUST be a type associated with an XML schema, which means that it must be a <i><b>typedef</b></i>ed type
in case of a primitive type, or a <i><b>struct</b></i>/<i><b>class</b></i> name with a namespace prefix for schema association, or another dynamic array. If these conditions are not met, a list/vector (de)serialization is used (see Section&nbsp;<a href="#sec:list">8.8.6</a>).

<p>
An alternative is to use a <i><b>class</b></i> with optional methods:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size[K]; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset[K]; <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... // any fields that follow will be ignored <br />
};
</td></tr></table><br></i>
In the above, K is a constant denoting the number of dimensions of the multi-dimensional array.

<p>
To encode the data type as an array, the name of the <i><b>struct</b></i> or <i><b>class</b></i> SHOULD NOT have a namespace prefix, otherwise
the data type will be encoded and decoded as a SOAP list/vector, see Section&nbsp;<a href="#sec:list">8.8.6</a>.

<p>
The deserializer of a dynamic array can decode partially transmitted multi-dimensional arrays.

<p>
For example, the following declaration specifies a matrix class:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>class</b>&nbsp;Matrix <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__double *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size[2]; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset[2]; <br />
}; 
</td></tr></table><br></i>
In contrast to the matrix class of Section&nbsp;<a href="#sec:nested">8.8.4</a> that defined a matrix as an array of pointers to matrix rows, this
class has one pointer to a matrix stored in row-major order.  The size of the matrix is determined by the <i>__size</i> field:
<i>__size[0]</i> holds the number of rows and <i>__size[1]</i> holds the number of columns of the matrix.  Likewise, <i>__
offset[0]</i> is the row offset and <i>__offset[1]</i> is the columns offset.

<p>
		      <h4><a name="tth_sEc8.8.6">
8.8.6</a>&nbsp;&nbsp;<font color="#0000FF">Dynamic Array as List Encoding</font></h4><a name="sec:list">
</a>

<p>
In case the name of the <i><b>struct</b></i> or <i><b>class</b></i> of a dynamic array has a namespace prefix, the data type is considered a
list (a.k.a.&nbsp;vector) and will be serialized as a SOAP list and not encoded as a SOAP array.

<p>
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__Map <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__Binding {<b>char</b>&nbsp;*key; <b>char</b>&nbsp;*val;} *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
This declares a dynamic array, but the array will be serialized and deserialized as a list. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:Map xsi:type="ns:Map"&#62; <br />
&lt;ns:Binding xsi:type="ns:Binding"&#62; <br />
&lt;key&#62;Joe&lt;/key&#62; <br />
&lt;val&#62;555 77 1234&lt;/val&#62; <br />
&lt;/ns:Binding&#62; <br />
&lt;ns:Binding xsi:type="ns:Binding"&#62; <br />
&lt;key&#62;Susan&lt;/key&#62; <br />
&lt;val&#62;555 12 6725&lt;/val&#62; <br />
&lt;/ns:Binding&#62; <br />
&lt;ns:Binding xsi:type="ns:Binding"&#62; <br />
&lt;key&#62;Pete&lt;/key&#62; <br />
&lt;val&#62;555 99 4321&lt;/val&#62; <br />
&lt;/ns:Binding&#62; <br />
&lt;/ns:Map&#62;
</td></tr></table><br></tt>
Deserialization is less efficient compared to an array, because the size of the list is not part of the SOAP encoding. Internal buffering is used by the deserializer to collect the elements. When the end of the list is reached, the buffered elements are copied to a newly allocated space on the heap for the dynamic array.

<p>
A list (de)serialization is also in affect for dynamic arrays when the pointer field does not refer to a type that is associated
with a schema. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;vector <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Since <i><b>int</b></i> has no association with a schema, a <i>vector</i> structure <i>X</i> is serialized as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;X&#62; <br />
&lt;item&#62;1&lt;/item&#62; <br />
&lt;item&#62;-2&lt;/item&#62; <br />
... <br />
&lt;/X&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc8.8.7">
8.8.7</a>&nbsp;&nbsp;<font color="#0000FF">Polymorphic Dynamic Arrays and Lists</font></h4>

<p>
An array of pointers to class instances allows the encoding of polymorphic arrays (arrays of polymorphic element types)
and lists.  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;ns__Object <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;... <br />
}; <br />
<b>class</b>&nbsp;ns__Data: <b>public</b>&nbsp;ns__Object <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;... <br />
}; <br />
<b>class</b>&nbsp;ArrayOfObject <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;ns__Object **__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset; <br />
}; 
</td></tr></table><br></i>
The pointers in the array can point to the <i>ns__Object</i> base class or <i>ns__Data</i> derived class instances which will be
serialized and deserialized accordingly in SOAP.  That is, the array elements are polymorphic.

<p>
		      <h4><a name="tth_sEc8.8.8">
8.8.8</a>&nbsp;&nbsp;<font color="#0000FF">How to Change the Tag Names of the Elements of a SOAP Array or List</font></h4>

<p>
The <i>__ptr</i> field in a <i><b>struct</b></i> or <i><b>class</b></i> declaration of a dynamic array may have an optional suffix part that
describes the name of the tags of the SOAP array XML elements.
The suffix is part of the field name:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">Type</span></u> *__ptr<u><span class="roman">array_elt_name</span></u>
</td></tr></table><br></i>
The suffix describes the tag name to be used for all array elements. The usual identifier to XML translations apply, see
Section&nbsp;<a href="#sec:idtrans">7.3</a>.
The default XML element tag name for array elements is <tt>item</tt> (which corresponds to the use of field name <i>__ptritem</i>).

<p>
Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ArrayOfstring <br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__string *__ptrstring;
&nbsp;&nbsp;&nbsp;int __size;
};
</td></tr></table><br></i>
The array is serialized as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;array xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="xsd:string[2]&#187; <br />
&lt;string xsi:type="xsd:string&#187;Hello&lt;/string&#62; <br />
&lt;string xsi:type="xsd:string&#187;World&lt;/string&#62; <br />
&lt;/array&#62;
</td></tr></table><br></tt>
SOAP 1.1 and 1.2 do not require the use of a specific tag name for array elements.  gSOAP will deserialize a SOAP array while
ignoring the tag names. Certain XML schemas used in doc/literal encoding may require the declaration of arrray element tag names.

<p>
		      <h4><a name="tth_sEc8.8.9">
8.8.9</a>&nbsp;&nbsp;<font color="#0000FF">Embedded Arrays and Lists</font></h4>

<p>
An array (or list) can be embedded in a struct/class without the need to declare a separate array data type.
When a struct or class type declaration contains a <i><b>int</b>&nbsp;__size</i> field and the next field below is a pointer type,
gSOAP assumes the pointer type points to an array of values where the <i>__size</i> field holds the number of values at run time.
Multiple arrays can be embedded in a struct/class by using <i>__size</i> field names that end with a unique name suffix.

<p>
The general convention for embedding arrays is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__SomeStruct <br />
{ <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size<u><span class="roman">name1</span></u>; // number of elements pointed to <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type1</span></u> *<u>field1</u>; // by this field <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size<u><span class="roman">name2</span></u>; // number of elements pointed to <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type2</span></u> *<u>field2</u>; // by this field <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
where <i><u><span class="roman">name1</span></u></i> and <i><u><span class="roman">name2</span></u></i> are identifiers used as a suffix to distinghuish the <i>__
size</i> field. These names can be arbitrary and are not visible in XML.

<p>
For example, the following struct has two embedded arrays:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__Contact <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*firstName; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*lastName; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__sizePhones; <br />
&nbsp;&nbsp;&nbsp;ULONG64 *phoneNumber; // array of phone numbers <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__sizeEmails; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;**emailAddress; // array of email addresses <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*socSecNumber; <br />
};
</td></tr></table><br></i>
The XML serialization of an example <i>ns__Contact</i> is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;mycontact xsi:type="ns:Contact"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;firstName&#62;Joe&lt;/firstName&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;lastName&#62;Smith&lt;/lastName&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;phoneNumber&#62;5551112222&lt;/phoneNumber&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;phoneNumber&#62;5551234567&lt;/phoneNumber&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;phoneNumber&#62;5552348901&lt;/phoneNumber&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;emailAddress&#62;Joe.Smith@mail.com&lt;/emailAddress&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;emailAddress&#62;Joe@Smith.com&lt;/emailAddress&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;socSecNumber&#62;999999999&lt;/socSecNumber&#62; <br />
&lt;/mycontact&#62;
</td></tr></table><br></tt>

<p>
	     <h3><a name="tth_sEc8.9">
8.9</a>&nbsp;&nbsp;<font color="#0000FF">Base64Binary XML Schema Type Encoding</font></h3><a name="sec:base64binary">
</a>

<p>
The <tt>base64Binary</tt> XML schema type is a special form of dynamic array declared with a pointer (<i>__ptr</i>) to an
<i><b>unsigned</b>&nbsp;<b>char</b></i> array.

<p>
For example using a <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Or with a <i><b>class</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
When compiled by the gSOAP stub and skeleton compiler, this header file specification will generate <tt>base64Binary</tt> serializers and deserializers.

<p>
The <tt>SOAP_ENC:base64</tt> encoding is another type for base 64 binary encoding
specified by the SOAP data type schema and some SOAP applications may use this form
(as indicated by their WSDL descriptions). It is declared by:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENC__base64 <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Or with a <i><b>class</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;SOAP_ENC__base64 <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
When compiled by the gSOAP stub and skeleton compiler, this header file specification will generate <tt>SOAP-ENC:base64</tt> serializers and deserializers.

<p>
The advantage of using a <i><b>class</b></i> is that methods can be used to initialize and manipulate the <i>__ptr</i> and <i>__size</i> fields. The user can add methods to this class to do this. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;xsd__base64Binary(); // Constructor <br />
&nbsp;&nbsp;&nbsp;xsd__base64Binary(<b>int</b>&nbsp;n); // Constructor <br />
&nbsp;&nbsp;&nbsp;~xsd__base64Binary(); // Destructor <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*location(); // returns the memory location <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;size(); // returns the number of bytes <br />
};
</td></tr></table><br></i>
Here are example method implementations:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
xsd__base64Binary::xsd__base64Binary() <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = NULL; <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
} <br />
xsd__base64Binary::xsd__base64Binary(<b>int</b>&nbsp;n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = (<b>unsigned</b>&nbsp;<b>int</b>*)malloc(n); <br />
&nbsp;&nbsp;&nbsp;__size = n; <br />
} <br />
xsd__base64Binary::~xsd__base64Binary() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(__ptr) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(__ptr); <br />
} <br />
<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*xsd__base64Binary::location() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;__ptr; <br />
} <br />
<b>int</b>&nbsp;xsd__base64Binary::size() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;__size; <br />
}
</td></tr></table><br></i>
The following example in C/C++ reads from a raw image file and encodes the image in SOAP using the <tt>base64Binary</tt> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
FILE *fd = fopen(<tt>"image.jpg"</tt>, <tt>"r"</tt>); <br />
xsd__base64Binary image(filesize(fd)); <br />
fread(image.location(), image.size(), 1, fd); <br />
fclose(fd); <br />
soap_begin(&amp;soap); <br />
image.soap_serialize(&amp;soap); <br />
image.soap_put(&amp;soap, <tt>"jpegimage"</tt>, NULL); <br />
soap_end(&amp;soap); <br />
...
</td></tr></table><br></i>
where <i>filesize</i> is a function that returns the size of a file given a file descriptor.

<p>
Reading the <tt>xsd:base64Binary</tt> encoded image.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
xsd__base64Binary image; <br />
soap_begin(&amp;soap); <br />
image.get(&amp;soap, <tt>"jpegimage"</tt>); <br />
soap_end(&amp;soap); <br />
...
</td></tr></table><br></i>
The <i><b>struct</b></i> or <i><b>class</b></i> name <i>soap_enc__base64</i> should be used for <tt>SOAP-ENC:base64</tt> schema type instead of
<i>xsd__base64Binary</i>.

<p>
	     <h3><a name="tth_sEc8.10">
8.10</a>&nbsp;&nbsp;<font color="#0000FF">hexBinary XML Schema Type Encoding</font></h3><a name="sec:hexbinary">
</a>

<p>
The <tt>hexBinary</tt> XML schema type is a special form of dynamic array declared with the name <i>xsd__hexBinary</i> and a pointer (<i>__ptr</i>) to an <i><b>unsigned</b>&nbsp;<b>char</b></i> array.

<p>
For example, using a <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__hexBinary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Or using a <i><b>class</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__hexBinary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
When compiled by the gSOAP stub and skeleton compiler, this header file specification will generate <tt>base64Binary</tt> serializers and deserializers.

<p>
	     <h3><a name="tth_sEc8.11">
8.11</a>&nbsp;&nbsp;<font color="#0000FF">Doc/Literal XML Encoding Style</font></h3><a name="sec:literal">
</a>

<p>
gSOAP supports doc/literal SOAP encoding of request and/or response messages. However, there are some limitations on the XML format
to support (de)serialization of XML documents into C/C++ data structures.
XML documents may contain constructs that gSOAP cannot parse and will simply ignore because the gSOAP XML parser has been
optimized for SOAP data. This occurs when the XML document uses XML attribute values that are part of the data.
Arbitrary XML documents can be (de)serialized into regular C strings or wide character strings (<i>wchar_t*</i>) by gSOAP.
Because XML documents are stored in strings, an application may need a ``plug-in'' XML parser to decode XML content stored in
strings. For details on (de)serialization XML into strings, see Section&nbsp;<a href="#sec:literal2">8.11.1</a>.

<p>
gSOAP supports doc/literal SOAP encoding either manually by setting <i>soap.encodingStyle</i>, <i>soap.defaultNamespace</i>,
and <i>soap.disable_href</i> of the current gSOAP environment <i>soap</i>, or automatically by using a gSOAP directive in the header file.
In most doc/literal cases, the <tt>SOAP-ENV:encodingStyle</tt> attribute needs to be absent. To do this,
set <i>soap.encodingStyle=NULL</i>. Furthermore, a default namespace needs to be defined by setting <i>soap.defaultNamespace</i>.
Finally, doc/literal is a limited form of serialization and does not support graphs. So
setting <i>soap.disable_href=1</i> will not produce multi-reference data. Note that cyclic data will crash the doc/literal
serializer because of this setting. Also polymorphic data may cause deserialization problems due to the absense of type
information in the SOAP payload (which makes us wonder why doc/literal is the default in .NET).

<p>
The <i>LocalTimeByZipCode</i> remote method of the LocalTime service provides the local time given a zip code and uses doc/literal
SOAP encoding (using MS .NET).
The following header file declares the method:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
int LocalTimeByZipCode(<b>char</b>&nbsp;*ZipCode, <b>char</b>&nbsp;**LocalTimeByZipCodeResult);
</td></tr></table><br></i>
Note that none of the data types need to be namespace qualified using namespace prefixes. The use of namespace prefixes is
optional for doc/literal in gSOAP. When used, the XML document will include <tt>xsi:type</tt> attributes.

<p>
To illustrate the manual doc/literal setting, the following client program sets the required properties before the call:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.encodingStyle = NULL; // don't use SOAP encoding <br />
&nbsp;&nbsp;&nbsp;soap.defaultNamespace = "http://alethea.net/webservices/"; // use the service's namespace <br />
&nbsp;&nbsp;&nbsp;soap.disable_href = 1;" // don't produce multi-ref data (but can accept) <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_LocalTimeByZipCode(&amp;soap, "http://alethea.net/webservices/LocalTime.asmx", "http://alethea.net/webservices/LocalTimeByZipCode", "32306", &amp;t)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Time = %s<tt>\n</tt>", t); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
The SOAP request is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /webservices/LocalTime.asmx HTTP/1.0 <br />
Host: alethea.net <br />
Content-Type: text/xml; charset=utf-8 <br />
Content-Length: 479 <br />
SOAPAction: "http://alethea.net/webservices/LocalTimeByZipCode" <br />
<br />
&lt;?xml version="1.0" encoding=&#220;TF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns="http://alethea.net/webservices/"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LocalTimeByZipCode&#62;&lt;ZipCode&#62;32306&lt;/ZipCode&#62;&lt;/LocalTimeByZipCode&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
Alternatively, the settings can be automatically set by including gSOAP directives in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service name: localtime <br />
//gsoap ns service encoding: literal <br />
//gsoap ns service namespace: http://alethea.net/webservices/ <br />
int ns__LocalTimeByZipCode(<b>char</b>&nbsp;*ZipCode, <b>char</b>&nbsp;**LocalTimeByZipCodeResult);
</td></tr></table><br></i>
In this case, the method name requires to be associated with a schema through a namespace prefix, e.g. <i>ns</i> is used in this example.
See Section&nbsp;<a href="#sec:directives">12.2</a> for more details on gSOAP directives.
With these directives, the gSOAP compiler generates client and server sources with the specified settings.
The directives are required to produce a WSDL file for a new service that uses doc/literal encoding.

<p>
The example client program can be simplified into:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include "localtime.nsmap" // include generated map file <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ ns__LocalTimeByZipCode(&amp;soap, "http://alethea.net/webservices/LocalTime.asmx", "http://alethea.net/webservices/LocalTimeByZipCode", "32306", &amp;t)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Time = %s<tt>\n</tt>", t); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
</td></tr></table><br></i>

<p>
	      <h4><a name="tth_sEc8.11.1">
8.11.1</a>&nbsp;&nbsp;<font color="#0000FF">Serializing and Deserializing XML Into Strings</font></h4><a name="sec:literal2">
</a>

<p>
To declare a literal XML ``type'' to hold XML documents in regular strings, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*XML;
</td></tr></table><br></i>
To declare a literal XML ``type'' to hold XML documents in wide character strings, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;wchar_t *XML;
</td></tr></table><br></i>
Note: only one of the two storage formats can be used.
The differences between the use of regular strings versus wide character strings for XML documents are:

<ul><p>
<li> Regular strings for XML documents MUST hold UTF-8 encoded XML documents. That is, the string MUST contain the proper UTF-8
encoding to exchange the XML document in SOAP messages.</li>
<p>
<li> Wide character strings for XML documents SHOULD NOT hold UTF-8 encoded XML documents. Instead, the UTF-8 translation is done automatically by
the gSOAP runtime marshalling routines.</li>
</ul>
Literal XML encoding should only use one input parameter and one output parameter.
Here is an example of a remote method specification in which the parameters of the remote method uses literal XML encoding to pass
an XML document to a service and back:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*XML; <br />
ns__GetDocument(XML m__XMLDoc, XML &amp;m__XMLDoc_);
</td></tr></table><br></i>
The <i>ns__Document</i> is essentially a <i><b>struct</b></i> that forms the root of the XML document.
The use of the underscore in the <i>ns__Document</i> response part of the message avoids the name clash between the
<i><b>struct</b></i>s.
Assuming that the namespace mapping table contains the binding of <i>ns</i> to <tt>http://my.org/</tt>
and the binding of <i>m</i> to <tt>http://my.org/mydoc.xsd</tt>, the XML message is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://my.org/" <br />
&nbsp;&nbsp;&nbsp;xmlns:m="http://my.org/mydoc.xsd" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle=""&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ns:GetDocument&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;XMLDoc xmlns="http://my.org/mydoc.xsd"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/XMLDoc&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ns:Document&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
Important: the literal XML encoding style MUST be specified by setting <i>soap.encodingStyle</i>, where <i>soap</i> is a variable
that contains the current runtime environment.
For example, to specify no constraints on the encoding style (which is typical) use NULL:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.encodingStyle = NULL;
</td></tr></table><br></i>
As a result, the <tt>SOAP-ENV:encodingStyle</tt> attribute will not appear in the SOAP payload.

<p>
For interoperability with Apache SOAP, use
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.encodingStyle = "http://xml.apache.org/xml-soap/literalxml";
</td></tr></table><br></i>
The name of the response element can be changed (default is the remote method name ending with <i>Response</i>).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*XML; <br />
ns__GetDocument(<b>struct</b>&nbsp;soap *soap, XML m__XMLDoc, <b>struct</b>&nbsp;ns__Document { XML m__XMLDoc; } &amp;result);
</td></tr></table><br></i>

<p>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;<font color="#0000FF">SOAP Fault Processing</font></h2><a name="sec:fault">
</a>

<p>
A predeclared standard SOAP Fault data structure is generated by the gSOAP stub and skeleton compiler for exchanging exception messages.
This predeclared data structure is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Fault <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultcode; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultstring; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultactor; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*detail; <br />
};
</td></tr></table><br></i>
The data structure can be changed to the need of an application.  To do this, include a new declaration of a
<i><b>struct</b>&nbsp;SOAP_ENV__Fault</i> in the header file input to the gSOAP compiler to replace the built-in data structure.
A <i><b>class</b></i> for the SOAP Fault data structure is not allowed in gSOAP 2.0.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Fault <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultcode; // MUST be string <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultstring; // MUST be string <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultactor; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*detail; // MUST be string<br />
&nbsp;&nbsp;&nbsp;Detail *t__detail; // new detail field (note namespace prefix "t") <br />
};
</td></tr></table><br></i>
where <i>DetailType</i> is some data type that holds application specific data such as a stack dump.

<p>
When the proxy of a remote method returns an error (see Section&nbsp;<a href="#sec:errcodes">7.2</a>), thne <i>soap.fault</i> contains the SOAP
Fault data.

<p>
When a remote method wants to raise an exception, it does so by assigning the <i>fault</i> field of the current reference to the
runtime environment with 
appropriate data associated with the exception and by returning the error <i>SOAP_FAULT</i>.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
&nbsp;&nbsp;&nbsp;soap_fault(soap); // allocate fault struct if necessary <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>faultstring = "Stack dump"; <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>detail = NULL; <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>t__detail = sp; // point to stack (needs stack serializer) <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_Fault; // return from remote method call
</td></tr></table><br></i>
When <i>soap_fault</i> allocates a fault struct, this data can be removed with the <i>soap_end</i> call (or <i>soap_dealloc</i>).

<p>
Each remote method implementation in a service application can return a SOAP Fault upon an exception by returning an error code,
see Section&nbsp;<a href="#sec:example7">5.2.1</a> for details and an example.
In addition, a SOAP Fault can be returned by a service application through calling the <i>soap_send_fault</i> function.
This is useful in case the initialization of the application fails, as illustrated in the example below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;some initialization code <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(initialization failed) <br />
&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.error = SOAP_FAULT; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_fault(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.fault<tt>-&gt;</tt>faultcode = "Server"; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.fault<tt>-&gt;</tt>faultstring = &#207;nit failed"; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.fault<tt>-&gt;</tt>details = "..."; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_send_fault(&amp;soap); // Send SOAP Fault to client <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; // Terminate <br />
&nbsp;&nbsp;&nbsp;} <br />
}
</td></tr></table><br></i>

<p>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;<font color="#0000FF">SOAP Header Processing</font></h2><a name="sec:header">
</a>

<p>
A predeclared standard SOAP Header data structure is generated by the gSOAP stub and skeleton compiler for exchanging SOAP
messages with SOAP Headers.
This predeclared data structure is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <b>void</b>&nbsp;*dummy; <br />
};
</td></tr></table><br></i>
which declares and empty header (some C and C++ compilers don't accept empty structs so a transient dummy field is provided).

<p>
To adapt the data structure to a specific need for SOAP Header processing, a
new <i><b>struct</b>&nbsp;SOAP_ENV__Header</i> can be added to the header file input to the gSOAP
compiler.  A <i><b>class</b></i> for the SOAP Header data structure can be used instead of a <i><b>struct</b></i>.

<p>
For example, the following header can be used for transaction control:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <b>char</b>&nbsp;*t__transaction; <br />
};
</td></tr></table><br></i>
with client-side code:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
... <br />
soap.header = NULL; // do not use a SOAP Header for the request (as set with soap_init) <br />
soap.actor = NULL; // do not use an actor (receiver is actor) <br />
soap_call_method(&amp;soap, ...); <br />
<b>if</b>&nbsp;(soap.header) // a SOAP Header was received <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  soap.header<tt>-&gt;</tt>t__transaction; <br />
// Can reset, modify, or set soap.header here before next call <br />
soap_call_method(&amp;soap, ...); // reuse the SOAP Header of the service response for the request <br />
...
</td></tr></table><br></i>
The SOAP Web service response can include a SOAP Header with a transaction number that the client is supposed to use for the next remote method invocation to the service. Therefore, the next request includes a transaction number:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope ...&#62; <br />
&lt;SOAP-ENV:Header&#62; <br />
&lt;t:transaction xsi:type="int"&#62;12345&lt;/t:transaction&#62; <br />
&lt;/SOAP-ENV:Header&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
... <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
This is just an example and the transaction control is not a feature of SOAP but can be added on by the application layer
to implement stateful transactions between clients and services.
At the client side, the <i>soap.actor</i> attribute can be set to
indicate the recipient of the header (the SOAP <tt>SOAP-ENV:actor</tt> attribute).

<p>
A Web service can read and set the SOAP Header as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap.actor = NULL; // use this to accept all headers (default) <br />
&nbsp;&nbsp;&nbsp;soap.actor = "http://some/actor"; // accept headers destined for "http://some/actor" only <br />
&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap);<br />
} <br />
... <br />
<b>int</b>&nbsp;method(<b>struct</b>&nbsp;soap *soap, ...) <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap<tt>-&gt;</tt>header) // a Header was received <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... = soap<tt>-&gt;</tt>header<tt>-&gt;</tt>t__transaction; <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>header = soap_malloc(sizeof(<b>struct</b>&nbsp;SOAP_ENV__Header)); // alloc new header <br />
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>header<tt>-&gt;</tt>t__transaction = ...; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>
See Section&nbsp;<a href="#sec:directives">12.2</a> on how to generate WSDL with the proper method-to-header-part bindings.

<p>
The <tt>SOAP-ENV:mustUnderstand</tt> attribute indicates the requirement that the recipient of the SOAP Header (who must
correspond to the <tt>SOAP-ENV:actor</tt> attribute when present or when
<tt>SOAP-ENV:actor="http://schemas.xmlsoap.org/soap/actor/next"</tt>) MUST handle the Header part that carries the attribute.
gSOAP handles this automatically on the background. However, an application still needs to inspect the header part's value
and handle it appropriately. If a remote method in a Web service is not able to do this, it should return
<i>SOAP_MUSTUNDERSTAND</i> to indicate this failure.

<p>
The syntax for the header file input to the gSOAP compiler is extended with a special storage qualifier <i>mustUnderstand</i>.
This qualifier can be used in the SOAP Header declaration to indicate which parts should carry a <i>SOAP-ENV:mustUnderstand="1"</i>
attrbute. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t__transaction; <br />
&nbsp;&nbsp;&nbsp;mustUnderstand <b>char</b>&nbsp;*t__authentication; <br />
};
</td></tr></table><br></i>
When both fields are set and <i>soap.actor="http://some/actor"</i> then the message contains:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;SOAP-ENV:Envelope ...&#62; <br />
&lt;SOAP-ENV:Header&#62; <br />
&lt;t:transaction&#62;5&lt;/t:transaction&#62; <br />
&lt;t:authentication SOAP-ENV:actor="http://some/actor" SOAP-ENV:mustUnderstand="1"&#62;XX&lt;/t:authentication&#62; <br />
&lt;/SOAP-ENV:Header&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
... <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>

<p>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;<font color="#0000FF">DIME Attachment Processing</font></h2><a name="sec:DIME">
</a>

<p>
gSOAP can transmit binary data with DIME attachments. The binary data is stored in augmented <tt>xsd:base64Binary</tt> and
<tt>xsd:hexBinary</tt> structs/classes. These structs/classes have three additional fields: an <i>id</i> field for attachment
referencing (typically a CID or UUID), a <i>type</i> field to specify the MIME type of the binary data, and an <i>options</i> field to piggy-back additional
information with a DIME attachment. DIME attachment support is fully automatic, which means that gSOAP will test for the presence
of attachments at run time and use SOAP in DIME accordingly.

<p>
A <tt>xsd:base64Binary</tt> type with DIME attachment support is declared by
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*id; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*type; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*options; <br />
};
</td></tr></table><br></i>
The specification order of the fields is important. In addition, no other fields or methods may be declared before any of these
fields in the struct/class.
A <i>xsd:hexBinary</i> declaration is similar. If the <i>id</i> field and/or <i>type</i> field is non-NULL during serialization of
the data, DIME attachment transmission is used for the <em>entire</em> SOAP message, as per SOAP in DIME specifications.
If only the <i>type</i> field is set, gSOAP will assign a default DIME id to the attachment (see also below).
The <i>options</i> field is an optional string with a special layout: the first two bytes are reserved for the option type, the next two
bytes store the size of the option data, followed by the option data. The function
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>char</b>&nbsp;*soap_option(<b>struct</b>&nbsp;soap *soap, <b>unsigned</b>&nbsp;<b>short</b>&nbsp;type, <b>const</b>&nbsp;<b>char</b>&nbsp;*option)
</td></tr></table><br></i>
returns a string with this encoding. For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary image; <br />
image.__ptr = ...; <br />
image.__size = ...; <br />
image.id = "uuid:09233523-345b-4351-b623-5dsf35sgs5d6"; <br />
image.type = "image/jpeg"; <br />
image.options = soap_option(soap, 0, "My wedding picture");
</td></tr></table><br></i>
When receiving DIME attachments, the fields will be set according to the DIME attachment data. If binary data is received without
attachments, the <i>id</i>, <i>type</i>, <i>options</i> fields are NULL. Note that SOAP messages may contain binary data that
references external resources not provided as attachments. In that case, the <i>__ptr</i> field is NULL and the <i>id</i> field
refers to the external data source. Non-augmented binary data types <tt>xsd:base64Binary</tt> and <tt>xsd:hexBinary</tt> can be used to receive DIME attachments, but the <i>id</i>,
<i>type</i>, and <i>options</i> information cannot be processed due to the absence of these fields. Also strings can be received as
DIME attachments, but not send.

<p>
If necessary, the <tt>xsd:base64Binary</tt> schema type and its attachment-based type can be separated with class inheritance. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
}; <br />
<b>class</b>&nbsp;xsd__base64Binary_ : xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*id; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*type; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*options; <br />
};
</td></tr></table><br></i>
The <i>dime_id_format</i> attribute of the current gSOAP run-time environment can be set to the default format of DIME id fields.
The format string MUST contain a <i>%d</i> format specifier (or any other <i><b>int</b></i>-based format specifier). The value of this specifier is a non-negative integer, with zero
being the value of the DIME attachment id for the SOAP message.
For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap;<br />
soap_init(&amp;soap); <br />
soap.dime_id_format = "uuid:09233523-345b-4351-b623-5dsf35sgs5d6-%x"; <br />
</td></tr></table><br></i>
As a result, all attachments with a NULL <i>id</i> field will use a gSOAP-generated id value based on the format string.

<p>
<font color="#FF0000"><b>Caution</b></font>: Do not set the <i>disable_request_count</i> or <i>disable_response_count</i> attributes of the gSOAP run-time
with DIME.

<p>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;<font color="#0000FF">Advanced Features</font></h2><a name="sec:advanced">
</a>

<p>
		     <h3><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;<font color="#0000FF">Internationalization</font></h3>

<p>
The use of wide-character strings (<i>wchar_t*</i>) in C and C++ clients and services suffices for internationalization.
In contrast, when strings with wide characters are received and stored in regular strings, only the lower 8 bits of the wide characters are retained.
The <i>enable_utf_string</i> attribute of the current gSOAP environment can be set
to enable send and receive of wide-characters with regular strings.
With this attrbute set, text will be stored in UTF8 format in the strings directly, which means that character codes 1 to 127 are treated as plain ASCII.
Codes with the MSB set are UTF8-encoded characters. Please consult the UTF8 specification for details.

<p>
		     <h3><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;<font color="#0000FF">Customizing the WSDL and Namespace Mapping Table File Contents</font></h3><a name="sec:directives">
</a>

<p>
A header file can be augmented with directives for the gSOAP Stub and Skeleton compiler to automatically generate customized WSDL and namespace mapping tables contents. The WSDL and namespace mapping table files do not need to be modified by hand (Sections&nbsp;<a href="#sec:wsdl">5.2.5</a> and&nbsp;<a href="#sec:nstable">7.4</a>).
These compiler directive are specified as <i>//</i>-comments.

<p>
Three directives are currently supported that can be used to specify details associated with namespace prefixes used by the remote
method names in the header file.
To specify the name of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service name: <i>service-name</i>
</td></tr></table><br></i>
where <i>namespace-prefix</i> is a namespace prefix used by identifiers in the header file and <i>service-name</i> is the name
of a Web Service (only required to create new Web Services).

<p>
To specify the location of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service location: <i>URL</i>
</td></tr></table><br></i>
where <i>URL</i> is the location of the Web Service (only required to create new Web Services).
The <i>URL</i> specifies the path to the service executable (so <i><i>URL</i>/<i>service-executable</i></i>
is the actual locations of the executable).

<p>
To specify the name of the executable of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service executable: <i>executable-name</i>
</td></tr></table><br></i>
where <i>executable-name</i> is the name of the executable of the Web Service.

<p>
To specify the namespace URI of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service namespace: <i>namespace-URI</i>
</td></tr></table><br></i>
where <i>namespace-URI</i> is the URI associated with the namespace prefix.

<p>
In addition, the schema namespace URI can be specified in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> schema namespace: <i>namespace-URI</i>
</td></tr></table><br></i>
where <i>namespace-URI</i> is the schema URI associated with the namespace prefix.
If present, it affects the schema-part of the generated WSDL file and the URI in the namespace mapping table.
This declaration is useful when the service declares it's own data types that need to be associated with a namespace.
Furthermore, the header file for client applications do not need the full service details and the specification of the schema
namespaces for namespace prefixes suffices.

<p>
When header processing is required, each method declared in the WSDL should provide a binding to the parts of the header that may
appear as part of a method request message. Such a binding is given by:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-header-part: <i>method-name</i> <i>header-part</i>
</td></tr></table><br></i>
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*h__transaction; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;UserAuth *h__authentication; <br />
};
</td></tr></table><br></i>
Suppose method <i>ns__login</i> uses both header parts (at most), then this is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service method-header-part: login transaction <br />
//gsoap ns service method-header-part: login authentication <br />
<b>int</b>&nbsp;ns__login(...);
</td></tr></table><br></i>
Suppose method <i>ns__search</i> uses only the first header part (at most), then this is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service method-header-part: search transaction <br />
int ns__search(...);
</td></tr></table><br></i>
Note that the method name and header part names in the directive are left unqualified.

<p>
To specify the header parts for the method input (method request message), use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-input-header-part: <i>method-name</i> <i>header-part</i>
</td></tr></table><br></i>
Similarly, to specify the header parts for the method output (method response message), use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-output-header-part: <i>method-name</i> <i>header-part</i>
</td></tr></table><br></i>
The declarations above only affect the WSDL. It's the application's responsibility to set and reset the header messages.

<p>
When doc/literal encoding is required, the service encoding can be specified in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service encoding: literal
</td></tr></table><br></i>
or when the <tt>SOAP-ENV:encodingStyle</tt> attribute is different from the SOAP 1.1 encoding style:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service encoding: <i>encoding-style</i>
</td></tr></table><br></i>

<p>
(Note: blanks can be used anywhere in the directive, except between <i>//</i> and <i>gsoap</i>.)

<p>
The use of these directive is best illustrated with an example.
The <i>quotex.h</i> header file of the <i>quotex</i> example in the gSOAP distribution for Unix/Linux is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns1 service namespace:	urn:xmethods-delayed-quotes <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result); <br />
 <br />
//gsoap ns2 service namespace:	urn:xmethods-CurrencyExchange <br />
<b>int</b>&nbsp;ns2__getRate(<b>char</b>&nbsp;*country1, <b>char</b>&nbsp;*country2, <b>float</b>&nbsp;&amp;result); <br />
 <br />
//gsoap ns3 service name:	quotex <br />
//gsoap ns3 service location:	http://www.cs.fsu.edu/~engelen <br />
//gsoap ns3 service namespace:	urn:quotex <br />
<b>int</b>&nbsp;ns3__getQuote(<b>char</b>&nbsp;*symbol, <b>char</b>&nbsp;*country, <b>float</b>&nbsp;&amp;result);
</td></tr></table><br></i>
The <i>quotex</i> example is a new Web Service created by combining two existing Web Services:
the XMethods Delayed Stock Quote service and XMethods Currency Exchange service.

<p>
Namespace prefix <i>ns3</i> is used for the new <i>quotex</i> Web Service with namespace URI <i>urn:quotex</i>,
service name <i>quotex</i>, and location <i>http://www.cs.fsu.edu/~engelen</i>.
Since the new Web Service invokes the <i>ns1__getQuote</i> and <i>ns2__getRate</i> remote methods,
the service namespaces of these methods are given.
The service names and locations of these methods are not given because they
are only required for setting up a new Web Service for these methods
(but may also be provided in the header file for documentation purposes).
After invoking the gSOAP Stub and Skeleton compiler on the <i>quotex.h</i> header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 quotex.h</i>
</td></tr></table><br></span>
the WSDL of the new <i>quotex</i> Web Service is saved as <i>quotex.wsdl</i>.
Since the service name (<i>quotex</i>), location (<i>http://www.cs.fsu.edu/~engelen</i>), and namespace URI
(<i>urn:quotex</i>) were provided in the header file, the generated WSDL file does not need to be changed by hand and can be published
immediately together with the compiled Web Service installed as a CGI application at the designated URL
(<i>http://www.cs.fsu.edu/~engelen/quotex.cgi</i>
and <i>http://www.cs.fsu.edu/~engelen/quotex.wsdl</i>).

<p>
The namespace mapping table for the <i>quotex.cpp</i> Web Service implementation is saved as <i>quotex.nsmap</i>.
This file can be directly included in <i>quotex.cpp</i> instead of specified by hand in the source of <i>quotex.cpp</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "quotex.nsmap"
</td></tr></table><br></i>
The automatic generation and inclusion of the namespace mapping table requires compiler directives 
for <b>all</b> namespace prefixes to associate each namespace prefix with a namespace URI. Otherwise, namespace URIs have to be
manually added to the table (they appear as <i>%{URI}%</i>).

<p>
		     <h3><a name="tth_sEc12.3">
12.3</a>&nbsp;&nbsp;<font color="#0000FF">Transient Data Types</font></h3>

<p>
There are situations when certain data types have to be ignored by gSOAP for the compilation of (de)marshalling routines.
For example, in certain cases the fields in a class or struct need not be (de)serialized, or the base class of a derived class should not be
(de)serialized, and certain built-in classes such as <i>ostream</i> cannot be (de)serialized.
These data types (including fields) are called ``transient'' and can be declared outside of gSOAP's compilation window.
Transient data type and transient fields are declared with the <i><b>extern</b></i> keyword or are declared within <i>[</i> and <i>]</i> blocks in the header file
input to the gSOAP compiler.
The <i><b>extern</b></i> keyword has a special meaning to the gSOAP compiler and won't affect the generated codes.
The special <i>[</i> and <i>]</i> block construct can be used with data type declarations and within <i><b>struct</b></i> and
<i><b>class</b></i> declarations. The use of <i><b>extern</b></i> or <i>[ ]</i> achieve the same effect, but <i>[ ]</i> may be more convenient
to encapsulate transient types in a larger part of the header file. The use of <i><b>extern</b></i> with <i><b>typedef</b></i> is reserved for
the declaration of user-defined external (de)serializers for data types, see Section&nbsp;<a href="#sec:extern">12.4</a>.

<p>
First example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>extern</b>&nbsp;<b>class</b>&nbsp;ostream; // ostream can't be (de)serialized, but need to be declared to make it visible to gSOAP <br />
<b>class</b>&nbsp;ns__myClass <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(ostream &amp;s) <b>const</b>; // need ostream here <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
Second example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
[ <br />
&nbsp;&nbsp;&nbsp;<b>class</b>&nbsp;myBase // base class need not be (de)serialized <br />
&nbsp;&nbsp;&nbsp;{ ... }; <br />
] <br />
<b>class</b>&nbsp;ns__myDerived : myBase <br />
{ ... }; <br />
</td></tr></table><br></i>
Third example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
[ <b>typedef</b>&nbsp;<b>int</b>&nbsp;transientInt; ] <br />
<b>class</b>&nbsp;ns__myClass <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;a; // will be (de)serialized <br />
&nbsp;&nbsp;&nbsp;[ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;b; // transient field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;s[256]; // transient field <br />
&nbsp;&nbsp;&nbsp;]  <br />
&nbsp;&nbsp;&nbsp;<b>extern</b>&nbsp;<b>float</b>&nbsp;d; // transient field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; // will be (de)serialized <br />
&nbsp;&nbsp;&nbsp;transientInt *n; // transient field <br />
&nbsp;&nbsp;&nbsp;[ <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;method(<b>char</b>&nbsp;buf[1024]); // does not create a <b>char</b>[1024] (de)serializer <br />
&nbsp;&nbsp;&nbsp;]  <br />
};
</td></tr></table><br></i>
In this example, <i><b>class</b>&nbsp;ns__myClass</i> has three transient fields: <i>b</i>, <i>s</i>, and <i>n</i> which will not be (de)serialized in
SOAP. Field <i>n</i> is transient because the type is declared within a transient block. Pointers, references, and arrays of
transient types are transient.
The single class method is encapsulated within <i>[</i> and <i>]</i> to prevent gSOAP from creating (de)serializers for the
<i><b>char</b>[1024]</i> type. gSOAP will generate (de)serializers for all types that are not declared within a <i>[</i> and <i>]</i>
transient block.

<p>
Functions prototypes of remote methods cannot be declared transient and will result in errors when attempted.

<p>
		     <h3><a name="tth_sEc12.4">
12.4</a>&nbsp;&nbsp;<font color="#0000FF">How to Declare User-Defined Serializers and Deserializers</font></h3><a name="sec:extern">
</a>

<p>
Users can declare their own (de)serializers for specific data types instead of relying on the gSOAP-generated (de)serializers.
To declare a external (de)serializer, declare a type with <i><b>extern</b>&nbsp;<b>typedef</b></i>. gSOAP will not generate the (de)serialzers
for the type name that is declared. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>extern</b>&nbsp;<b>typedef</b>&nbsp;<b>char</b>&nbsp;*MyData; <br />
<b>struct</b>&nbsp;Sample <br />
{ <br />
&nbsp;&nbsp;&nbsp;MyData s; // use user-defined (de)serializer for this field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; // use gSOAP (de)serializer for this field <br />
};
</td></tr></table><br></i>
The user is required to supply the following routines for each <i><b>extern</b>&nbsp;<b>typedef</b></i>'ed name <u>T</u>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;soap_mark_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<u><span class="roman">T</span></u> *a) <br />
<b>void</b>&nbsp;soap_default_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <u><span class="roman">T</span></u> *a) <br />
<b>void</b>&nbsp;soap_out_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, <b>int</b>&nbsp;id, <b>const</b>&nbsp;<u><span class="roman">T</span></u> *a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) <br />
<u><span class="roman">T</span></u> *soap_in_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, <u><span class="roman">T</span></u> *a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) 
</td></tr></table><br></i>
The function prototypes can be found in <i>soapH.h</i>.

<p>
For example, the (de)serialization of <i>MyData</i> can be done with the following code:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;soap_mark_MyData(<b>struct</b>&nbsp;soap *soap, MyData *<b>const</b>*a) <br />
{ } // no need to mark this node (for multi-ref and cycle detection) <br />
<b>void</b>&nbsp;soap_default_MyData(&amp;soap, MyData **a) <br />
{ *a = NULL } <br />
<b>void</b>&nbsp;soap_out_MyData(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, <b>int</b>&nbsp;id, MyData *<b>const</b>*a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_element_begin_out(soap, tag, id, type); // print XML beginning tag <br />
&nbsp;&nbsp;&nbsp;soap_send(soap, *a); // just print the string (no XML conversion) <br />
&nbsp;&nbsp;&nbsp;soap_element_end_out(soap, tag); // print XML ending tag <br />
} <br />
MyData **soap_in_MyData(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, MyData **a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_element_begin_in(soap, tag)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!a) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = (MyData**)soap_malloc(soap, sizeof(MyData*)); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap<tt>-&gt;</tt>null) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a = NULL; // xsi:nil element <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(*soap<tt>-&gt;</tt>type &amp;&amp; soap_match_tag(soap, soap<tt>-&gt;</tt>type, type)) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>error = SOAP_TYPE_MISMATCH; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; // type mismatch <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(*soap<tt>-&gt;</tt>href) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = (MyData**)soap_id_forward(soap, soap-&#62;href, a, SOAP_MyData, sizeof(MyData*)) <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<b>if</b>&nbsp;(soap<tt>-&gt;</tt>body) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*s = soap_value(soap); // fill buffer <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a = (<b>char</b>*)soap_malloc(soap, strlen(s)+1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(*a, s); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap-&#62;body &amp;&amp; soap_element_end_in(soap, tag)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;a;
</td></tr></table><br></i>
More information on custom (de)serialization will be provided in this document or in a separate document in the future.
The writing of the (de)serializer code requires the use of the low-level gSOAP API.

<p>
		     <h3><a name="tth_sEc12.5">
12.5</a>&nbsp;&nbsp;<font color="#0000FF">How to Serialize Data Without XML <tt>xsi:type</tt> Attributes</font></h3>

<p>
gSOAP serializes data in XML with <tt>xsi:type</tt> attributes when the types are declared with namespace prefixes to indicate the type of the data contained in the
elements. SOAP 1.1 and 1.2 requires <tt>xsi:type</tt> attributes in the presence of polymorphic data or when the type of the data cannot be
deduced from the SOAP payload.

<p>
To omit the generation of <tt>xsi:type</tt> attributes in the serialization, simply use type declarations that do not include
namespace prefixes. The only remaining issue is the (de)serialization of lists/vectors with typed elements.
To declare a list/vector with typed elements, use a leading underscores for type names of
the <i><b>struct</b></i> or <i><b>class</b></i>. The leading underscores in type names makes type anonymous (invisible in XML).

<p>
		     <h3><a name="tth_sEc12.6">
12.6</a>&nbsp;&nbsp;<font color="#0000FF">Function Callbacks for Customized I/O and HTTP Handling</font></h3><a name="sec:callback">
</a>

<p>
gSOAP provides five callback functions for customized I/O and HTTP handling:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Callback (function pointer)</b></font> </td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap.fopen)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>int</b>&nbsp;port)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called from a client proxy to open a connection to a Web Service located at <i>endpoint</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input parameters <i>host</i> and <i>port</i> are micro-parsed from <i>endpoint</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return a valid file descriptor, or -1 and soap<tt>-&gt;</tt>error set to an error code </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>tcp_connect</i> </td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap.fpost)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>const</b>&nbsp;<b>char</b>&nbsp;*path, <b>const</b>&nbsp;<b>char</b>&nbsp;*action, size_t
count)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called from a client proxy to generate the HTTP header to connect to <i>endpoint</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input parameters <i>host</i> and <i>path</i> are micro-parsed from <i>endpoint</i>, <i>action</i> is the SOAP action, </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and <i>count</i> is the length of the SOAP message or 0 when <i>soap.disable_request_count</i> <font face="symbol"></font
> 0 </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use function <i>soap_send(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s)</i> to write the header contents </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return SOAP_OK, or a gSOAP error code </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>http_post</i> </td></tr>
<tr><td></td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap.fresponse)(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;soap_error_code, size_t count)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called from a service to generate the response HTTP header </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input parameter <i>soap_error_code</i> is a gSOAP error code (see Section&nbsp;<a href="#sec:errcodes">7.2</a> and </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>count</i> is the length of the SOAP message or 0 when <i>soap.disable_response_count</i> <font face="symbol"></font
> 0 </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use function <i>soap_send(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s)</i> to write the header contents </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return SOAP_OK, or a gSOAP error code </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>http_response</i> </td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap.fparse)(<b>struct</b>&nbsp;soap *soap)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called by client proxy and service to parse an HTTP header (if present) </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When user-defined, this routine must at least skip the header </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use function <i><b>int</b>&nbsp;soap_getline(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*buf, <b>int</b>&nbsp;len)</i> to read HTTP header lines into </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a buffer <i>buf</i> of length <i>len</i> (returns empty line at end of HTTP header) </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return SOAP_OK, or a gSOAP error code </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>http_parse</i> </td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap.fclose)(<b>struct</b>&nbsp;soap *soap)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called by client proxy <b>multiple times</b>, to close a socket connection before a new socket </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection is established and at the end of communications when <i>soap.keep_alive</i> <font face="symbol"></font
> 0 </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return SOAP_OK, or a gSOAP error code </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>tcp_disconnect</i> </td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap.fsend)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*s, size_t n)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called for all send operations to emit contents of <i>s</i> of length <i>n</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return SOAP_OK, or a gSOAP error code </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>fsend</i> </td></tr>
<tr><td><i>size_t (*soap.frecv)(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s, size_t n)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called for all receive operations to fill buffer <i>s</i> of maximum length <i>n</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return the number of bytes read or 0 in case of an error, e.g.&nbsp;EOF </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>frecv</i> </td></tr>
<tr><td><i><b>int</b>&nbsp;(*soap_fignore)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag)</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Called when an unknown XML element was encountered on the input and <i>tag</i> is the offending XML element tag name. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Should return SOAP_OK, or a gSOAP error code such as SOAP_MUSTUNDERSTAND to throw an exception </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Built-in gSOAP function: <i>fignore</i> </td></tr></table>

</td></tr></table><br></span>
In addition, a <i><b>void</b>*user</i> field in the <i><b>struct</b>&nbsp;soap</i> data structure has been reserved that can serve to point to user-defined data that needs
to be carried along the callbacks.

<p>
The following example uses I/O function callbacks for customized serialization of data into a buffer and deserialization back into a
datastructure:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>char</b>&nbsp;buf[10000]; // XML buffer <br />
<b>int</b>&nbsp;len1 = 0;	// #chars written <br />
<b>int</b>&nbsp;len2 = 0;	// #chars read <br />
// mysend: put XML in buf[] <br />
<b>int</b>&nbsp;mysend(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*s, size_t n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(len1 + n  &gt;  sizeof(buf)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;strcpy(buf + len1, s); <br />
&nbsp;&nbsp;&nbsp;len1 += n; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
// myrecv: get XML from buf[] <br />
size_t myrecv(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s, size_t n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(len2 + n  &gt;  len1) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = len1 - len2; <br />
&nbsp;&nbsp;&nbsp;strncpy(s, buf + len2, n); <br />
&nbsp;&nbsp;&nbsp;len2 += n; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;n; <br />
} <br />
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__person p; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;len1 = len2 = 0;	// reset buffer pointers <br />
&nbsp;&nbsp;&nbsp;p.name = "John Doe"; <br />
&nbsp;&nbsp;&nbsp;p.age = 25; <br />
&nbsp;&nbsp;&nbsp;soap.fsend = mysend; // assign callback <br />
&nbsp;&nbsp;&nbsp;soap.frecv = myrecv; // assign callback <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.enable_embedding = 1; <br />
&nbsp;&nbsp;&nbsp;soap_serialize_ns__person(&amp;soap, &amp;p); <br />
&nbsp;&nbsp;&nbsp;soap_put_ns__person(&amp;soap, &amp;p, "ns:person", NULL); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.error) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stdout); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_get_ns__person(&amp;soap, &amp;p, "ns:person", NULL); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.error) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stdout); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // disable callbacks <br />
}
</td></tr></table><br></i>
The <i>soap_done</i> function can be called to reset the callback to the default internal gSOAP I/O and HTTP handlers.

<p>
The following example illustrates customized I/O and (HTTP) header handling. The SOAP request is saved to a file. The client proxy
then reads the file contents as the service response. To perform this trick, the service response has exactly the same structure as the
request. This is declared by the <i><b>struct</b>&nbsp;ns__test</i> output parameter part of the remote method declaration.
This struct resembles the service request (see the generated <i>soapStub.h</i> file created from the header file).

<p>
The header file is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service name: callback <br />
//gsoap ns service namespace: urn:callback <br />
<b>struct</b>&nbsp;ns__person <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;age; <br />
}; <br />
<b>int</b>&nbsp;ns__test(<b>struct</b>&nbsp;ns__person in, <b>struct</b>&nbsp;ns__test &amp;out);
</td></tr></table><br></i>
The client program is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
... <br />
<b>int</b>&nbsp;myopen(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>int</b>&nbsp;port) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(strncmp(endpoint, "file:", 5)) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("File name expected<tt>\</tt>n"); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;((soap<tt>-&gt;</tt>sendfd = soap<tt>-&gt;</tt>recvfd = open(host, O_RDWR, S_IWUSR|S_IRUSR)) &lt; 0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
<b>void</b>&nbsp;myclose(<b>struct</b>&nbsp;soap *soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;if (soap<tt>-&gt;</tt>sendfd &#62; 2) // still open? <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(soap<tt>-&gt;</tt>sendfd); // then close it <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>recvfd = 0; // set back to stdin <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>sendfd = 1; // set back to stdout <br />
} <br />
<b>int</b>&nbsp;mypost(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>const</b>&nbsp;<b>char</b>&nbsp;*path, <b>const</b>&nbsp;<b>char</b>&nbsp;*action, size_t count) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;soap_send(soap, "Custom-generated file<tt>\</tt>n"); // writes to soap<tt>-&gt;</tt>sendfd <br />
} <br />
<b>int</b>&nbsp;myparse(<b>struct</b>&nbsp;soap *soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;buf[256]; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(lseek(soap<tt>-&gt;</tt>recvfd, 0, SEEK_SET) &lt; 0 || soap_getline(soap, buf, 256)) // go to begin and skip custom header <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__test r; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__person p; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // reset <br />
&nbsp;&nbsp;&nbsp;p.name = "John Doe"; <br />
&nbsp;&nbsp;&nbsp;p.age = 99; <br />
&nbsp;&nbsp;&nbsp;soap.fopen = myopen; // use custom open <br />
&nbsp;&nbsp;&nbsp;soap.fpost = mypost; // use custom post <br />
&nbsp;&nbsp;&nbsp;soap.fparse = myparse; // use custom response parser <br />
&nbsp;&nbsp;&nbsp;soap.fclose = myclose; // use custom close <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__test(&amp;soap, "file://test.xml", "", p, r); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.error) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stdout); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // reset to default callbacks <br />
}
</td></tr></table><br></i>
SOAP 1.1 and 1.2 specify that XML elements may be ignored when present in a SOAP payload on the receiving side.
gSOAP ignores XML elements that are unknown, unless the XML attribute <tt>mustUnderstand="true"</tt> is present in the XML element.
It may be undesirable for elements to be ignored when the outcome of the omission is uncertain.
The <i>soap.fignore</i> callback can be set to a function that returns <i>SOAP_OK</i> in case the element can be safely ignored, or
<i>SOAP_MUSTUNDERSTAND</i> to throw an exception, or to perform some application-specific action.
For example, to throw an exception as soon as an unknown element is encountered on the input, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;myignore(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_MUSTUNDERSTAND; // never skip elements (secure) <br />
} <br />
... <br />
soap.fignore = myignore; <br />
soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap);
</td></tr></table><br></i>
To selectively throw an exception as soon as an unknown element is encountered but element <tt>ns:xyz</tt> can be safely ignored, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;myignore(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_match_tag(soap, tag, "ns:xyz") != SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_MUSTUNDERSTAND; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
... <br />
soap.fignore = myignore; <br />
soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap) <br />
... <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "some-URI"}, // the namespace of element ns:xyz <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
</td></tr></table><br></i>
Function <i>soap_match_tag</i> compares two tags. The third parameter may be a pattern where <i>*</i> is a wildcard
and <i>-</i> is a single character wildcard. So for example
<i>soap_match_tag(tag, "ns:*")</i> will match any element in namespace <i>ns</i> or when no namespace prefix is present in the XML
message.

<p>
The callback can also be used to keep track of unknown elements in an internal data structure such as a list:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Unknown <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*tag; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;Unknown *next; <br />
}; <br />
<b>int</b>&nbsp;myignore(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*s = (<b>char</b>*)soap_malloc(soap, strlen(tag)+1); <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;Unknown *u = (<b>struct</b>&nbsp;Unknown*)soap_malloc(soap, sizeof(<b>struct</b>&nbsp;Unknown)); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s &amp;&amp; u) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(s, tag); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u-&#62;tag = s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u-&#62;next = ulist; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulist = u; <br />
&nbsp;&nbsp;&nbsp;} <br />
} <br />
... <br />
<b>struct</b>&nbsp;soap *soap; <br />
<b>struct</b>&nbsp;Unknown *ulist = NULL; <br />
soap_init(&amp;soap); <br />
soap.fignore = myignore; <br />
soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap) <br />
// print the list of unknown elements <br />
soap_end(&amp;soap); // clean up
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc12.7">
12.7</a>&nbsp;&nbsp;<font color="#0000FF">HTTP 1.0 and 1.1</font></h3>

<p>
gSOAP uses HTTP 1.0 by default. gSOAP supports HTTP 1.1, but does not support all HTTP 1.1 transfer encodings such as gzipped
encodings. gSOAP does support HTTP 1.1 chunked-transfer encoding. Nevertheless, the the HTTP version used can be changed by
setting the attribute:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
... <br />
soap.http_version = "1.1";
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc12.8">
12.8</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Keep-Alive</font></h3>

<p>
gSOAP supports keep-alive socket connections. To activate keep-alive support, set the <i>keep_alive</i> attribute:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
... <br />
soap.keep_alive = 1;
</td></tr></table><br></i>
When a client proxy communicates with a service that closes the connection, <i>soap.keep_alive</i> will be reset to 0 afterwards.

<p>
Keep-alive support can be activated for stand-alone services:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap.keep_alive = 1; <br />
&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;while (soap_serve(&amp;soap) == SOAP_OK &amp;&amp; soap.keep_alive) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...; <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
The connection will be kept open on the server-side only if the request contains an HTTP 1.0 header with "<tt>Connection: Keep-Alive</tt>" or an HTTP 1.1
header that does not contain "<tt>Connection: close</tt>". This means that a gSOAP client method call should use "<tt>http://</tt>" in the endpoint
URL of the request.
If the client does not close the connection, the server will wait forever when no timeout is specified.

<p>
	     <h3><a name="tth_sEc12.9">
12.9</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Chunked Transfer Encoding</font></h3>

<p>
gSOAP supports HTTP chunked transfer encoding. Un-chunking of inbound messages takes place automatically. Outbound messages are
never chunked, except when the <i>soap.chunked_transfer=1</i> is set, where <i>soap</i> is the current gSOAP run-time
environment. Most Web services, however, will not accept chunked inbound messages. Note that chunking allows
<i>soap.disable_request_count=0</i> and <i>soap.disable_response_count=0</i>, <b>but not when DIME attachments are used</b>.

<p>
	     <h3><a name="tth_sEc12.10">
12.10</a>&nbsp;&nbsp;<font color="#0000FF">Timeout Management for Non-Blocking Operations</font></h3><a name="sec:timeout">
</a>

<p>
Socket connect, accept, send, and receive timeout values can be set to manage socket communication timeouts.
The <i>soap.connect_timeout</i>, <i>soap.accept_timeout</i>, <i>soap.send_timeout</i>, and <i>soap.recv_timeout</i>
attributes of the current gSOAP runtime environment <i>soap</i> can be
set to the appropriate user-defined socket send, receive, and accept timeout values.
A positive value measures the timeout in seconds. A negative timeout value measures the timeout in microseconds (10<sup><font face="symbol">-</font
>6</sup> sec).

<p>
The <i>soap.connect_timeout</i> specifies the timeout value for <i>soap_call_ns__method</i> calls.

<p>
The <i>soap.accept_timeout</i> specifies the timeout value for <i>soap_accept(&amp;soap)</i> calls.

<p>
The <i>soap.send_timeout</i> and <i>soap.recv_timeout</i> specify the timeout values for non-blocking socket I/O operations.

<p>
Example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.send_timeout = 10; <br />
soap.recv_timeout = 10; 
</td></tr></table><br></i>
This will result in a timeout if no data can be send in 10 seconds and no data is received within 10 seconds after initiating
a send or receive operation over the socket. A value of zero disables timeout, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap.send_timeout = 0; <br />
soap.recv_timeout = 0; 
</td></tr></table><br></i>
When a timeout occurs in send/receive operations, a <i>SOAP_EOF</i> exception will be raised (``end of file or no input'').
Negative timeout values measure timeouts in microseconds, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define uSec *-1 <br />
#define mSec *-1000 <br />
soap.accept_timeout = 10 uSec; <br />
soap.send_timeout = 20 mSec; <br />
soap.recv_timeout = 20 mSec;
</td></tr></table><br></i>
The macros improve readability.

<p>
<font color="#FF0000"><b>Caution</b></font>: Many Linux versions do not support non-blocking <i>connect()</i>. Therefore, setting <i>soap.connect_timeout</i> for
non-blocking <i>soap_call_ns__method</i> calls may not work under Linux.

<p>
	     <h3><a name="tth_sEc12.11">
12.11</a>&nbsp;&nbsp;<font color="#0000FF">Secure SOAP Clients with HTTPS/SSL</font></h3>

<p>
You need to install the OpenSSL library on your platform to enable secure SOAP clients to utilize HTTPS/SSL.
After installation, compile your application with option <i>-DWITH_OPENSSL</i>. For example on Linux:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_OPENSSL myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lssl -lcrypto</i>
</td></tr></table><br></span>
or Unix:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_OPENSSL myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lxnet -lsocket -lnsl -lssl -lcrypto</i>
</td></tr></table><br></span>
or you can add the following line to <i>stdsoap.h</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define WITH_OPENSSL
</td></tr></table><br></i>
A client program simply uses the prefix <i>https:</i> instead of <i>http:</i> in the endpoint URL of a remote method call to a
Web Service to use encrypted transfers (if the service supports HTTPS).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_call_ns__mymethod(&amp;soap, "https://domain/path/secure.cgi", "", ...);
</td></tr></table><br></i>

<p>
By default, server authentication is disabled. To enable server authentication, set the <i>require_server_auth</i> attribute of
the current gSOAP runtime environment (<i><b>struct</b>&nbsp;soap</i>) before a call is made:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap.require_server_auth = 1;
</td></tr></table><br></i>
This will force server authentication for all calls over HTTPS.

<p>
Make sure you have signal handlers set in your application to catch broken connections (<i>SIGPIPE</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
signal(SIGPIPE, sigpipe_handle);
</td></tr></table><br></i>
where, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;sigpipe_handle(<b>int</b>&nbsp;x) { }
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc12.12">
12.12</a>&nbsp;&nbsp;<font color="#0000FF">Secure SOAP Web Services with HTTPS/SSL</font></h3>

<p>
When a Web Service is installed as CGI, it uses standard I/O that is encryped/decrypted by the Web server that runs the CGI
application.
Therefore, HTTPS/SSL support must be configured for the Web server (not Web Service).

<p>
SSL support for stand-alone gSOAP Web services is accomplished by calling <i>soap_ssl_accept</i> after <i>soap_accept</i>.
In addition, a key file, CA file, DH file, and password need to be supplied. Instructions on how to do this can be found in the
OpenSSL documentation.
To enable OpenSSL, first install OpenSSL and use option <i>-DWITH_OPENSSL</i> with your C or C++ compiler, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_OPENSSL -o myprog myprog.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lssl -lcrypto</i>
</td></tr></table><br></span>
Let's take a look at an example SSL secure
multi-threaded stand-alone SOAP Web Service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; <br />
&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap, *tsoap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.keyfile = "server.pem"; // must be resident key file <br />
&nbsp;&nbsp;&nbsp;soap.cafile = "cacert.pem"; // must be resident CA file <br />
&nbsp;&nbsp;&nbsp;soap.dhfile = "dh512.pem"; // must be resident DH file <br />
&nbsp;&nbsp;&nbsp;soap.password = "password"; // password <br />
&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, "linprog2.cs.fsu.edu", 18000, 100); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;fprintf(stderr, "Socket connection successful: master socket = %d<tt>\</tt>n", m); <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(;;) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, "Socket connection successful: slave socket = %d<tt>\</tt>n", s); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_ssl_accept(&amp;soap)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap = soap_new(); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!tsoap) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap<tt>-&gt;</tt>socket = soap.socket; // set by soap_accept <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap<tt>-&gt;</tt>ssl = soap.ssl; // set by soap_ssl_accept <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap<tt>-&gt;</tt>bio = soap.bio; // set by soap_ssl_accept <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, &amp;process_request, (<b>void</b>*)tsoap); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
}  <br />
<b>void</b>&nbsp;*process_request(<b>void</b>&nbsp;*soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;pthread_detach(pthread_self()); <br />
&nbsp;&nbsp;&nbsp;soap_serve((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_end((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;free(soap); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
}
</td></tr></table><br></i>
In case Web services have to verify clients, use a key file, CA file, and password in an SSL-enabled client:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
soap_init(&amp;soap); <br />
soap.keyfile = "client.pem"; <br />
soap.password = "password"; <br />
soap.cafile = "cacert.pem"; <br />
<b>if</b>&nbsp;(soap_call_ns__method(&amp;soap, "https://linprog2.cs.fsu.edu:18000", "", ...) <br />
...
</td></tr></table><br></i>
Make sure you have signal handlers set in your service and/or client applications to catch broken connections (<i>SIGPIPE</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
signal(SIGPIPE, sigpipe_handle);
</td></tr></table><br></i>
where, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;sigpipe_handle(<b>int</b>&nbsp;x) { }
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc12.13">
12.13</a>&nbsp;&nbsp;<font color="#0000FF">Client-Side Cookie Support</font></h3>

<p>
Client-side cookie support is optional. To enable cookie support, compile with option <i>-DWITH_COOKIES</i>, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_COOKIES -o myclient stdsoap2.cpp soapC.cpp soapClient.cpp</i>
</td></tr></table><br></span>
or add the following line to <i>stdsoap.h</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define WITH_COOKIES
</td></tr></table><br></i>
Client-side cookie support is fully automatic. So just (re)compile <i>stdsoap2.cpp</i> with <i>-DWITH_COOKIES</i> to enable
cookie-based session control in your client.

<p>
A database of cookies is kept and returned to the appropriate servers.
Cookies are not automatically saved to a
file by a client. So the internal cookie database is discarded when
the client program terminates.

<p>
To avoid "cookie storms" caused by malicious servers that return an 
unreasonable amount of cookies, gSOAP clients/servers are restricted to
a database size that the user can limit (32 cookies by default), for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.cookie_max = 10;
</td></tr></table><br></i>
The cookie database is a linked list pointed to by <i>soap.cookies</i> where each node is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap_cookie <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*value; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*domain; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*path; <br />
&nbsp;&nbsp;&nbsp;<b>long</b>&nbsp;expire; /* client-side: local time to expire; server-side: seconds to expire */ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;version; <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;secure; <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;session; /* server-side */ <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;env; /* server-side: got cookie from client */ <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;modified; /* server-side: client cookie was modified */ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap_cookie *next; <br />
};
</td></tr></table><br></i>
Since the cookie database is linked to a <i>soap</i> struct, each thread has a local cookie database in a multi-threaded
implementation.

<p>
	     <h3><a name="tth_sEc12.14">
12.14</a>&nbsp;&nbsp;<font color="#0000FF">Server-Side Cookie Support</font></h3>

<p>
Server-side cookie support is optional. To enable cookie support, compile with option <i>-DWITH_COOKIES</i>, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_COOKIES -o myserver ...</i>
</td></tr></table><br></span>
gSOAP provides the following cookie API for server-side cookie session control:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap_cookie *soap_set_cookie(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*value, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add a cookie to the database with name <i>name</i> and value <i>value</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns pointer to a cookie node in the linked list, or NULL otherwise. </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap_cookie *soap_cookie(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find a cookie in the database with name <i>name</i> and value <i>value</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns pointer to a cookie node in the linked list, or NULL otherwise. </td></tr>
<tr><td><i><b>char</b>&nbsp;*soap_cookie_value(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get value of a cookie in the database with name <i>name</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns the string pointer to the value, or NULL otherwise. </td></tr>
<tr><td><i><b>long</b>&nbsp;soap_cookie_expire(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get expiration value of the cookie in the database with name <i>name</i> (in seconds). </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the expiration value, or -1 if cookie does not exist. </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_set_cookie_expire(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>long</b>&nbsp;expire, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set expiration value <i>expire</i> of the cookie in the database with name <i>name</i> (in seconds). </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise. </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_set_cookie_session(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set cookie in the database with name <i>name</i> to be a session cookie. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This means that the cookie will be returned to the client. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Only cookies that are modified are returned to the client). </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise. </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_clr_cookie_session(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clear cookie in the database with name <i>name</i> to be a session cookie. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise. </td></tr>
<tr><td><i><b>void</b>&nbsp;soap_clr_cookie(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remove cookie from the database with name <i>name</i>. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>. </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_getenv_cookies(<b>struct</b>&nbsp;soap *soap);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Initializes cookie database by reading the 'HTTP_COOKIE' environment variable. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This provides a means for a CGI application to read cookies send by a client. </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise. </td></tr>
<tr><td><i><b>void</b>&nbsp;soap_free_cookies(<b>struct</b>&nbsp;soap *soap);</i> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Release cookie database. </td></tr></table>

</td></tr></table><br></span>
The following global variables are used to define the current domain and path:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Attribute</b></font> </td><td><font color="#FF0000"><b>value</b></font> </td></tr>
<tr><td><i><b>const</b>&nbsp;<b>char</b>&nbsp;*cookie_domain</i> </td><td>MUST be set to the domain (host) of the service </td></tr>
<tr><td><i><b>const</b>&nbsp;<b>char</b>&nbsp;*cookie_path</i> </td><td>MAY be set to the default path to the service </td></tr>
<tr><td><i><b>int</b>&nbsp;cookie_max</i> </td><td>maximum cookie database size (default=32) </td></tr></table>

</td></tr></table><br></span>
The <i>cookie_path</i> value is used to filter cookies intended for this service according to the path prefix rules outlined in
RFC2109.

<p>
The following example server adopts cookies for session control:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.cookie_domain = "..."; <br />
&nbsp;&nbsp;&nbsp;soap.cookie_path = "/"; // the path which is used to filter/set cookies with this destination <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc  &lt;  2) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_getenv_cookies(&amp;soap); // CGI app: grab cookies from 'HTTP_COOKIE' env var <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, NULL, atoi(argv[1]), 100); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 1; ; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap);		// clean up  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_free_cookies(&amp;soap);	// remove all old cookies from database so no interference occurs with the arrival of new cookies <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>int</b>&nbsp;ck__demo(<b>struct</b>&nbsp;soap *soap, ...) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;n; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*s; <br />
&nbsp;&nbsp;&nbsp;s = soap_cookie_value(soap, "demo", NULL, NULL); // cookie returned by client? <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!s) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = "init-value"; // no: set initial cookie value <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... // modify 's' to reflect session control <br />
&nbsp;&nbsp;&nbsp;soap_set_cookie(soap, "demo", s, NULL, NULL); <br />
&nbsp;&nbsp;&nbsp;soap_set_cookie_expire(soap, "demo", 5, NULL, NULL); // cookie may expire at client-side in 5 seconds <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc12.15">
12.15</a>&nbsp;&nbsp;<font color="#0000FF">Connecting Clients Through Proxy Servers</font></h3>

<p>
When a client needs to connect to a Web Service through a proxy server, set the <i>soap.proxy_host</i> string and
<i>soap.proxy_port</i> integer attributes of the current <i>soap</i> runtime environment to the proxy's host name and port, respectively. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.proxy_host = "proxyhostname"; <br />
soap.proxy_port = 8080; <br />
<b>if</b>&nbsp;(soap_call_ns__method(&amp;soap, "http://host:port/path", "action", ...)) <br />
&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
<b>else</b><br />
&nbsp;&nbsp;&nbsp;...
</td></tr></table><br></i>
The attributes <i>soap.proxy_host</i> and <i>soap.proxy_port</i> keep their values throug the remove method calls,
so they only need to be set once.

<p>
	     <h3><a name="tth_sEc12.16">
12.16</a>&nbsp;&nbsp;<font color="#0000FF">FastCGI Support</font></h3>

<p>
To enable FastCGI support, install FastCGI and compile with option <i>-DWITH_FASTCGI</i> or add
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define WITH_FASTCGI
</td></tr></table><br></i>
to <i>stdsoap2.h</i>.

<p>
</body>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.00.<br />On 14 Jul 2002, 22:18.</small>
</html>
