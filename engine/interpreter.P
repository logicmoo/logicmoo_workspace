/* 
LPS Interpreter, by Bob Kowalski and Fariba Sadri. 
Contributions by David Wei and Miguel Calejo.

Copyright (c) 2016, Imperial College, London
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

% RAK interpreter, based partly on Wei's interpreter. November-December
% 2016.

%%% LOAD THIS FILE to start LPS

:- module(interpreter, [
	go/0, go/1, go/2, go/3,
	test_examples/0, build_all_test_results/0, do_test_suite/2, load_test_file_for/1,
	load_check_syntax/2, my_term_to_atom/2, collect_current_fluents/2, collect_current_actions/2, collect_guessed_declarations/1,
	lps_engine_directory/1, uassert/1, uretractall/1,
	bindAllVars/1]).

% This fact will contain this file's directory; its presence also denotes "LPS running"
:- dynamic lps_engine_directory/1.

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).

:- consult:current_loaded_file(F), parse_filename(F,D,_,_), retractall(lps_engine_directory(_)), assert(lps_engine_directory(D)).
:- lps_engine_directory(D), string:concat_atom([D,'../Wei-engine/db.P'],DB), ensure_loaded(DB).

:- use_module(db,[
	action/1, current_time/1, d_pre/1, event/1,
	fluent/1, happens/3, (initiated)/3, l_events/2, l_int/2,
	l_timeless/2, (observe)/2, reactive_rule/2, reactive_rule/3, state/1,
	steps/1, (terminated)/3, used/1, maxTime/1,
	current_goal/1, depth/1, tried/3, option/1, initial_state/1, lps_updating_current_state/0,
	lps_test_result_item/3, lps_test_result/3, lps_test_options/1, 
	lps_failed_test/2,
	(events)/1, (fluents)/1, (actions)/1,
	my_load_dyn/2, head_hint/3]).

:- use_module(usermod,[lps_source_position/4]). % support Prolog Studio error reporting

% assert in usermod, if X imported from there... see SWI comment below
uassert(X) :- assert(X). 
uassertz(X) :- assertz(X).
uretract(X) :- retract(X).
uretractall(X) :- retractall(X).
u_user_predicate(X) :- functor(X,F,N), current_predicate(F/N).
callprolog(G) :- catch(G,_,fail).

:- use_module(basics, [length/2, member/2, append/3, select/3, reverse/2]).
:- use_module(lists, [append_lists/2]).
:- use_module(subsumes,[variant/2]).
:- use_module(num_vars,[numbervars/1]).
:- use_module(string,[concat_atom/2, term_to_codes/2]).
:- use_module(format,[format/2]).
:- use_module(standard,[datime/1]).
date_stamp(D) :- datime(Date), fmt_write_string(D,"%d-%02d-%02d at %02d:%02d:%02d",Date).

:- use_module(shell,[list_directory/2, is_directory/1]).

lps_examples_directory(ED) :- 
	lps_engine_directory(D), 
	concat_atom([D,'/../examples'], E), expand_filename(E,ED).

my_term_to_codes(T,C) :- atomize_zero_functors(T,NT), term_to_codes(NT,C).

% atomize_zero_functors(+Term,-NewTerm) replaces subterms foo() by 'foo'
% turnaround to bug reported by Miguel to XSB folks on May 24, 2016
atomize_zero_functors(T,NT) :- var(T), !, NT=T.
atomize_zero_functors(T,NT) :- functor(T,F,0), atom(F), !, NT=F.
atomize_zero_functors(T,NT) :- atomic(T), !, NT=T.
atomize_zero_functors([T1|Tn],[NT1|NTn]) :- !, atomize_zero_functors(T1,NT1), atomize_zero_functors(Tn,NTn).
atomize_zero_functors(T,NT) :- T=..[F|Args], atomize_zero_functors(Args,NewArgs), NT=..[F|NewArgs].

my_term_to_atom(T,A) :- my_term_to_codes(T,C), atom_codes(A,C).

print_error(Type,Message,_Position) :- write('SYNTAX '), write(Type), write(': '), writeln(Message).

:- endif.

%%% end of XSB specific section; now for SWI:

:- if((current_prolog_flag(dialect, swi), current_module(swish))).

% First a SWISH specificity - rather than use the db module, will use pengine's dynamic module

:- use_module(library(pengines),[pengine_self/1]).

% If performance becomes bad (due to nonindexed access inside the pengine_self predicate) we should pass M as arg
% Implementation note: execution specific states (cf. cleanup_engine) might be stored instead by simply using thread_local declarations

action(X) :- pengine_self(M), catch(M:action(X),_,fail).
current_goal(X) :- pengine_self(M), M:current_goal(X).
current_time(X) :- pengine_self(M), M:current_time(X).
lps_updating_current_state :- pengine_self(M), catch(M:lps_updating_current_state,_,fail).
d_pre(X) :- pengine_self(M), catch(M:d_pre(X),_,fail).
depth(X) :- pengine_self(M), catch(M:depth(X),_,fail).
event(X) :- pengine_self(M), catch(M:event(X),_,fail).
fluent(X) :- pengine_self(M), catch(M:fluent(X),_,fail).
happens(X,Y,Z) :- pengine_self(M), catch(M:happens(X,Y,Z),_,fail).
initial_state(X) :- pengine_self(M), catch(M:initial_state(X),_,fail).
initiated(X,Y,Z) :- pengine_self(M), catch(M:initiated(X,Y,Z),_,fail).
l_events(X,Y) :- pengine_self(M), catch(M:l_events(X,Y),_,fail).
l_int(X,Y) :- pengine_self(M), catch(M:l_int(X,Y),_,fail).
l_timeless(X,Y) :- pengine_self(M), catch(M:l_timeless(X,Y),_,fail).
maxTime(X) :- pengine_self(M), catch(M:maxTime(X),_,fail).
observe(X,Y) :- pengine_self(M), catch(M:observe(X,Y),_,fail).
% TODO: interference with SWI ???
option(X) :- pengine_self(M), catch(M:option(X),_,fail).
reactive_rule(X,Y) :- pengine_self(M), catch(M:reactive_rule(X,Y),_,fail).
reactive_rule(X,Y,Z) :- pengine_self(M), catch(M:reactive_rule(X,Y,Z),_,fail).
state(X) :- pengine_self(M), catch(M:state(X),_,fail).
steps(X) :- pengine_self(M), M:steps(X).
terminated(X,Y,Z) :- pengine_self(M), catch(M:terminated(X,Y,Z),_,fail).
tried(X,Y,Z) :- pengine_self(M), catch(M:tried(X,Y,Z),_,fail).
used(X) :- pengine_self(M), catch(M:used(X),_,fail).
lps_test_options(X) :- pengine_self(M), catch(M:lps_tes_options(X),_,fail).
lps_test_result_item(X,Y,Z) :- pengine_self(M), catch(M:lps_test_result_item(X,Y,Z),_,fail).
lps_test_result(X,Y,Z) :- pengine_self(M), catch(M:lps_test_result(X,Y,Z),_,fail).
lps_failed_test(X,Y) :- pengine_self(M), catch(M:lps_failed_test(X,Y),_,fail).
events(X) :- pengine_self(M), catch(M:events(X),_,fail).
fluents(X) :- pengine_self(M), catch(M:fluents(X),_,fail).
actions(X) :- pengine_self(M), catch(M:actions(X),_,fail).
% probably not used:
my_load_dyn(X,Y) :- pengine_self(M), M:my_load_dyn(X,Y).

uassert(X) :- pengine_self(M), catch(assert(M:X),_,true). 
uassertz(X) :- pengine_self(M), catch(assertz(M:X),_,true).
% uretractall(X) :- pengine_self(M), catch(retractall(M:X),_,true).
uretractall(X) :- pengine_self(M), retractall(M:X).
uretract(X) :- pengine_self(M), retract(M:X).
u_user_predicate(X) :- functor(X,F,N),  pengine_self(M), current_predicate(M:F/N).
callprolog(G) :- predicate_property(G,built_in), !, G.
callprolog(G) :- pengine_self(M), catch(call(M:G),_,fail).

u_swiclause(H,B,Ref) :- pengine_self(M), clause(M:H,B,Ref).
:- endif.


:- if((current_prolog_flag(dialect, swi), \+ current_module(swish))).
% Now support for vanilla SWI Prolog
:- use_module('../Wei-engine/db.P',[
	action/1, current_time/1, d_pre/1 ,event/1,
	fluent/1, happens/3, (initiated)/3, l_events/2, l_int/2,
	l_timeless/2, (observe)/2, reactive_rule/2, reactive_rule/3, state/1,
	steps/1, (terminated)/3, used/1, maxTime/1,
	current_goal/1, depth/1, tried/3, option/1, lps_updating_current_state/0,
	initial_state/1,
	lps_test_result_item/3, lps_test_result/3, lps_test_options/1, 
	lps_failed_test/2,
	(events)/1, (fluents)/1, (actions)/1,
	my_load_dyn/2,
	head_hint/3]).

uassert(X) :- assert(db:X). 
uassertz(X) :- assertz(db:X).
uretractall(X) :- retractall(db:X).
uretract(X) :- retract(db:X).
u_user_predicate(X) :- functor(X,F,N), current_predicate(db:F/N).

callprolog(G) :- predicate_property(G,built_in), !, G.
callprolog(G) :- catch(db:G,_,fail).

u_swiclause(H,B,Ref) :- clause(db:H,B,Ref).

:- endif.

:- if(current_prolog_flag(dialect, swi)).
% ...and finally the generic SWI support

:- prolog_load_context(directory, D), retractall(lps_engine_directory(_)), assert(lps_engine_directory(D)).

:- op(900,fy,not).

:- use_module(library(lists), [member/2, append/3, select/3, reverse/2]).
:- use_module(library(prolog_clause),[clause_info/5]).

append_lists([],[]).
append_lists([X|Xs],L) :-
	append(X,T,L),
	append_lists(Xs,T).
:- use_module(library(terms),[variant/2]).
:- use_module(library(varnumbers),[numbervars/1]).
term_to_codes(T,C) :- term_to_atom(T,A), atom_codes(A,C).
my_term_to_atom(T,A) :- term_to_atom(T,A).
concat_atom(L,A) :- atomic_list_concat(L,A).
%:- use_module(format,[format/2]).
:- use_module(library(dialect/sicstus/system),[datime/1,file_exists/1]).
date_stamp(D) :- datime(Date), Date=..[_|Args], format(atom(D),"~d-~d-~d at ~d:~d:~d",Args).

list_directory(D,F) :- directory_files(D,Files), member(F,Files).
is_directory(D) :- exists_directory(D).
expand_filename(F,Path) :- expand_file_name(F,[Path]).

:- use_module(library(filesex),[relative_file_name/3]).
lps_examples_directory(ED) :- 
	lps_engine_directory(D), 
	concat_atom([D,'/'],DD), % hack, don't know where to fetch OS-dependent separator
	relative_file_name(ED,DD,'../examples').

cputime(T) :- T is cputime.

% NO LONGER returns Pos as in http://www.swi-prolog.org/pldoc/man?predicate=read_term/2 (subterm_positions)
% returns Pos as file(File,LineNumber,_one,_Char) - one line is known
lps_source_position(Term,FileWithExt,file(FileWithExt,LineNumber,_One,_Char),Vars) :- 
	functor(Term,F,N), functor(Term_,F,N), 
	u_swiclause(Term_,Body,Ref), 
	variant(Term,Term_),
	!,
	% clause_info(Ref,FileWithExt,Pos,_VO).
	clause_info(Ref, FileWithExt, _TermPos, _VarOffsets, [variable_names(Vars)]),
	term_variables((Term_:-Body),VarValues), 
	Term=Term_,
	bindAllVars(VarValues,Vars),
	clause_property(Ref,line_count(LineNumber)).


print_error(Type,Message,Position) :- 
	print_message(Type,error(syntax_error(Message),Position)). % SWI's universal messaging pipeline

%% Now for an implementation available only on SWI:

% resolveUntilAction(Goal) 
% Execute goal until an action is found, then calls shift(candidateAction(A)), suspending computation
% On backtracking into some goals, suspend computation with shift(later), allowing such goals a later chance
resolveUntilAction([]) :- !.
resolveUntilAction([G1|Gn]) :- !, 
	resolveUntilAction(G1), resolveUntilAction(Gn).
resolveUntilAction(not(holds(F,T))) :- !, 
	query(not(holds(F,T))).
resolveUntilAction(holds(F,T)) :- query(holds(F,T)).
resolveUntilAction(holds(F,T)) :- !, % on failure, delay if that makes sense
	current_time(Now), once((var(T);T>Now)),
	shift(later), resolveUntilAction(holds(F,T)).
resolveUntilAction(happens(E,T1,T2)) :- nonvar(T1), current_time(Now), T1>Now, !,
	shift(later), resolveUntilAction(happens(E,T1,T2)).
resolveUntilAction(happens(E,T1,T2)) :- macroaction(E), !, 
	l_events(happens(E,T1,T2),Body), resolveUntilAction(Body).
resolveUntilAction(happens(E,T1,T2)) :- 
	action_(E), % Is this condition necessary...?
	shift(candidateAction(happens(E,T1,T2))), % suspend and return candidate
	happens(E,T1,T2).
resolveUntilAction(happens(E,T1,T2)) :- !, % on failure, delay if that makes sense
	current_time(Now), Next is Now+1,
	once((var(T1),var(T2);nonvar(T1),T1>Now;nonvar(T2),T2>Next)),
	shift(later), resolveUntilAction(happens(E,T1,T2)).
resolveUntilAction(tc(G)) :- ground(G), G.
resolveUntilAction(tc(G)) :- !, \+ ground(G), shift(later), resolveUntilAction(tc(G)).
resolveUntilAction(G) :- l_timeless(G,Body), evaluate(Body).
resolveUntilAction(G) :- callprolog(G).

% dc_resolve_goals(Goals,NewGoals) NewGoals contains goals delayed because of pending actions
% Fails if all Goals can not be solved with admissible actions
dc_resolve_goals([],[]) :- !.
dc_resolve_goals(_Unfinished, end):-
	steps(N), N < 1, !.
dc_resolve_goals([goal(G)|Goals],NewGoals) :-
	write_verbose(['Goal is ',G,'.',nl]),
	reset(resolveUntilAction(G),Ball,Continuation),
	(Continuation==0 -> % resolved G completely:
		dc_resolve_goals(Goals,NewGoals) 
	; % we suspended the execution:
		dc_resolve_goals_suspended(G,Goals,Ball,Continuation,NewGoals)
	).

% Decide what to do, depending on the cause of suspension: found an action, or failed something that may succeed later
dc_resolve_goals_suspended(G,Goals,candidateAction(A),Continuation,NewGoals) :-
	!,
	write_verbose(['Suspended for action ',A,' while executing ',G, nl]),
	A=happens(_A,T1,T2),
	current_time(Now), Next is Now+1,
	((nonvar(T1),T1<Now) -> fail ; true), % outdated event should fail
	((nonvar(T1),T1>Now) -> % it's still too soon, postpone it:
		dc_resolve_goals(Goals,NewGoals_),
		NewGoals = [goal([A,Continuation])|NewGoals_]
	; 
		T1=Now, T2=Next,
		( \+ A-> (uassertz(A), write_verbose(['Asserting ',A,nl]);uretractall(A), write_verbose(['Retracting ',A,nl]), fail) ; true), %%% uretractall here, on failure! and then fail!!!
		( (d_pre(Conds),holds_all(Conds)) -> fail % preconditions would be violated
			% resume with asserted compatible action:
			; dc_resolve_goals([goal(Continuation)|Goals],NewGoals)
		)
	).
dc_resolve_goals_suspended(G,Goals,later,Continuation,[goal(Continuation)|NewGoals_]) :-
	write_verbose([' Delayed while executing ',G, nl]),
	dc_resolve_goals(Goals,NewGoals_).


:- endif.

%%% end of SWI and Prolog engine-specific code

%%% From here on, generic Prolog code

my_load_dyn(F) :- my_load_dyn(F,false).

% my_term_size(Item,Size)  
% could use XSB's native term_size, but I was having troublbuildEe aligning it with the following for SWI, so...
my_term_size(T,1) :- var(T), !.
my_term_size([T|TT],N) :- !, my_term_size(T,N1), my_term_size(TT,N2), N is N1+N2.
my_term_size([],1) :- !.
my_term_size(T,1) :- atomic(T), !.
my_term_size(T,N) :- T=..[_|L], my_term_size(L,N2), N is N2+1.

% Suffix typically being .extension
all_files_in(Directory,Suffix,Files) :-
	(is_list(Suffix)->Suffix=SuffixCodes;atom_codes(Suffix,SuffixCodes)),
	findall( File, (
		list_directory(Directory,F), 
		F \== '.', F \== '..',
		concat_atom([Directory,'/',F],FullF),
		(is_directory(FullF) -> 
			all_files_in(FullF,Suffix,DFiles), member(File,DFiles) 
			; 
			atom_codes(F,FC), 
			append(_PFcodes,SuffixCodes,FC), 
			concat_atom([Directory,'/',F],File))
		),
		Files).

% for each .lpsw file (Wei syntax), generate its test result file
% BEWARE, this will assume the WHOLE examples subtree runs well!
build_all_test_results :- 
	lps_examples_directory(ED),
	all_files_in(ED,'.lpsw',Files),
	writeln('Generating test results for files:'), writeln(Files),
	do_test_suite(Files,[make_test,verbose]).

% add rules to trigger "meta" actions which document the occurrence of composite events
add_meta_reactive_rules :-
	forall( l_events(E,_), 
		uassert( expanded_reactive_rule([E],[happens(lps_meta(E),_T3,_)]) ) ),
	uassert(action(lps_meta(_))). % No swish support, needs revision!
	
% Clean up execution of a single LPS program.
cleanup_engine :- 
    uretractall(expanded_reactive_rule(_,_)),
    uretractall(expanded_reactive_rule(_,_,_)),
    uretractall(current_goal(_)),
    uretractall(current_time(_)),
    uretractall(depth(_)),
    uretractall(expanded_consequent(_,_)),
    uretractall(failed(_, _, _)),
    uretractall(happens(_, _, _)),
    uretractall(state(_)),
    uretractall(steps(_)),
    uretractall(tried(_, _, _)),
    uretractall(used(_)),
    % uretractall(this_initiated(_)),
    uretractall(lps_failed_test(_,_)),
    uretractall(lps_test_result(_,_,_)),
    uretractall(lps_test_result_item(_,_,_)),
    uretractall(lps_test_options(_)).

% Clear an LPS program to run another LPS program.
cleanup_program :- option(swish), !. % program is loaded into dynamic module
cleanup_program :-
    uretractall(actions(_)),
    uretractall(action(_)),
    uretractall(d_pre(_)),
    uretractall(events(_)),
    uretractall(event(_)),
    uretractall(fluents(_)),
    uretractall(fluent(_)),
    uretractall(initial_state(_)),
    uretractall(initiated(_, _, _)),
    uretractall(l_events(_, _)),
    uretractall(l_int(_, _)),
    uretractall(l_timeless(_, _)),
    uretractall(observe(_, _)),
    uretractall(reactive_rule(_, _)),
    uretractall(reactive_rule(_, _, _)),
    uretractall(terminated(_, _, _)),
    uretractall(maxTime(_)).


% obtained from Kowalski's gorak 
%
% go(+File)
%
go(File) :- go(File, []).

go :- go(_,[verbose,swish]). % makes sense only on swish

go(File, OptionsList) :- go(File, OptionsList,[]).

% ResultFluents is a list of Fluent-Instances, obtained at the end of execution in the final state
%  Instances is a list (ordered by setof)
go(File, OptionsList, ResultFluents) :-
	forall(member(RF,ResultFluents), (nonvar(RF), RF=_-_)),
	parse_options(OptionsList),
	(nonvar(File) -> true; 
			( (option(make_test), \+ option(swish)) -> writeln(user_error, 'ERROR in options: make_test requires a File name'), fail 
			; true)),
	cleanup_program, cleanup_engine,
	init_test_file(File),
	(\+ option(swish) -> 
		my_load_dyn(File)
		; true),
	collect_guessed_declarations(Facts),
	forall(member(Fact,Facts),uassert(Fact)),
	% fails if errors occur:
	print_errors(File), 
	(option(meta_actions) -> add_meta_reactive_rules ; true),
	( initial_state(IS) -> assert_list(IS) ; true),
	( option(delta_state(State)), member(F,State),
		(F = + Fluent -> uassert(state(Fluent)) ; F = - Fluent -> uretractall(state(Fluent))),
		fail
		; true
	),
	cputime(T0),
	
    	uassertz(current_time(1)),
    	uassertz(steps(100)),
    	uassertz(current_goal(0)),
    	uassertz(depth(0)),
	uassertz(used(0)),
    	(option(ultra_verbose)->
    		current_prolog_flag(write_depth,Old), 
    		set_xsb_flag(write_depth,10000) % ultra_verbose only remembered for xsb
   	;true),
    	cputime(T1),
	findall(reactive_rule(A, C), (reactive_rule(A, C);reactive_rule(A,C,_P)), R0), % drop priorities, if any
	findall(S,state(S),IS_),
	test(fluents,0,IS_),
	cycle(R0, []),
	!,
	cputime(T2),
	print_statistics(T0,T1,T2),
	close_test_file(File),
	(option(ultra_verbose)->set_xsb_flag(write_depth,Old);true),
		% ultra_verbose only remembered for xsb
	collect_results(ResultFluents).

% These internal predicates are necessary to aggregate all declarations
% TODO: generate and assert all, to get indexing
action_(A) :- action(A) ; actions(Actions), member(A,Actions).
event_(E) :- event(E) ; events(Events), member(E,Events).
fluent_(F) :- fluent(F) ; fluents(Fluents), member(F,Fluents).

% parameter for declaration generation by alternative syntaxes; 'false' may help LPS program debugging
add_automatic_declarations(false). % 'true' will add fluent, event and action declarations guessed from usage; 

% collect_guessed_declarations(-List). 
%  This was originally in psyntax; it may be called more than once, but only the first run actually does anything
collect_guessed_declarations(L) :-
	findall(Fact,(
		add_automatic_declarations(true), uretract(head_hint(X,Type,false)), Type \== timeless, Fact=..[Type,X]
		), L).

collect_results([]) :- !.
collect_results([F-R|FR]) :- (setof(F,query(holds(F,_)),R)->true;R=[]), collect_results(FR).

% collect_fluents(Fluents,Instances)
collect_current_fluents([F|Fluents],Instances) :- !,
	(setof(F,query(holds(F,_)),R)->true;R=[]),
	collect_current_fluents(Fluents,Instances1),
	append(R,Instances1,Instances).
collect_current_fluents([],[]).

% collect_actions(Actions,Instances)  actions or events
collect_current_actions([A|Actions],Instances) :- !,
	(setof(A, happens(A,_,_) , R)->true;R=[]),
	collect_current_actions(Actions,Instances1),
	append(R,Instances1,Instances).
collect_current_actions([],[]).
	
print_statistics(_,_,_) :- option(silent), !.
print_statistics(T0,_T1,T2) :- 
	TotalT is T2-T0,
	current_time(Next), Cycles is Next-1,
	nl, format("** ~d cycles took ~f seconds **\n",[Cycles,TotalT]).

% check_syntax(+File,-Notices) Returns a list of notice(Type,Message,Position)
%  Type is 'error' or 'warning', Position is some term denoting a source file location
%  Position will be 'unknown'... unless our environment provides a definition for lps_source_position/4
%  Predicates called here typically have as second argument a notices list with a single
%  element... or they simply fail
check_syntax(F,Notices) :-
	findall(N, 
		(
			( Rule = reactive_rule(A, C) ; Rule = reactive_rule(A,C,_)), % TODO: should check priority too
			Rule,
			(source_position(Rule,F,Pos,Vars), 
			(check_reactive_rule(A,Pos,Vars,[N]) ; check_reactive_rule(C,Pos,Vars,[N])))
			), 
		RR),
	findall(N, 
		(
			l_int(P, B), 
			source_position(l_int(P, B),F,Pos,Vars), 
			( 
				\+ ((nonvar(P), P = holds(_,_))), 
				buildError(P,Vars,' is not a valid intensional predicate',ET),
				N=notice(error,ET,Pos) 
				; 
				check_lp_int(B,Pos,Vars,[N])) ), 
		IP), 
	findall(N, 
		(
			l_events(P, B), 
			source_position(l_events(P, B),F,Pos,Vars),
			( 
				\+ ((nonvar(P), P = happens(_,_,_))), 
				buildError(P,Vars,' is not a valid composite event predicate',ET), 
				N=notice(error,ET,Pos) 
				; 
				check_lp_events(B,Pos,Vars,[N])) ), 
		CE),
	findall(N, (d_pre(B),source_position(d_pre(B),F,Pos,Vars),check_d(B, d_pre, Pos, Vars, [N])), PC),
	findall(N,(
		initiated(Ev, Fl, Cond), 
		source_position(initiated(Ev, Fl, Cond),F,Pos,Vars),
		(
			((nonvar(Ev), Ev = happens(Ev2, _, _)) -> 
				( d_event(Ev2) -> fail 
				; 
				buildError(Ev2,Vars,' in initiated post-condition must be a simple event (event/action) predicate',ET), 
				N=notice(error,ET,Pos)
				)
			; 
				buildError(Ev,Vars,' is not a valid domain initiated post-condition predicate',ET), 
				N=notice(error,ET,Pos)
			)
		;
			\+ d_head(Fl), 
			buildError(Fl,Vars,' in initiated post-condition must be an extensional fluent predicate',ET), 
			N=notice(error,ET,Pos)
		;
			check_d(Cond, 'i post-condition', Pos, Vars,[N])
		) ), 
		PostI),
	findall(N,(
		terminated(Ev, Fl, Cond), 
		source_position(terminated(Ev, Fl, Cond),F,Pos,Vars),
		(
			((nonvar(Ev), Ev = happens(Ev2, _, _)) -> 
				( d_event(Ev2) -> fail 
				; 
				buildError(Ev2,Vars,' in terminated post-condition must be a simple event (event/action) predicate',ET), 
				N=notice(error,ET,Pos)
				)
			; 
				buildError(Ev,Vars,' is not a valid domain terminated post-condition predicate',ET), 
				N=notice(error,ET,Pos)
			)
		;
			\+ d_head(Fl), 
			buildError(Fl,Vars,' in terminated post-condition must be an extensional fluent predicate',ET), 
			N=notice(error,ET,Pos)
		;
			check_d(Cond, 't post-condition', Pos, Vars,[N])
		) ), 
		PostT),
	append_lists([RR,IP,CE,PC,PostI,PostT],Notices).

% buildError(BadSubterm,Vars,Message,NoticeSubterm)  Assume the new syntax to be the preferred for reporting errors:
%  this introduces a dependency on psyntax, should probably have a hook or refactor further... oh well.
buildError(BadSubterm,Vars,Message,NoticeSubterm) :-
	copy_term(BadSubterm+Vars,BadSubterm_+Vars_),
	buildError(BadSubterm_,Vars_,Vars,Message,NoticeSubterm).
buildError(X,Vars_,Vars,M,subterm(X,MM)) :- catch(psyntax:syntax2p_literal(NicerTerm,[],lps2p,_,_,X),_,fail), !, 
	Vars=Vars_, bindAllVars(Vars),
	concat_terms([NicerTerm,M],MM). % should probably use SWI's term_string and make sure M quotes do not make it to the output
buildError(X,Vars,Vars,M,subterm(X,MM)) :- bindAllVars(Vars), concat_terms([X,M],MM).

% also closes var tailed lists
bindAllVars([]) :- !.
bindAllVars([VV|Vars]) :- 
	arg(1,VV,Name), arg(2,VV,Value), 
	(var(Value) -> Value=Name ; true), bindAllVars(Vars).

% bindAllVars(+VarValues,?NameValuePairs).
bindAllVars(Values,Pairs) :- length(Values,N), length(Pairs,N), !,
	bindAllVars_(Values,Pairs).
bindAllVars(_Values,_Pairs). % probably extra time vars, we lost information in the transform, can't recover var names
	
bindAllVars_([V|Vs],[Pair|Pairs]) :- !, arg(2,Pair,V), bindAllVars_(Vs,Pairs).
bindAllVars_([],_NameValuePairs).

% May call an external predicate hook to find the position
% position for Prolog Studio is t(CharPosition,TermIndex), for SWI / swish see lps_source_position/4 above
source_position(Term,F,Position,Vars) :- catch(lps_source_position(Term,F,Position,Vars),_,fail), !.
source_position(_,_,unknown,[]).
	
% fails if errors occur:
print_errors(File) :- 
	check_syntax(File,Notices), nl,
	( 
		member(notice(Type,M,Position),Notices), 
		(M=subterm(_,M_)->true;M=M_),
		print_error(Type,M_,Position), 
		fail 
	; Notices=[]),
	((option(priority), \+ reactive_rule(_,_,_)) 
		-> writeln('WARNING: no rules with priority present!') 
		; true),
	(( \+ option(priority), \+ reactive_rule(_,_))
		-> writeln('WARNING: no priority-less reactive rules are present!')
		; true).

concat_terms(Terms,Atom) :- concat_terms(Terms,[],Codes), atom_codes(Atom,Codes).

concat_terms([T1|Tn],C,Cn) :- term_to_codes(T1,C1), append(C,C1,C2), concat_terms(Tn,C2,Cn).
concat_terms([],C,C).

check_reactive_rule([H|T], Pos, Vars,NT) :-
    reactive_conjunct(H),
    !,
    check_reactive_rule(T, Pos, Vars,NT).
check_reactive_rule([H|_], Pos, Vars,[notice(error,ET,Pos)]) :- !,
    buildError(H,Vars,' is not a valid reactive rule conjunct',ET).
check_reactive_rule(H, Pos, Vars,[notice(error,ET,Pos)]) :- \+ is_list(H),
    buildError(H,Vars,' must be a list',ET).
    
check_lp_int([H|T], Pos, Vars,NT) :-
    l_int_body(H), !,
    check_lp_int(T, Pos,Vars, NT).
check_lp_int([H|_], Pos, Vars,[notice(error,ET,Pos)]) :-
    buildError(H,Vars,' is not a valid L_int body',ET).

check_lp_events([H|T], Pos, Vars,NT) :-
    l_events_body(H), !,
    check_lp_events(T, Pos, Vars,NT).
check_lp_events([H|_], Pos, Vars, [notice(error,ET,Pos)]) :-
    buildError(H,Vars,' is not a valid L_events body',ET).

check_d([H|T], What, Pos, Vars, NT) :-
    d_body(H), !,
    check_d(T, What, Pos, Vars, NT).
check_d([H|_], What, Pos, Vars, [notice(error,ET,Pos)]) :-
    concat_terms([' is not a valid ',What,' body'],M),
    buildError(H,Vars,M,ET).
    
% this may be called by environment tools; see check_syntax/2
load_check_syntax(File,Notices) :-
	cleanup_program,
	% Let's assume Prolog syntactic errors are reported elsewhere:
	catch(my_load_dyn(File),_E,true), 
	check_syntax(File,Notices).

assert_list([]).
assert_list([H|T]) :-
    uassertz(state(H)),
    assert_list(T).

% last cycle
endTime(T) :- maxTime(T), !.
endTime(20). % default duration of execution

% parse_options(OptionsList)
%
parse_options(Options) :- 
	uretractall(option(_)),
	% when running a test the options will be imposed by the test file:
	(member(run_test,Options) -> Options=[_]; true),
	( (member(silent,Options), (member(verbose,Options);member(ultra_verbose,Options))) ->
		writeln(user_error, 'ERROR in options: silent incompatible with verbose and ultra_verbose.'), fail
		; true),
	( (member(cycle_hook(_),Options), (member(make_test,Options) ; member(manual,Options))) ->
		writeln(user_error, 'ERROR in options: cycle_hook incompatible with make_test and with manual.'), fail
		; true),
	( (member(meta_actions,Options), member(swish,Options)) ->
		writeln(user_error, 'ERROR in options: meta_actions not supported on SWISH.'), fail
		; true),		
	parse_options_(Options).

parse_options_([]) :- !.
parse_options_([swish|Rest]) :- !, % don't cleanup db (nor load the program), the environment will do it
    uassertz(option(swish)),
    parse_options_(Rest).
parse_options_([dc|Rest]) :- !,
    (current_prolog_flag(dialect, swi) 
    	-> uassertz(option(dc)) 
    	; 
    	writeln(user_error, 'ERROR in options: delimited continuations are available only for SWI Prolog '),
    	fail
    	),
    parse_options_(Rest).
parse_options_([verbose|Rest]) :- !,
    uassertz(option(verbose)),
    parse_options_(Rest).
% Increase the default maximum written term depth, to avoid '...' output
parse_options_([ultra_verbose|Rest]) :- !,
    uassertz(option(verbose)),
    (current_prolog_flag(dialect, xsb) 
    	-> uassertz(option(ultra_verbose)) 
    	; writeln(user_error, 'WARNING: ultra_verbose option considered only for XSB Prolog ')
    	),
    parse_options_(Rest).
parse_options_([silent|Rest]) :- !,
    uassertz(option(silent)),
    parse_options_(Rest).
parse_options_([make_test|Rest]) :- !,
	(member(manual,Rest) ->  
		writeln(user_error, 'ERROR in options: with make_test you can not use ''manual''.'), fail
		; true),
	uassertz(option(make_test)),
	parse_options_(Rest).
parse_options_([run_test|Rest]) :- !,
	uassertz(option(run_test)),
	parse_options_(Rest).
parse_options_([meta_actions|Rest]) :- !,
	uassertz(option(meta_actions)),
	parse_options_(Rest).
parse_options_([cycle_hook(Predicate,Fluents,Actions)|Rest]) :- !,
	% Fluents and (basic) Actions are lists of templates; the cycle hook predicate should collect all matching tuples
	((atom(Predicate),is_list(Fluents),is_list(Actions))->true
	; writeln(user_error, 'ERROR in options: cycle_hook first argument must be an atom, a predicate name; then fluent and action lists.'), fail),
	uassertz(option(cycle_hook(Predicate,Fluents,Actions))),
	parse_options_(Rest).
parse_options_([observations(Obs)|Rest]) :- !,
	((is_list(Obs), forall(member(observe(L,T),Obs),(is_list(L),integer(T))) ) -> true
	; writeln(user_error, 'ERROR in options: observations must contain a list of observe(List,Time).'), fail),
	uassertz(option(observations(Obs))),
	parse_options_(Rest).
parse_options_([delta_state(State)|Rest]) :- !,
	((is_list(State), forall(member(F,State), (nonvar(F), (F = + _ ; F = - _ ))) ) -> true
	; writeln(user_error, 'ERROR in options: delta_state must contain a list of +Fluent or -Fluent.'), fail),
	uassertz(option(delta_state(State))),
	parse_options_(Rest).
parse_options_([O|Rest]) :- 
    write(user_error, 'WARNING: Ignored option '), writeln(user_error,O),
    parse_options_(Rest).


write_verbose(What) :-
    ( option(verbose) ->
        do_write(What)
    ;
        true
    ).

do_write([]) :- !.

do_write([pprint_goal(What)|Rest]) :- !,
    pprint_goal(What),
    do_write(Rest).

do_write([nl|Rest]) :- !,
    nl,
    do_write(Rest).

do_write([What|Rest]) :- !,
    write(What),
    do_write(Rest).

pprint_goal([]).

pprint_goal([goal(_, [H|_])|Rest]) :-
    write(H),nl,
    pprint_goal(Rest).

pprint_goal([goal(_, _, [H|_])|Rest]) :-
    write(H),nl,
    pprint_goal(Rest).

% init_test_file(Filename)
% Load test file for this program file  
% if not running tests does nothing
init_test_file(F) :- option(run_test), !, % guaranteed to be the only option
	load_test_file_for(F),
	lps_test_options(Options),
	% add the options:
	parse_options(Options), % cleans options and loads from file...
	uassert(option(run_test)). %...this one not being there
init_test_file(_F).

load_test_file_for(F) :-
	test_filename(F,TF),
	catch(my_load_dyn(TF,false),E,true),
	(nonvar(E) -> 
		write(user_error, 'ERROR: could not load test file '), writeln(user_error,TF), writeln(user_error,E),
		writeln(user_error,' To obtain a test file you need to execute your program with the make_test option: go(YourFile,[make_test])'),
		fail
		; true).

% close_test_file(ProgramFile)
close_test_file(F) :- var(F), !.
close_test_file(F) :- option(make_test), \+ option(swish),  !,
	test_filename(F,TF),
	telling(Old), tell(TF),
	date_stamp(D),
	writeln('/*'), write('  LPS test results file generated on '), writeln(D), 
	write('  on Prolog '), current_prolog_flag(version_data,P), write(P),
	writeln(' for program file:'),
	write('  '), writeln(F), writeln('*/'), nl,
	write((:- dynamic lps_test_result/3, lps_test_result_item/3, lps_test_options/1)), writeln('.'),
	nl,
	writeln('% LPS options prior to the test:'),
	setof(O,option(O),Options),
	select(make_test,Options,RealOptions),
	write(lps_test_options(RealOptions)), writeln('.'), nl,
	writeln('% lps_test_result(Stage,Cycle,TestTerm)'),
	(lps_test_result(S,C,T), writeq(lps_test_result(S,C,T)), writeln('.'), fail ; true),
	writeln('% lps_test_result_item(Stage,Cycle,TestTerm)'),
	(lps_test_result_item(S,C,T), writeq(lps_test_result_item(S,C,T)), writeln('.'), fail ; true),
	told, tell(Old).
close_test_file(F) :- option(run_test), !,  
	test_filename(F,TF),
	nl,
	( \+ lps_failed_test(_,_) -> Result=' (ok)'; Result=' (FAILED)'),
	write('*** Tests ended with '), write(TF), write(Result), writeln(' ****').
close_test_file(_F).

% test_filename(+ProgramFile,-TestFile)
% Names the test file as the programs's plus '.lpst' (LPS test file)
test_filename(PF,TF) :- 
	expand_filename(PF,Path),
	concat_atom([Path,'.lpst'],TF).
	
% test_filename(+ProgramFile,-TestFile)
% Names the test file as the programs's plus '.lpst' (LPS test file)
test_filename(PF,TF) :- 
	expand_filename(PF,Path),
	concat_atom([Path,'.lpst'],TF).
	
% test(Stage,Cycle,Term)
% Remembers or checks that at this Stage and Cycle, Term is obtained
% Requires the Term to be a LIST
% if term size is too big an abstraction is stored, and it is NOT verified
test(Stage,Cycle,Term) :- option(make_test), !,
	is_list(Term),
	\+ \+ (( 
		numbervars(Term), length(Term,N), uassert(lps_test_result(Stage,Cycle,N)),
		forall(member(Item,Term),assert_lps_test_result_item(Stage,Cycle,Item))
		)).
test(Stage,Cycle,Term) :- option(run_test), !,
	% fails if the test fails:
	( lps_test_result(Stage,Cycle,N) -> true 
	  ; 
	  	write('FAILED test '), writeln(Stage/Cycle/Term), 
	  	writeln('Missing test fact.'), 
	  	uassert(lps_failed_test(lps_test_result(Stage,Cycle,Term),missing_fact)), 
	  	fail),
	findall(Item,lps_test_result_item(Stage,Cycle,Item),Test), 
	% numbervars(Test),
	( \+ \+ ((length(Term,N), /*numbervars(Term),*/ test_items_ok(Term,Test)) )
		-> true
		; 
		write('FAILED test '), writeln(Stage/Cycle/Term), write('Expected '), writeln(Test), 
		uassert(lps_failed_test(lps_test_result(Stage,Cycle,Term),Test)),
		fail).
test(_,_,_).

% test_items_ok(+Actual,+Test)
test_items_ok([A|An],[lps_gigantic(Size)|Tn]) :- !,
	% Must recalculate term size after numbervars, otherwise would be different:
	\+ \+ (numbervars(A),my_term_size(A,Size_), Size_ == Size), 
	test_items_ok(An,Tn).
test_items_ok([A|An],[T|Tn]) :- !,
	variant(A,T),
	test_items_ok(An,Tn).
test_items_ok([],[]).

% assert_lps_test_result_item(Stage,Cycle,Item) Gigantic terms are abstracted as lps_gigantic(Size)
assert_lps_test_result_item(Stage,Cycle,Item) :- 
	my_term_size(Item,Size), 
	( Size > 1000 -> Item_=lps_gigantic(Size) ; Item_=Item),
	uassert(lps_test_result_item(Stage,Cycle,Item_)).
	

% test all programs in the LPS examples directory tree which have a .lpst file present
test_examples :- 
	lps_examples_directory(ED),
	all_files_in(ED,'.lpst',TFiles),
	atom_codes('.lpst',LPST),
	findall(ProgramFile,(
		member(TFile,TFiles), atom_codes(TFile,Tcodes),
		append(PCodes,LPST,Tcodes),atom_codes(ProgramFile,PCodes)
		),Files),
	do_test_suite(Files,[run_test]).

% do_test_suite(Files,Options)  
%  Options must contain make_test or run_test, optionally more; Files are either LPS or test result files resp.

do_test_suite(Files,Options) :-
	(member(run_test,Options);member(make_test,Options)), 
	!,
	writeln('*** Starting test suite, will report at the end...'),
	do_test_suite(Files,Options,Results),
	nl, write('*** Test suite ended ('), write(Options), writeln('):'),
	( member(F-R,Results), write(F), write(': '), writeln(R), fail; true),
	writeln('*** End of test suite results').

% do_test_suite(Files,Options,Results)  Results is a list of File - ok/failed
do_test_suite([],_Option,[]) :- !.
do_test_suite([F|Files],Options,[F-R|Results]) :- 
	expand_filename(F,Path),
	file_exists(Path),
	!,
	go(Path,Options),
	( \+ lps_failed_test(_,_) -> R=ok 
	; 
	findall(LPSR/Expected,lps_failed_test(LPSR,Expected),Failures), R=failed(Failures) 
	),
	do_test_suite(Files,Options,Results).
do_test_suite([_|Files],Options,Results) :- do_test_suite(Files,Options,Results).


%  cycle(PartialReactiveRules,GoalState)
%  GoalState is a list (conjunction) of goal(Id,Tree)
%  Tree is a list representing the current branch of the tree.
cycle(_Ri, Gi) :-
	current_time(Time), endTime(M), M < Time,
	!,nl, write_verbose([' Time is up. Unsolved goals: ',nl,Gi]).

cycle(Ri, Gi) :-
	current_time(Time),  Previous is Time - 1 ,Next is Time +1,
    	( option(cycle_hook(Predicate,_,_)) -> 
    		HookGoal =.. [Predicate,ExternalObservations],
		(HookGoal -> true ; writeln('* LPS cycle hook goal failed, terminating.'), fail)
    	; ExternalObservations=[]),
	(Time = 1 -> updateEvents(0, 1, ExternalObservations)   ; true),
	% At this point last cycle events are still available
    	% TODO: ExternalObservations to be injected as new events
	findall(Action, happens(Action, Previous, Time), Actions),
	write_verbose([nl, '----- time is now ',Time,' -----',nl]),
	write_verbose([nl, ' Events and actions from ', Previous, ' to ', Time,' are ',Actions,nl]),
	test(events,Time,Actions),
	enter_step_0, % during updateFluents we need a hack to query the previous state
	updateFluents(Time),
	findall(Fluent, state(Fluent), Fluents), % setof doesn't work.
	write_verbose([nl,' State at time ',Time,' is ',Fluents]),
	test(fluents,Time,Fluents),
	leave_step_0,
	% This processes antecedents of rules:
	(option(dc) -> dc_process(Ri, [], NRi, [], NewGi), nl, writeln(nRi-NRi) ; process(Ri, [], NRi, [], NewGi)),
	write_verbose([nl,
		' Process reactive rules at time ',Time, nl,'Old:  ',Ri, nl, ' New:  ', NRi,  nl,
		' Process goal tree at time ',Time, nl,' New: ',NewGi, nl]),
	append(Gi, NewGi, NGi), % Puts new goals at the end of the queue.
	uretractall(happens(_, _, _)),
	updateEvents(Time, Next, ExternalObservations),
	% This resolves goals in the goal state.
	(option(dc) -> once( dc_resolve_goals(NGi,GoalTree) ) ; resolve_tree(NGi, [], GoalTree)),
	(GoalTree = end -> 
		write_verbose([nl,' Exceeded number of steps. ',nl])	
		;	
		(option(dc) -> NextGi=GoalTree ; removeSolvedGoals(GoalTree, [], NextGi)),
		next_time, 
		cycle(NRi, NextGi)
	).

% Update any observed events, including events injectd from the outside, e.g. Java API
updateEvents(Time, Next, ExternalObservations) :-  
	forall( (observe(Evs, Next),member(E, Evs) ; member(E,ExternalObservations)), uassertz(happens(E, Time, Next))) -> true
     ; true.

enter_step_0 :- uassert(lps_updating_current_state).
leave_step_0 :- uretractall(lps_updating_current_state).

%   Destructively update the state.
updateFluents(Time) :-
	findall(Fl, (happens(Ev, Previous, Time), terminated(happens(Ev, Previous, Time), Fl, Cond), holds_all(Cond)), Terms),
	findall(Fl, (happens(Ev, Previous, Time), initiated(happens(Ev, Previous, Time), Fl, Cond), holds_all(Cond)), Inits),
	forall((member(Fl, Terms), state(Fl)), uretractall(state(Fl))),
    	forall((member(Fl, Inits), \+ state(Fl)), uassertz(state(Fl))).

removeSolvedGoals([], NextGi, NextGi).

removeSolvedGoals([goal(GId, Branch) | GoalTree], AccGi, FinalGi):-
     (Branch = [[] | _] ->
        uretractall(tried(GId, _, _)), removeSolvedGoals(GoalTree, AccGi, FinalGi)
      ; removeSolvedGoals(GoalTree, [goal(GId, Branch) | AccGi], FinalGi)).

% process(RulesToProcess, RulesProcessed, FinalRules, GoalsSoFar, FinalGoals).
%	
process([], Rs, Rs, NG, NG) :- !.

% Antecedent is []. Add Consequent as new goal/tree.
process([reactive_rule([], C) | Rs], AccRi, NRi, AccG, NGi):- !, generate_id(GId),
	process(Rs, AccRi, NRi, [goal(GId, [C]) | AccG], NGi ).

% Cannot be resolved now. Leave for later.
process([reactive_rule([L | Ls], C) | Rs], AccRi, NRi, AccG, NGi):-
	(L = holds(_, T); L = happens(_,_, T)),
	ground(T), current_time(Now), T > Now,
	!,
	process(Rs, [reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi).

% Negation of fluent P at time T = current time. If P holds then drop
% the reactive rule. If P doesn't hold, then delete not P from the rule.
% Need similar case for prolog atom.
process([reactive_rule([L | Ls], C) | Rs], AccRi, NRi, AccG, NGi):-
	(L = not(holds(P, T)); L = (holds(not(P), T))),!,
	copy_term( reactive_rule([holds(P, T) |Ls], C), reactive_rule([holds(CP, CT) |CLs], CC) ),
	current_time(Now),
	(   query(holds(CP, Now)) -> (T==Now -> process(Rs, AccRi, NRi, AccG, NGi)
				     ;	 process(Rs, [reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi))
	;   CT=Now, process([reactive_rule( CLs, CC) | Rs], AccRi, NRi, AccG, NGi)).

% Cannot be resolved now. Too late, no longer relevant.
process([reactive_rule([L |_],_) | Rs], AccRi, NRi, AccG, NGi):-
	(L = holds(_, T); L = happens(_,_, T)),
	ground(T), current_time(Now), T < Now,
	!,
	process(Rs, AccRi, NRi, AccG, NGi).

%Cannot be resolved now. Either delete or leave for later cycles.
% Perhaps this clause can be made into or already is a special case of
% the next clause. In fact, it might be possible to combine all four
% clauses into one clause. Desirable?
process([reactive_rule([L |Ls], C) | Rs], AccRi, NRi, AccG, NGi):-
%	copy_term([L|Ls], [CL|_]), %copy_term not needed?
	\+ lpsClause(L, _),
	!,
	(mustBeProcessedNow(L) -> process(Rs, AccRi, NRi, AccG, NGi)
	;  process(Rs, [reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi)).

% Can be resolved now.
process([reactive_rule([L |Ls], C) | Rs], AccRi, NRi, AccG, NGi) :-
      copy_term(reactive_rule([L |Ls], C) , reactive_rule([CL |CLs], CC)),
%      lpsClause(CL, Body),
%	setof(lpsClause(CL, Body), lpsClause(CL, Body), AllClauses),
%	nl, write(' all clauses that match the head of the reactive rule
%	'), write(AllClauses), nl, setof(reactive_rule(Resolvent,CC),
%	(member(lpsClause(CL, Body), AllClauses), append(Body, CLs,
%	Resolvent)), NewR ),
	findall(reactive_rule(Resolvent,CC) , 
	(lpsClause(CL, Body),append(Body, CLs, Resolvent)), NewR ),
%	nl, write(' all resolvents of the head '),write(L), write(' of
%	the reactive rule are '),
%	write(NewR), nl,
	append(NewR, Rs, NextRs),
       (mustBeProcessedNow(L)
%	nl, write(' must be processed now '),write(L),
            -> process(NextRs, AccRi, NRi, AccG, NGi)
            ;  process(NextRs,[reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi)).

generate_id(New) :-
	used(Id),New is Id+1, uretract(used(Id)), uassertz(used(New)).

% resolve_tree(Goal/tree/branches still to be processed, Goals already processed, Final goals)
% candidate actions happens(e,t, t+1) are asserted in the form happens(e,t, t+1) and,
% if necessary, deleted on backtracking. Otherwise, they persist.

% Goals already processed are in reverse of the original order. Original order needs to be recovered.
% Difference lists could be used instead. Retract all tried actions is a
% hack, to remove and tried actions not removed by clause 4 of resolve.
% There should be a more elegant solution.
resolve_tree([], NewAccG, FinalG) :- !,
	reverse(NewAccG, FinalG),
	uretractall(tried(_GoalId, _Depth, lpsClause(happens(_A,_T,_), []))).

% terminate with message: “Requires too much thinking.”
resolve_tree(_Unfinished, _AccG, end):-
	steps(N), N < 1, !.

/*
Alternatively, continue:
resolve_tree(Unfinished, AccG, NextGoals):-
	steps(N), N < 1, reverse(AccG, RevAccG), append(Unfinished, RevAccG, NextGoals),
	nl,write(' Exceeded number of steps. '), nl.
*/

% An alternative to asserting and retracting depth is simply to compute
% depth when necessary, or pass as a parameter of resolve.
resolve_tree([goal(GoalId, [ [L|Ls] | Bs]) | Gs], AccG, FinalG) :-
	uretractall(current_goal(_)), uassertz(current_goal(GoalId)),
	uretractall(depth(_)),length([ [L|Ls] | Bs], Depth),
	uassertz(depth(Depth)),
     resolve([L|Ls], Result),
	write_verbose([' Goal is ',L, nl,'. Result/resolvent is ',Result,nl]),
	(Result = fail -> (backtrack([goal(GoalId,[[L|Ls]|Bs])|Gs], NextTree, AccG, NewAccG)
%	 nl, write(L), write(' fails. Backtracking: next tree '),
%	 write(NextTree) nl, write('new accumulated tree '),
%	 write(NewAccG), nl
	 )
	; (Result = later -> (continue([goal(GoalId,[[L|Ls]|Bs])|Gs], NextTree, AccG, NewAccG)
%	nl, write('continue next tree '), write(NextTree),
%	nl, write(' new accumulated tree '), write(NewAccG), nl
	 )
	; (advance(Result, [goal(GoalId, [ [L|Ls] | Bs]) | Gs], NextTree, AccG, NewAccG)
%	nl, write('advance next tree '), write(NextTree),
%	nl, write(' new accumulated tree '), write(NewAccG), nl
	  ))
	 
	 ),
	resolve_tree(NextTree, NewAccG, FinalG).


% Clause 0. Negation of fluent P at time T = current time. If P holds
% then fail. If P doesn't hold, then delete not P from the goal.
% Need similar case for L the negation of a prolog atom.
resolve([L | Ls],Result):-
	(L = not(holds(P, T)); L = (holds(not(P), T))),!,
	reduce_step,
	copy_term(holds(P, T), holds(CP, _CT)),
	current_time(Now),
	(   query(holds(CP, Now)) -> (T==Now -> Result = fail ; Result = later)
	;   (T=Now, Result = Ls) ).

resolve([L|_], later) :- 
	(L = holds(_, T); L = happens(_, T, _)),
	ground(T), current_time(Now), T > Now, !.

%Clause 1. No clause resolves with L.
resolve([L|_], Result) :-
%		copy_term([L|Ls], [CL|_]), %copy_term not needed?
		\+ lpsClause(L, _),
		reduce_step,
%		nl, write(' no clause resolves with '), write(L), nl,
		\+ (L = happens(A, _, _), action_(A)),
		(mustBeResolvedNow(L) -> Result = fail
		; Result = later).
%		  write('clause 1. try later: '), write(L), nl) ).

% Clause 2. Untried clause resolves with L.
resolve([L|Ls], Result) :-
	copy_term([L|Ls], [CL|CLs]),
	\+ (L = happens(A, _, _), action_(A)),
	lpsClause(CL, Body),
	reduce_step,
	current_goal(GoalId), depth(Depth),
	\+ tried(GoalId, Depth, lpsClause(CL, Body)),
     uassertz(tried(GoalId, Depth, lpsClause(CL, Body))),
	append(Body, CLs, Result).
%	write(' -------- tried '), write([GoalId, Depth, lpsClause(CL,
%	Body)]) , nl.

% Clause 3. Clauses resolve with L, but all have been tried.
resolve([L|Ls], Result) :-
	%current_time(Now), Next is Now+1,
	copy_term([L|Ls], [CL|_]),  %Don't need copy_term?
	\+ (L = happens(A, _, _), action_(A)),
	lpsClause(CL, Body),
	% !,
	reduce_step,
	current_goal(GoalId), depth(Depth),
	!,
    	findall(lpsClause(CL, Body), lpsClause(CL, Body), AllClauses),
%    write(' All clauses that resolve with '), write(L), write(' are '),
%    nl, write(AllClauses), nl,
    	forall(member(Clause, AllClauses), tried(GoalId, Depth, Clause) ),% Problem if this fails?
%    write(' All clauses that resolve with '), write(L), write(' have
%    been tried. '), nl,
	(mustBeResolvedNow(L) -> (Result = fail
%				 ,
%	 write('failed all clauses tried  '), write(L), nl
				 )
	; Result = later).

% Clause 4. L is an action.
resolve([L|Ls], Result) :-
	L = happens(A, T, _), action_(A), current_time(Now),
	copy_term([L|Ls], [CL|_CLs]),
	reduce_step,
	current_goal(GoalId),
	depth(Depth),
	(   tried(GoalId, Depth, lpsClause(CL, [])) ->
		    (( T == Now ->
		      Result = fail
%		       write(' action failed  '), write(L), nl
		    ; Result = later ),
		    uretractall(happens(A,T,_)),
		    uretractall(tried(GoalId, Depth, lpsClause(CL, []))))
%		      write('clause 4. try action later '), write(L),
%		      nl)))
        ;   candidateAction([L | Ls], Result) ).

% candidateAction([CA| _], Result) Result == fail   Result==later...
candidateAction([L| Ls], Result) :-
	copy_term([L|Ls], [CL|CLs]),
	current_time(Now), Next is Now+1,current_goal(GoalId),
	L = happens(A, T, _), CL = happens(A, Now, Next),
	depth(Depth),
	( happens(A, Now, Next)-> true ; uassertz(happens(A, Now, Next))),
	uassertz(tried(GoalId, Depth, lpsClause(CL, []))),
	( 
		( d_pre(Conds), holds_all(Conds) )->
			uretractall(happens(A, Now, Next)), 
			(T = Now ->  % This used to be == ; with = this approximates the proposed Bob fix
				Result = fail;  
				Result =  later)
	;  Result = CLs ).


/* Bob original fix: candidateAction([L| Ls], Result) :-
	copy_term([L|Ls], [CL|CLs]),
	current_time(Now), Next is Now+1,current_goal(GoalId),
	L = happens(A, _, _), CL = happens(A, Now, Next),
	depth(Depth),
	( happens(A, Now, Next)-> true ; uassertz(happens(A, Now, Next))),
	uassertz(tried(GoalId, Depth, lpsClause(CL, []))),
	( (d_pre(Conds), holds_all(Conds)) ->
		uretractall(happens(A, Now, Next)), 
		Result = fail
	;  Result = CLs ). */

lpsClause(Head, Body) :-  l_timeless(Head, Body).
lpsClause(Head, Body) :-  l_events(Head, Body).
lpsClause(Head, Body) :-  l_int(Head, Body).
lpsClause(happens(X, Y, Z), []) :- happens(X, Y, Z).
lpsClause(holds(X, Y), []) :- current_time(Y), state(X).
lpsClause(tc(_), []).  % This ignores temporal constraints completely.
lpsClause(P, []) :- \+l_timeless(P,_),\+l_events(P,_),\+l_int(P,_),
	\+P = happens(_,_,_), \+P= holds(_,_), callprolog(P).

% mustBeProcessedNow(L) is used when unfolding atoms in antecedents of rules.
% true if L is extensional fluent or basic event with known time, intensional fluent/composite event or timeless/Prolog
mustBeProcessedNow(holds(_, T)) :-
	ground(T), current_time(Now),  T =< Now, !.
mustBeProcessedNow(happens(_, _, T)) :-
	ground(T), current_time(Now),  T =< Now, !.
mustBeProcessedNow(holds(P, _)) :-
	intensional(P), \+ fluent_(P),!.
	% Not necessary if extensional and intentional predicates are disjoint.
mustBeProcessedNow(happens(A,_,_)) :-
	macroaction(A), \+ action_(A),  !.
	% Not necessary if actions and macroactions are disjoint.
mustBeProcessedNow(P) :- prolog(P).

prolog(P) :- \+ P = happens(_,_,_), \+ P = holds(_,_).

intensional(P) :-  P =.. [Pred | Args], length(Args, L),
	length(Args2, L), Q =.. [Pred |Args2],
	 l_int(holds(Q, _), _).
macroaction(A):- functor(A,F,N), functor(Q,F,N), l_events(happens(Q, _,_), _), !.

%mustBeResolvedNow is used when unfolding atoms in goal clauses,
mustBeResolvedNow(happens(X, T, _)) :-
	action_(X), ground(T), current_time(Now), T == Now, !.
mustBeResolvedNow(P) :- mustBeProcessedNow(P),
	\+ (P = happens(_, _, T),ground(T), current_time(Now), T =< Now).

% To be done: Top-level goal lpsClause B1 failed, and no further
% backtracking possible.
%  backtrack([goal(GoalId, [ B1]) | Gs], NextTree,% [], NewAccG) :-
%  then terminate everything, and output that the goals are not
%  satisfiable.

% Top-level goal lpsClause B1 failed. Backtrack to LastB. Save B1 to retry later.
backtrack([goal(GoalId, [ B1]) | Gs], [NextBranch, goal(GoalId, [B1]) | Gs],
	  [LastBranch | PreviousBs], PreviousBs):-
	LastBranch = goal(GId, [LastLeaf | LastBs] ),
	length(LastBs, Depth),
	uretract(current_goal(_)), uassertz(current_goal(GId)),
	uretract(depth(_)), uretractall(tried(GoalId, _, _)),
%	((current_time(Now), Next is Now+1,
%	  B1 = [happens(A, _, _) | _], action_(A)) % could be
%	  risky/unnecessary
%	-> retractall(happens(A, Now, Next)) %risky/unnecessary?
%	; true),
	(LastLeaf = []
	->  (NextBranch = goal(GId, LastBs), uassertz(depth(Depth) ))
	; (NextBranch = LastBranch, D is Depth+1, uassertz(depth(D)))).

% Pop up one level if backtracking over empty goal lpsClause.
% backtrack([goal(GoalId, [ [] | Bs]) | Gs], [goal(GoalId, Bs) | Gs], AccG, AccG):-

% Pop up one level if backtracking over non-top clause.
backtrack([goal(GoalId,[_B1|Bs])|Gs], [goal(GoalId, Bs) | Gs],  AccG, AccG):-
	\+ Bs = [], depth(Depth), NewDepth is Depth - 1, 
	uretract(depth(Depth)),
	uassertz(depth(NewDepth)), uretractall(tried(GoalId,Depth, _)).
%	((current_time(Now), Next is Now+1,
%	  B1 = [happens(A, Now, Next) | _]) % could be risky/unnecessary
%	-> retractall(happens(A, Now, Next))
%	; true).

advance([], [goal(GoalId, [B1|Bs]) | Gs] , NextTree, AccG, NewAccG):-
	!, NextTree = Gs,
%	nl,write(' Next tree is  '), write(NextTree),nl,
	NewAccG = [goal(GoalId,[[], B1 | Bs])| AccG],
	(Gs = [] -> true ;(Gs =	[goal(GId, NextBranch) | _] ,
	uretract(depth(_)), length(NextBranch,D), uassertz(depth(D)),
	uretract(current_goal(_)), uassertz(current_goal(GId)))).

advance(Resolvent, [goal(GoalId, [B1|Bs]) | Gs] , NextTree, AccG, NewAccG):-
	\+ Resolvent = [],
	NextTree = [goal(GoalId, [Resolvent, B1 | Bs]) | Gs], NewAccG = AccG,
	depth(Depth), NewDepth is Depth +1, uretract(depth(Depth)),
	uassertz(depth(NewDepth)).

% Same as advance with [].
continue([goal(GoalId, [B1|Bs]) | Gs], NextTree,  AccG, NewAccG):-
	NextTree = Gs,
%	nl,write(' Next tree is  '), write(NextTree),nl,
%	retractall(tried(GoalId, _, _)), % This was an unexplainable
%	mistake?
	uretract(depth(_)), uretract(current_goal(_)),
	NewAccG = [goal(GoalId,  [B1 | Bs] ) | AccG],
	(Gs = [] -> true ;(Gs =	[goal(GId, NextBranch) | _] ,
	length(NextBranch,D), uassertz(depth(D)),
	uassertz(current_goal(GId)))).

/*
Notice that this assumes that atoms in goal lpsClauses B1 are written in temporal order.
Otherwise it would be necessary to skip over L but retain L and continue to process Ls.
This would be tricky.Notice also that the goal tree/branches in NewAccG are reversed.
This list will have to be reversed later, or difference lists could be used.
*/

% From Wei’s interpreter:

reduce_step() :-
    steps(C),
    NC is C-1,
    uretract(steps(C)),
    uassertz(steps(NC)).

% holds_all(+PL). True if all predicates in PL hold in the augmented
% state {S*_i, ev*_i, L_int, L_timeless}.
holds_all([]).
holds_all([P|Rest]) :-
    query(P),
    holds_all(Rest).

% query(+P). True if P holds in the augmented state {S*_i, ev*_i, L_int,
% L_timeless}.
%
query(not(holds(P, Now))) :- !, \+ query(holds(P,Now)).
query(holds(not(P), Now)) :- !, \+ query(holds(P,Now)).
query(holds(P, T)) :- 
	current_time(Now),
	( lps_updating_current_state -> RealNow is Now-1 ; RealNow=Now),
	( nonvar(T), T\== RealNow, throw(bad_query(holds(P, T))) ; true),
	T=RealNow, state(P).
query(holds(P, Now)) :- l_int(holds(P, Now), B), holds_all(B).
query(happens(P, X, Y)) :- happens(P, X, Y).
query(P) :-  
	P \= holds(_, _), P \= happens(_,_, _),
    	(\+ l_timeless(P, _B) -> callprolog(P) ; l_timeless(P, B), evaluate(B)).


evaluate([]).
evaluate([P|Rest]) :-query(P), evaluate(Rest).

% next_time().  Succeeds to the next time point. Destructively updates current_time/1 
next_time() :-
    current_time(This),
    uretract(current_time(This)),
    Next is This + 1,
    uassertz(current_time(Next)),
    uretract(steps(_)),
    uassertz(steps(30)).
 %  assertz(steps(1000)).

% fluent_pred(+Fl)
%   True if Fl is a fluent predicate symbol.
%
fluent_pred(Fl) :-
    % Extensional predicates, represent facts in the state S_i.
    fluent_(Fl).
fluent_pred(not(Fl)) :-
    fluent_(Fl).
fluent_pred(Fl) :-
    % Intensional predicates, defined in L_int.
    functor(Fl,F,N), functor(Fll,F,N),
    l_int(holds(Fll, _), _).
fluent_pred(not(Fl)) :-
    l_int(holds(Fl, _), _).


% event_pred(+Ev)
%   True if Ev is an event predicate symbol.
%
event_pred(Ev) :-
    % Simple event predicates, internally generated actions.
    action_(Ev) ; event_(Ev).
event_pred(Ev) :-
    % Composite event predicates, defined in L_events.
    functor(Ev,F,N), functor(Evv,F,N),
    l_events(happens(Evv, _, _), _).

% temp_constraint(+Term)
%   True if Term is an atomic temporal constraint formula.
%
temp_constraint(<(_,_)).
temp_constraint(=<(_,_)).

% reactive_conjunct(+Conj)
%   True if Conj is a valid conjunct in the antecedent or consequent of a
%   reactive rule.
%
reactive_conjunct(true) :- !.
reactive_conjunct(holds(P, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
reactive_conjunct(happens(E, _, _)) :- !,
    event_pred(E).
reactive_conjunct(X) :-
    l_timeless(X, _), !.
reactive_conjunct(tc(T)) :- !, % TODO: relax or revise
    temp_constraint(T).
reactive_conjunct(X) :- u_user_predicate(X).


% l_int_body(+P)
%
l_int_body(holds(P, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
l_int_body(P) :-
    functor(P,F,N), functor(PP,F,N),
    l_timeless(PP, _), !.
l_int_body(P) :- u_user_predicate(P).

% l_events_body(+P)
%
l_events_body(holds(P, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
l_events_body(happens(P, _, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    event_pred(PP).
l_events_body(tc(P)) :-
    temp_constraint(P).
l_events_body(P) :-
    functor(P,F,N), functor(PP,F,N),
    l_timeless(PP, _), !.
l_events_body(P) :- u_user_predicate(P).

% d_head(+H)
%
d_head(H) :-
    fluent_(H).

% d_event(+H)
%
d_event(H) :- action_(H).
d_event(H) :- event_(H).

% d_body(+B)
%
d_body(happens(B, _, _)) :- !,
    d_event(B).
d_body(holds(not(B), _)) :- !,
    fluent_(B).
d_body(holds(B, _)) :- !,
    fluent_(B).
d_body(B) :-
    functor(B,F,N), functor(BB,F,N),
    l_timeless(BB, _), !.
d_body(B) :- u_user_predicate(B).


% Although this predicate is "generic", it works with SWI-only predicates, see resolveUntilAction etc. above
% dc_process(RulesToProcess, RulesProcessed, FinalRules, GoalsSoFar, FinalGoals) 
%  called as dc_process(Ri, [], NRi, [], NewGi)
% alternative implementation of process/5 using delimited continuations (http://www.swi-prolog.org/pldoc/man?section=delcont)
% Goals are represented as goal(G)
dc_process([], Rs, Rs, NG, NG) :- !.

% Antecedent is []. Add Consequent as new goal/tree.
dc_process([reactive_rule([], C) | Rs], AccRi, NRi, AccG, NGi):- !, 
	dc_process(Rs, AccRi, NRi, [goal(C) | AccG], NGi ).
	
% Too late to solve, no longer relevant.
dc_process([reactive_rule([L |_],_) | Rs], AccRi, NRi, AccG, NGi):-
	current_time(Now), Next is Now+1,
	(
		L = holds(_, T), nonvar(T), T<Now
		; 
		L = happens(_,T1, T2), (nonvar(T1),T1<Now;nonvar(T2),T2<Next)
	),
	!,
	dc_process(Rs, AccRi, NRi, AccG, NGi).

% negation case, not covered by the findall below
dc_process([reactive_rule([L |Ls],C) | Rs], AccRi, NRi, AccG, NGi):-
	(L = not(holds(_,_)); L = (holds(not(_),_))),
	!,
	( \+ \+ query(L) -> 
		dc_process([reactive_rule(Ls,C) | Rs], AccRi, NRi, AccG, NGi)
		; dc_process(Rs, AccRi, NRi, AccG, NGi) 
	).

dc_process([reactive_rule([E | Ls], C) | Rs], AccRi, NRi, AccG, NGi):- 
	( mustBeProcessedNow(E) -> ItMust=true; ItMust=false),
	findall( reactive_rule(Antecedent,C), 
		( lpsClause(E,Body), append(Body,Ls,Antecedent ) ),
		NewRules),
	(NewRules==[] -> % rule antecedent fails, discard it or postpone it:
		( ItMust==true -> dc_process(Rs,AccRi, NRi, AccG, NGi) ; dc_process(Rs,[reactive_rule([E | Ls], C)|AccRi], NRi, AccG, NGi))
		; % else, consider all new rules instead of the given one:
		%( ItMust==true -> append(NewRules,Rs,RulesToProcess), AlreadyProcessed=AccRi ; RulesToProcess=Rs, append(NewRules,AccRi,AlreadyProcessed)),
		append(NewRules,Rs,RulesToProcess), AlreadyProcessed=AccRi,
		dc_process(RulesToProcess,[reactive_rule([E | Ls], C)|AlreadyProcessed], NRi, AccG, NGi)		
		% dc_process(RulesToProcess,AlreadyProcessed, NRi, AccG, NGi)
	).
%dc_process([R|Rs],AccRi,NRi,AccG, NGi) :- dc_process(Rs,[R|AccRi],NRi,AccG, NGi).






